C e C++
Le chiavi della programmazione
Carlo A. Mazzone

Ai sognatori di ogni età che non perdono
mai la passione per lo studio e la voglia
per la scoperta del nuovo e che,
attraverso i loro sogni, contribuiscono a
creare un mondo migliore.
Carlo A. Mazzone

C e C++ | Le chiavi della programmazione
Autore: Carlo A. Mazzone
Collana:
Editor in Chief: Marco Aleotti
Progetto grafico: Roberta Venturieri
Immagine di copertina: Gianluca Rotondo
Realizzazione editoriale e impaginazione: Studio Dedita di Davide Gianetti
© 2016 Edizioni Lswr* – Tutti i diritti riservati
ISBN: 978-88-6895-330-0
I diritti di traduzione, di memorizzazione elettronica, di riproduzione e adattamento totale o
parziale con qualsiasi mezzo (compresi i microfilm e le copie fotostatiche), sono riservati
per tutti i Paesi. Le fotocopie per uso personale del lettore possono essere effettuate nei
limiti del 15% di ciascun volume dietro pagamento alla SIAE del compenso previsto dall’art.
68, commi 4 e 5, della legge 22 aprile 1941 n. 633.
Le fotocopie effettuate per finalità di carattere professionale, economico o commerciale o
comunque per uso diverso da quello personale possono essere effettuate a seguito di
specifica autorizzazione rilasciata da CLEARedi, Centro Licenze e Autorizzazioni per le
Riproduzioni Editoriali, Corso di Porta Romana 108, 20122 Milano, e-mail
autorizzazioni@clearedi.org e sito web www.clearedi.org.
La presente pubblicazione contiene le opinioni dell’autore e ha lo scopo di fornire
informazioni precise e accurate. L’elaborazione dei testi, anche se curata con scrupolosa
attenzione, non può comportare specifiche responsabilità in capo all’autore e/o all’editore
per eventuali errori o inesattezze.
L’Editore ha compiuto ogni sforzo per ottenere e citare le fonti esatte delle illustrazioni.
Qualora in qualche caso non fosse riuscito a reperire gli aventi diritto è a disposizione per
rimediare a eventuali involontarie omissioni o errori nei riferimenti citati.
Tutti i marchi registrati citati appartengono ai legittimi proprietari.

Via G. Spadolini, 7
20141 Milano (MI)
Tel. 02 881841
www.edizionilswr.it
(*) Edizioni Lswr è un marchio di La Tribuna Srl. La Tribuna Srl fa parte di
.

Sommario
INTRODUZIONE 13
Parte 1 – Il linguaggio C e i fondamenti della
programmazione
1. PREMESSE E MOTIVAZIONI PER UNIRE LA
TEORIA
E LA PRATICA DELLA PROGRAMMAZIONE 23
Analogico versus digitale: la battaglia ormai persa 24
In principio era il bit 25
Quanti ne rappresento? 28
Nibble e Byte 28
Altre basi numeriche 28
Rappresentazione dei dati alfanumerici 30
Hardware e software 31
Linguaggi naturali e artificiali 39
I programmi traduttori 40
Interpreti e compilatori 43
A spasso con una “macchina virtuale” 43
Il C e le sue origini 44
Il C come primo linguaggio 46
Ambienti di sviluppo 46
Gli ambienti di sviluppo per il C 47

Creare programmi con interfaccia grafica 52

2. SALVE, MONDO 53
“Salve, mondo” con Dev-C++ 56
Salutiamo il mondo da Code::Blocks 64

3. LE VARIABILI E IL MONDO ESTERNO 69
Andiamo a capo 72
Input e output di base 73
Tipologie di variabili 75
Anche l’occhio vuole la sua parte 76
I nomi delle variabili 77
Le costanti 77
Quando le costanti sono tante: le enumerazioni 79

4. OPERIAMO SUI DATI 81
Aiuto: quanti problemi! 81
Algoritmo, la parola magica 82
I diagrammi di flusso 83
Operatori aritmetici 87
printf, la stampa e le specifiche di formattazione 88
Il casting delle variabili 90
Operatori di incremento e decremento 92
Operatori relazionali 93
Operatori logici 94

5. IL DEBUGGING DI UN’APPLICAZIONE 99

Fare debug con Dev-C++ 100
Il debug con Code::Blocks 107

6. ISTRUZIONI CONDIZIONALI: OPERIAMO DELLE
SCELTE 111
Il costrutto if-else 111
Il costrutto else if 113
Strutture nidificate 115
Il costrutto switch 117

7. CICLI, OVVERO NOI LA MENTE E LA
MACCHINA IL BRACCIO 119
Spaghetti e programmazione strutturata 120
Il ciclo for: ripetiamo contando 120
Il ciclo while 125
Il ciclo do-while 129
Facciamo un break 130

8. COMINCIAMO A FARE SUL SERIO: GLI ARRAY
133
Premesse sulla complessità dei dati 133
Le strutture dati composte 134
Gli array 135
Inizializziamo un array 138
Array di caratteri, usiamo le stringhe 140
Caratteri “numerici” 141
Input di caratteri, la funzione getchar 142

Una pausa alternativa 143
Do ut des, ovvero getchar e putchar 143
Il pappagallo rimbambito 144
Input e output di stringhe: gets e puts 145
Il pappagallo 2, la vendetta 146
Alcune funzioni tipiche per le stringhe 147

9. ARRAY BIDIMENSIONALI 151
Array a due dimensioni 151
La scansione di un array 2D 153
La generazione di numeri casuali 156

10. ORDINIAMO LE COSE: GLI ALGORITMI
NOTEVOLI 161
Selection Sort 161
Bubble sort 165

11. SOLUZIONI SEMPLICI A PROBLEMI
COMPLESSI: LE FUNZIONI 167
Approccio Top-Down alla programmazione 167
Procedure e funzioni 168
Dichiarazione e definizione di una funzione 169
Nessun input, nessun output 170
Input sì, output no 171
Input e output nella stessa funzione 173
La visibilità delle variabili 175

12. LA RICORSIONE E LE FUNZIONI RICORSIVE
181
I numeri fattoriali 181
Ancora ricorsione, Fibonacci 184

13. I PUNTATORI 187
I puntatori 187
Puntatori e array 189
Puntatori e funzioni 191
L’eccezione che conferma la regola: array, funzioni e passaggio
per indirizzo 194
Comunichiamo con il programma, il passaggio di parametri al
main 195

14. LE STRUTTURE: MOLTI DATI E UN’UNICA
VARIABILE 199
Campi, record e strutture 199
Una struttura dentro l’altra 202
Array di strutture 205
Le strutture e le funzioni 207
Nuovi tipi con typedef 210
I campi di bit 212
Le unioni 213

15. I FILE E GLI ARCHIVI DI DATI SECONDO IL C
217
Archivi e file 217
Apertura e chiusura di un file 218

Modalità di apertura di un file 221
Scriviamo e leggiamo file di testo: fprintf e fscanf 221
Gestire gli errori 224
Un carattere per volta: fgetc e fputc 226
Scrivere e leggere file binari: fwrite e fread 227
Gestire gli archivi di dati 230

Parte 2 – Oltre le frontiere del C
16. LA PROGRAMMAZIONE ORIENTATA AGLI
OGGETTI
E LO SVILUPPO DI SOFTWARE COMPLESSO 235
I linguaggi orientati agli oggetti 237
Evoluzione dei linguaggi di programmazione 238
Vita, morte e “miracoli” di un software 239
Non solo codice 239
Il versioning del software 242
Dall’alfa al rilascio: versioni alfa, beta, RC 245

17. DAL C AL C++ 247
Un “Salve mondo” anche per il C++ 248
Diamo spazio ai nomi 251
Visibilità delle variabili in C++ 256
I riferimenti 257

18. INPUT E OUTPUT DI DATI 261
Console input 261

cin e le stringhe: un rapporto difficile 263
Qualche dettaglio sull’output, un po’ di formattazione 266

19. OGGETTI E CLASSI 271
Dalle struct alle classi 271
Incapsulamento e occultamento dell’informazione 273
Parliamo agli oggetti: messaggi e metodi 275
Oggetti e istanze 277
Come disegnare le classi 278

20. L’ARTE DEL CREARE E DEL DISTRUGGERE
281
Il costruttore 281
Il distruttore 283
La compilazione separata 284

21. IL POLIMORFISMO DEL C++ 291
Monomorfismo e polimorfismo 291
Una firma per la classe 295
Codice e ambiguità 296
Quando il numero conta: array di oggetti 297
Puntare sulla classe 298
Da punto a punto: puntare su se stessi 299
Overloading anche sugli operatori 302

22. EREDITARIETÀ 307
L’ereditarietà del C++ 308

Proteggere i membri della propria classe 313
Diversi ma non troppo: la sovrapposizione 314
Quando il virtuale è realmente utile 315
Dal virtuale all’astratto 318
L’amicizia è una funzione importante 319

23. LA PROGRAMMAZIONE GENERICA E LA
LIBRERIA STANDARD
DEL C++ 323
Riutilizzo del codice e applicazioni legacy 323
Modelli, template e classi generiche 324
Specializzare un template 331
La programmazione generica 331
STL: Standard Template Library 332

24. FLUSSI E FILE NEL C++ 335
Le classi per la gestione dei file 335
Apertura e chiusura di un file 337
Scriviamo file di testo 338
Modalità di apertura 339
Leggiamo il contenuto di un file 340
File binari e archivi di dati 342
Un archivio reale: gestiamo una collezione di fumetti 343

25. LA GESTIONE DEGLI ERRORI E DELLE
ECCEZIONI 353
Try e catch 353

Gestori multipli 356
Eccezioni standard 357

26. L’ALLOCAZIONE DINAMICA DELLA MEMORIA
359
Stack e Heap: come gestire la memoria 361
New e delete: operiamo dinamicamente sulla memoria 362
Il dinamismo di un array 363
I memory leaks 364
Verifichiamo la disponibilità di spazio di memoria 365
Allochiamo dinamicamente oggetti 366

27. LE INTERFACCE GRAFICHE E LA
PROGRAMMAZIONE
GUIDATA DA EVENTI 369
La programmazione guidata da eventi 369
Che fatica aprire una finestra 371
WinMain: il punto di ingresso dell’applicazione 375
La struttura di una finestra 376
Un loop per i messaggi 377
Rispondiamo ai messaggi 377
Messaggi complessi 378
Le risorse indispensabili per un’applicazione 379

28. IL C, ARDUINO E L’INTERNET DELLE COSE
387
Arduino 389

Hardware e corrente elettrica 390
La programmazione software di Arduino 391
Un “salve, mondo” per Arduino 393
Costanti e variabili 395
Comunicazione seriale 397
Arduino e la prototipazione 400
Qualche cenno sui principi della corrente elettrica 402
LED, resistenze e caduta di tensione 403
Fritzing: un aiuto per la progettazione elettronica 409
Bluetooth + Arduino = IoT 410
Collegamento wireless: il modulo ESP8266 418
Hardware libero e sperimentazione 436

Introduzione
La programmazione è una forma d’arte, così come possono esserlo
la pittura, il disegno o la scultura. Realizzare un programma
rappresenta, infatti, un processo di vera e propria creazione di
qualcosa che prende vita grazie al talento di un essere umano. Nel
contesto informatico, il creatore in questione è identificato con
differenti nomi: programmatore, sviluppatore o anche developer. Si
tratta, in ogni caso, di uno “strano essere” dotato di capacità
tecniche che gli consentono di istruire la macchina a realizzare
determinate attività e funzionalità.
Questo testo vuole fornire gli strumenti di base per intraprendere il
lungo viaggio che può portare chi è dotato di passione per le
macchine a diventare un vero programmatore e quindi a dialogare
con esse. Per farlo individua quelle che potrebbero essere definite
“le chiavi della programmazione” nell’uso di due linguaggi che
rappresentano
elementi
imprescindibili
per
un
qualsiasi
programmatore: C e C++.
La prima parte del testo è dedicata appunto al C e consente, anche
a chi si avvicina per la prima volta alla programmazione, di realizzare
programmi di media difficoltà. In questa prima parte vengono infatti
forniti non solo i rudimenti della sintassi del linguaggio ma anche,
passo dopo passo, le indicazioni sui costrutti fondamentali della
programmazione e i concetti di base relativi alle strutture dati, sia di
tipo semplice sia complesso.
La seconda parte del libro inizia, anche metaforicamente, nel punto
in cui si ferma il linguaggio C in termini di potenza e di strumenti dati
al programmatore.
Viene presentato il linguaggio C++ come logica e naturale
conseguenza dei limiti del C, nella direzione di rendere possibile la
creazione di programmi sempre più complessi e più facilmente
manutenibili. In questa ottica si espongono i concetti che sono alla
base della programmazione orientata agli oggetti e si illustra il loro
uso nel contesto del C++.

L’ultimo capitolo introduce il lettore al fermento attuale relativo al
mondo della programmazione delle schede per microcontroller e alla
loro interconnessione con la rete Internet. Si tratta del fenomeno
noto come l’Internet delle cose, in cui la programmazione software si
sposa con hardware a bassissimo costo, producendo una miriade di
innovativi strumenti che interagiscono con il mondo reale uscendo
dal confine ristretto di quello che è un classico software per PC. È in
questo contesto che il linguaggio C ruggisce ancora la sua potenza e
attualità consentendo, a chi ne conosce i rudimenti, di accedere
immediatamente all’ambiente di programmazione delle schede
hardware in questione.

A tutti voi che mi seguirete nelle pagine successive:
buon viaggio!

Struttura e contenuti del libro
Il testo è organizzato in due principali sezioni. La prima parte è
introduttiva alla programmazione in linguaggio C, presentando i
concetti di base dello sviluppo software: le strutture dati e gli
algoritmi che operano su di esse. Vengono così forniti i concetti
relativi a variabili e costanti e ai principali costrutti di
programmazione (sequenza, selezione, ripetizione) con abbondanza
di esempi stimolanti anche per il lettore già avvezzo a tali argomenti.
La prima sezione si chiude con la presentazione della struttura dati
struct del C quale esempio di modalità complessa di gestione di dati
ponendo le basi per le successive discussioni relative alla creazione
di nuovi tipi di dati e operatori.

Il Capitolo 1 vuole fornire una base sostanziale
rispetto ai concetti generali dell’informatica con
speciale attenzione relativa a tutto ciò che riguarda lo
sviluppo software. Viene innanzitutto presentata la
dicotomia analogico-digitale e quindi, rispetto al
contesto digitale, si fornisce una panoramica
essenziale, ma corposa, relativa alla logica binaria e
alle tecniche di rappresentazione dei dati (ASCII e
Unicode).
Vengono introdotti i concetti e le descrizioni di base riguardanti i
principali dispositivi hardware e una panoramica del mondo del
software sia in merito a una semplice classificazione tipologica sia
rispetto a ciò che attiene alla commerciabilità del software stesso.
Si introduce dunque il lettore al mondo dei linguaggi con indicazioni
relative alla traduzione del codice: interpretazione, compilazioni e
linguaggi bytecode.
Il primo capitolo termina quindi, motivando la scelta del linguaggio C
come elemento cardine per tutte le discussioni di tipo operativo che
proseguiranno nel resto del libro, con una carrellata in merito ai

principali ambienti di sviluppo utilizzabili per produrre codice con tale
linguaggio.

Il Capitolo 2 introduce alla compilazione, passo dopo
passo, del primo semplice programma C proponendo
l’ambiente Bloodshed Dev-C++ come strumento
principale da utilizzarsi per implementare tutti gli
spunti di esempio e di esercizio proposti nella prima
parte del testo. In ogni caso si presenta, per
coerenza di contenuti e di discussione, anche
l’ambiente Code::Blocks fornendo anche per questo
secondo sistema le istruzioni di base per compilare
un primo semplice programma C. Seppure il
consiglio sia quello di utilizzare tale secondo
ambiente di sviluppo per i contenuti della seconda
parte del testo, relativi al linguaggio C++, nulla osta a
sceglierlo come principale strumento sin dall’inizio.
Tale scelta può essere obbligata nel caso si utilizzi
una macchina del mondo Mac in quanto Dev-C++ è
specifico per l’ambiente Windows. Il consiglio di
utilizzare come primo ambiente proprio il Dev-C++ è
motivato
dalla
maggiore
semplicità
d’uso
dell’ambiente stesso, che consente di meglio
concentrarsi sugli aspetti del linguaggio. In ogni caso
il lettore più esperto potrà scegliere lo strumento di
sviluppo che preferisce sin dall’inizio.
Nel Capitolo 3 vengono introdotti i fondamentali
concetti di variabile, costante ed enumerazione
presentandone le varie tipologie unitamente ai

consigli per una scelta corretta per i loro nomi e
modalità d’uso. Per farlo si introduce da subito il
lettore all’input e output di base del linguaggio C.
Iniziano già in tale capitolo una serie di suggerimenti
di carattere generale che riguardano le buone
pratiche di programmazione che, nel contesto
specifico, sono relative all’usabilità dell’interfaccia
utente.
Il Capitolo 4 presenta il concetto cardine di algoritmo
e fornisce spunti di esercizio in merito a semplici
problemi risolvibili con l’ausilio dei diagrammi di
flusso. La necessità di realizzare delle operazioni sui
dati è lo spunto per introdurre i principali operatori
aritmetici e relazionali e la presentazione delle
problematiche relative alla trasformazione di un dato
da un certo tipo a un altro.
Il capitolo si chiude con l’introduzione degli operatori logici e quindi
con una panoramica sull’algebra di Boole.

Il Capitolo 5 presenta i meccanismi relativi al
debugging (verifica degli errori) delle applicazioni
software sia in relazione all’ambiente Dev-C++ sia
per l’ambiente Code::Blocks. Vengono così proposti i
concetti di punto di interruzione (breakpoint) e sono
poste sotto osservazione specifiche variabili
utilizzando esempi concreti.
Nel Capitolo 6 vengono fornite indicazioni dettagliate,
corredate da esempi d’uso, relative alle istruzioni

condizionali per consentire la realizzazione di
programmi con un livello di complessità maggiore
rispetto agli esempi iniziali.
Il Capitolo 7 completa la presentazione degli
strumenti
fondamentali
di
programmazione
introducendo il costrutto iterazione. Vengono messi a
confronto i cicli for e while cercando di evidenziare al
meglio il loro campo di applicazione. Si discute quindi
di programmazione di tipo strutturato come
superamento delle problematiche legate alla
cosiddetta “spaghetti programming”.
Nei Capitoli 8 e 9 vengono introdotte le strutture dati
di tipo complesso. Vengono così presentati gli array
monodimensionali con una dettagliata panoramica
sulle problematiche connesse al trattamento delle
stringhe. Successivamente è il turno degli array
bidimensionali, subito dopo i quali si coglie
l’occasione per illustrare la possibilità di generare
numeri casuali. In tal modo si rendono disponibili gli
strumenti che consentono la realizzazione di
programmi
autonomi
rispetto
all’input
del
programmatore o dell’utente.
Il Capitolo 10 presenta il concetto di algoritmo
notevole come esempio di risoluzione di problemi
mediante metodologie consolidate nella letteratura e
dalla pratica informatica. Vengono esaminati in
dettaglio gli algoritmi di ordinamento selection sort e

bubble sort con accenni a concetti di complessità
computazionale.
Il Capitolo 11 prende in esame l’approccio alla
programmazione software di tipo Top-Down
introducendo concetti ed esempi reali relativi a
procedure e funzioni. È il contesto giusto in cui
possono essere definiti, quindi, diversi dettagli relativi
ai concetti di visibilità e ciclo di vita delle variabili
presentando inoltre le classi di memorizzazione
esterne e statiche.
Nel Capitolo 12, ormai noto il concetto di funzione, se
ne presenta una tipologia molto particolare: la
funzione ricorsiva. Vengono così proposti concetti ed
esempi relativi al calcolo del fattoriale e alle
sequenze di Fibonacci.
Il Capitolo 13 presenta i puntatori, argomento per sua
natura ostico. Data la particolarità del tema si cerca
di motivarne il più possibile l’utilizzo analizzando
prima i collegamenti tra puntatori e array, e facendo
successivamente vedere quale sia il collegamento
tra puntatori e funzioni, esaminando le chiamate per
valore e per indirizzo delle funzioni stesse.
Il Capitolo 14 descrive la struttura dati struct del C
motivandone l’uso come contenitore fondamentale
per raggruppare dati di tipo complesso tra di essi
omogenei. Tale capitolo rappresenta un punto di

snodo: si iniziano a delineare i limiti dello sviluppo del
software con il linguaggio C e l’approccio di tipo
procedurale. Vengono così enfatizzati gli aspetti
relativi al trattamento dei dati introducendo la parola
chiave typedef per la definizioni di nuovi tipi e le
strutture dati union e campi di bit.
Con il Capitolo 15 si chiude la prima sezione del libro
focalizzata sugli elementi del C, facendo vedere
come vengano gestiti i file utilizzando l’approccio
proprio di tale linguaggio di programmazione.
Il Capitolo 16 apre dunque la seconda sezione del
testo presentando sin da subito le prime discussioni
critiche sull’approccio che utilizza il paradigma a
oggetti nella programmazione software. Preparando
il lettore per lo sviluppo di applicativi di sempre
maggiore
complessità
si
definiscono
le
problematiche proprie della corretta progettazione
del software come momento fondamentale e
preliminare alla scrittura del codice. Si introducono
quindi i concetti di ciclo di vita nello sviluppo software
e di conseguenza vengono presentati gli ambiti
propri dell’ingegneria del software. Il capitolo si
chiude con una panoramica sulle modalità di
versioning.
I Capitoli 17 e 18 introducono nel dettaglio la sintassi
e l’approccio alla programmazione del linguaggio
C++. In tale ambito si suggerisce l’utilizzo

dell’ambiente di sviluppo Code::Blocks fornendone le
specifiche d’uso di massima. Vengono da subito
introdotti i concetti di spazio dei nomi delle variabili e
si vede come queste possano variare la loro visibilità
nei differenti blocchi di codice. Il Capitolo 18 è
specifico e dettagliato rispetto alle funzionalità di
input e output proprie del C++.
Il Capitolo 19 presenta finalmente i concetti di classe
e oggetto. È un momento fondamentale nel quale si
mostra come, a partire da una struct del C, si possa
costruire un oggetto di programmazione inserendo al
suo interno la possibilità di realizzare specifiche
azioni con l’utilizzo di apposite funzioni. Si discute
quindi
di
incapsulamento
e
occultamento
dell’informazione e di come si possa di conseguenza
comunicare con gli oggetti.
Il Capitolo 20 fornisce la sintassi per la gestione del
ciclo di vita degli oggetti relativamente alla loro
creazione e successiva distruzione. Il capitolo
presenta inoltre le modalità per la cosiddetta
compilazione separata, ovvero la possibilità di
organizzare il proprio codice in differenti file,
operazione indispensabile al crescere delle
dimensioni dei propri programmi.
I Capitoli 21 e 22 completano la descrizione delle
proprietà fondanti della programmazione orientata
agli oggetti descrivendo polimorfismo ed ereditarietà.

Infatti, il Capitolo 21 continua l’analisi delle
caratteristiche degli oggetti fornendo dettagli sul
polimorfismo, contrapponendolo al comportamento
monomorfico delle funzioni C, relativamente alla
tecnica dell’overloading. Il Capitolo 22, d’altra parte,
introduce il concetto di ereditarietà e quindi la
possibilità di riutilizzare al meglio il codice già scritto
per ampliarlo adattandolo a nuove necessità. È in
questo contesto che si presentano le classi virtuali e
astratte.
Il Capitolo 23 presenta la programmazione generica
e quindi l’uso dei template. Si illustra così come sia
possibile realizzare un approccio alternativo al
polimorfismo classico, usando funzioni e classi
parametriche, nell’ottica di produrre un codice
sorgente il più efficiente e generico possibile in
merito alle aspettative del programmatore.
Nel Capitolo 24 si riprende la discussione già
affrontata nel Capitolo 15 in relazione alla gestione
dei file e degli archivi. In questo contesto si affronta
però l’approccio usato dal linguaggio C++ mostrando
una diversa metodologia per un comune problema e
dando al contempo la possibilità di esplorare dettagli
ulteriori della programmazione C++ e della libreria
standard. Ancora una volta vengono fornite
indicazioni dettagliate per la realizzazione di una

piccola ma reale applicazione di gestione di un
archivio di dati.
Il Capitolo 25 affronta le problematiche connesse alla
gestione degli errori e propone gli strumenti messi a
disposizione dal linguaggio C++ per prevenire e
gestire al meglio le condizioni anomale nelle quali
possono venire a trovarsi le nostre applicazioni.
Viene così proposto il concetto relativo alle eccezioni
e il costrutto try - catch per la loro corretta gestione.
Il Capitolo 26 torna sulle questioni attinenti alla
gestione della memoria, focalizzando l’attenzione
sulle corrette procedure da utilizzarsi per superare i
vincoli imposti dalle dimensioni fisse richieste nella
dichiarazione di variabili statiche automatiche. Si
discute quindi di allocazione dinamica della memoria
confrontando stack e heap e dando adeguati
suggerimenti per evitare situazioni potenzialmente
disastrose come i memory leaks.
Il Capitolo 27 chiude il viaggio attraverso la
programmazione e nel C/C++ fornendo spunti
relativamente alla realizzazione di applicazioni con
interfaccia grafica. Alle tante possibili declinazioni
relative alla creazione di applicazioni di tipo grafico si
preferisce l’approccio basato sulle funzioni native di
Windows. Tale scelta è sufficientemente generica da
fornire la giusta panoramica per comprendere i
fondamenti dello sviluppo di applicazioni grafiche

utilizzando
la
metodologia
programmazione guidata da eventi.

nota

come

Infine, il Capitolo 28, proprio di questa seconda
edizione, presenta il contesto della programmazione
delle schede per microcontroller e della loro
interconnessione con la rete Internet. Si introducono i
concetti di base relativi alla corrente elettrica e si
presenta in dettaglio la scheda Arduino, sia dal punto
di vista hardware che da quello software. Dopo aver
mostrato le corrispondenze tra i linguaggi C e C++
con il contesto Wiring, proprio di Arduino, si sfruttano
tali conoscenze per gestire la comunicazione seriale
tra il PC e la scheda in questione. Viene inoltre
introdotta e messa alla prova la tecnologia bluetooth
per controllare Arduino attraverso un qualsiasi
smartphone Android. In conclusione, si mostra come
sia possibile comandare la scheda Arduino
attraverso un collegamento di tipo Wi-Fi.

Materiale di supporto ed esempi
Il testo mantiene in tutta la sua organizzazione un approccio pratico
e per questo scopo propone numerosi esempi di codice reale. Tale
materiale è disponibile in formato digitale all’indirizzo:
www.tesseract.it/lechiavi.
Allo stesso indirizzo è possibile riferirsi per approfondimenti e novità
relativi al libro e agli argomenti in esso trattati.

Ringraziamenti
È abitudine consolidata quella di inserire, all’inizio di ogni testo, dei
ringraziamenti da parte dell’autore nei confronti di una serie di
persone che hanno, in un modo o nell’altro, contribuito alla
realizzazione del testo medesimo. Trovo tale consuetudine
doverosa.
Ognuno di noi cresce, vive e si realizza attraverso le proprie azioni in
conseguenza degli stimoli e del sostegno che riceve dalle persone
che lo circondano. Cosicché ogni nostra realizzazione è in un certo
modo un prodotto collettivo. Non sfugge a tale contesto il presente
volume.
Questo lavoro non avrebbe infatti visto la luce senza il sostegno che
ho ricevuto negli anni in primo luogo dalla mia famiglia. Essa è stata
da sempre fucina di stimoli e propulsione per una crescita basata
sulla critica costruttiva e l’interesse sempre meravigliato verso tutte
le cose del mondo. Ringrazio così in particolare i miei genitori e i
miei fratelli. Nello specifico un forte tributo alla mia dolce mamma
Rosa per l’affetto incondizionato, per le gite in libreria quando ero
bambino e, tra le tantissime altre cose, un grazie particolare per
avermi comprato il mio primo vero computer, il mitico Sinclair QL.
Uno speciale abbraccio è poi dovuto a mio fratello Ermanno per il
continuo appoggio e sostegno in tutto ciò che faccio.
A mia moglie va il riconoscimento per la sopportazione relativa al
fatto di aver sposato un uomo con DNA digitale e la mia eterna
gratitudine per la sua capacità di riuscire a completarmi. Ai miei figli,
unitamente al mio non misurabile affetto, vanno le scuse per quelle
volte in cui, per il troppo lavoro, li ho costretti alla mia assenza.
Questo libro deve molto ai miei amici, che hanno fatto da cavie nella
lettura e nello studio delle bozze. Tra i tanti voglio ringraziare gli
ingegneri Francesco Ambrosio, Stefano Ciaramella, Amedeo
Lepore, Giuseppe Pica e in particolare Luigi Della Gala. Un
ringraziamento speciale va poi al mio fraterno amico Roberto Frattin,
brillante informatico del quale ho sempre apprezzato la capacità di
schematizzare in forma grafica il mondo della matematica.

È spontaneo e sincero il riconoscimento che tributo agli ingegneri
Fabrizio D’Aloia e Dario Pica che mi hanno onorato della loro fiducia
relativamente alle mie competenze informatiche in questi anni di
continue evoluzioni tecnologiche.
Un ringraziamento specifico in merito al presente volume è poi per
tutti i miei innumerevoli alunni che hanno fatto sì che potessi
migliorarmi nelle capacità comunicative e non perdessi mai la voglia
di continuare a studiare e stare dalla parte di chi impara. Tra i
tantissimi ai quali va la mia riconoscenza, voglio ricordarne alcuni in
particolare: Antonio Esposito, Andrea Micco e Pietro Goglia. Inoltre,
per questa seconda edizione, un meritato e sentito riconoscimento
va a Umberto Covino, Assunto De Mizio e Mattia Simeone.
Sempre in merito a questa seconda edizione e al contesto
squisitamente didattico, se il presente testo coglie, almeno in parte,
gli intenti dell’autore in merito alla capacità comunicativa è di certo
dovuto anche alle sollecitazioni, suggerimenti e proposte di vari
colleghi. Tra i tanti cito, a parziale ma rappresentativo elenco, Angelo
Pucillo, Antonio Inglese, Carmine De Gennaro, Anna Maria
Marmorale, Angela Viola, Valentina Schibani, Clea Pastore, Liana
Urciuoli, Assunta Leone, Rosanna Gravano, Franca Fagioli, Antonio
Guadagno, Silvio Feleppa, Francesco Chiriaco.
Questo libro non avrebbe, tuttavia, visto la luce in questa forma
senza l’appoggio e la condivisione di intenti di Fabrizio Comolli e
Marco Aleotti.
E infine, a tutti coloro i quali, anche qui non menzionati, che in un
modo o nell’altro hanno incrociato positivamente la mia esistenza: un
grazie dal profondo del cuore.
Carlo A. Mazzone

Parte 1

Il linguaggio C e i fondamenti
della programmazione
Einstein ha argomentato che ci devono
essere spiegazioni semplificate della
natura, perché Dio non è capriccioso o
arbitrario.
Tale fede non è di conforto al
programmatore di software.
Frederick Phillips Brooks, Jr.

1
Premesse e motivazioni per
unire la teoria e la pratica della
programmazione
Gli smanettoni erediteranno la terra.
Karl Lehenbauer
La programmazione è senza ombra di dubbio un’attività pratica con
una sensazionale radice di tipo teorico. Una volta da qualche parte
ho letto quanto segue:

La differenza tra la teoria e la pratica è molto più
grande in pratica che in teoria.
La frase che può sembrare in un primo momento solo un gioco di
parole nasconde una profonda verità: quando si concretizza
praticamente qualsiasi attività immaginata in precedenza sulla carta
ci si scontra inevitabilmente con l’ostilità de mondo reale. Senza
tener conto poi che in agguato esiste sempre un certo Murphy: “Se
qualcosa può andare storto allora lo farà”.
La legge di Murphy è un insieme di affermazioni ironiche molto note
nel campo informatico e più in generale tecnico-scientifico. L’aspetto

più noto della legge di Murphy si può riassumere nella seguente
espressione: “Se qualcosa può andare storto allora lo farà” (“If
anything can go wrong, it will”).
Si tratta, come è evidente, di un modo per esorcizzare gli
innumerevoli problemi tecnici che si verificano durante il proprio
lavoro. Le origini di tale legge sono controverse. Murphy dovrebbe
essere un ingegnere della U.S. Air Force che conducendo un
esperimento non andato propriamente a buon fine addusse la
responsabilità dell’accaduto a un suo assistente dicendo: “Se quel
tipo ha una qualsiasi possibilità di fare un errore, lo farà” (“If that guy
has any way of making a mistake, he will”).
Ho usato il condizionale in quanto sembra non esserci nulla di certo
nei personaggi “storici” coinvolti in questa storia. Di certo c’è,
tuttavia, la notorietà planetaria di questa legge e le sue innumerevoli
varianti sul tema.
Delle tante vi cito la seguente: “La probabilità che una fetta di pane
imburrata cada dalla parte del burro verso il basso su un tappeto
nuovo è proporzionale al valore di quel tappeto”.
Ma ancora: “Ogni cosa che potrà andare storta lo farà, nel momento
peggiore e nel peggior modo possibile” (“Whatever can go wrong will
go wrong, and at the worst possible time, in the worst possible way”).
Il senso di tutto quanto detto è che il mondo reale è un sistema
costituito da una miriade di dettagli di cui si deve tener conto affinché
gli oggetti che costruiamo si comportino secondo gli schemi teorici
che abbiamo immaginato. Anche il più banale dei dettagli può far
fallire miseramente progetti di grandi dimensioni: tempo fa una
missione spaziale fallì a causa di una banale errata conversione tra
unità di misura.
Quello che voglio dire è che se la teoria è un aspetto imprescindibile
e fondamentale, essa deve essere accompagnata da una giusta
dose di praticità sia per verificare la correttezza di quanto formulato
teoricamente sia per comprendere meglio un dato aspetto del
sistema in esame.
Questa prima sezione include un’introduzione agli aspetti fondanti
della programmazione utilizzando come banco di prova il linguaggio
C.
Tale linguaggio può risultare, nel contesto di questo nostro viaggio,

di estrema utilità per comprendere diversi aspetti altrimenti sfuggenti
relativi alla programmazione e più in generale alla comprensione del
funzionamento dei sistemi di elaborazione. Da un lato esso ci
permette di verificare concretamente cosa sia un linguaggio
artificiale e dall’altro di sperimentare personalmente alcuni esempi e
applicazioni al fine di comprenderli appieno. Nondimeno il fatto di
verificare con i nostri occhi determinate realtà pratiche ci aiuta
enormemente nel fissare certi ricordi utilizzando la memoria visiva,
senz’altro di grandissima importanza.

Analogico versus digitale: la battaglia
ormai persa
Anche chi ha solo sentito parlare di analogico e precisamente non
sa di cosa si tratti può facilmente immaginare che il vincitore tra i due
contendenti indicati nel titolo di questo paragrafo è chiaramente il
digitale. Ciò deriva sicuramente, almeno in parte, dal fatto che il
termine digitale sia ormai quasi onnipresente nella descrizione di
qualsiasi nuova tecnologia. Basta considerare esempi banali e
comuni, come quelli legati ai display che visualizzano il numero che
abbiamo in una coda al banco salumi del supermercato sotto casa,
ai CD musicali, all’elettronica per le autovetture fino ad arrivare alle
attuali implementazioni di trasmissione dei segnali televisivi in
“digitale terrestre”.
Forse il modo migliore per comprendere il significato e le implicazioni
del termine digitale è fare riferimento alla traduzione dalla forma
inglese da cui è derivato: digit = cifra (e più in generale numero).
Dunque digitale sta per numerico e di conseguenza ogni dispositivo
digitale sfrutta i numeri per immagazzinare, elaborare, trasmettere e
ricevere informazioni.
L’esempio più classico che normalmente si fa per descrivere la
differenza tra dispositivi analogici e digitali è probabilmente quello
dell’orologio.
Un orologio con lancette è analogico in quanto le sue lancette
possono indicare uno qualsiasi degli infiniti punti che formano la
circonferenza del quadrante. Tali punti non sono quindi numerabili.
Al contrario un orologio digitale mostra sul suo quadrante un numero
limitato di valori. Più precisamente 86.400, vale a dire 24 ore x 60
minuti x 60 secondi.
Allo stesso modo si può constatare la differenza tra un termometro
digitale e uno analogico. Il primo mostra un numero intero
corrispondente alla temperatura misurata; nel caso di due cifre
avremo valori di temperatura distanziati da un solo grado (36°, 37°,
38°) con possibili valori intermedi approssimati al numero a due cifre

più vicino. Nel secondo caso, con un termometro analogico, la
precisione della lettura sarà affidata alla nostra capacità di leggere il
livello di mercurio sulla scala graduata del termometro stesso; in
ogni caso si tratta di infiniti valori.
È intuitivo che, convertendo un valore da analogico a digitale, si
effettua inevitabilmente un’approssimazione del valore stesso.
Tuttavia si ottengono in cambio enormi benefici, dovuti innanzitutto
alla possibilità di trattare i numeri ottenuti in maniera molto più
accurata, potendo trasmetterli, riceverli e rielaborarli in modo da
controllare molto più facilmente possibili errori di trasmissione. Su di
essi risulta inoltre molto più semplice effettuare trasformazioni e
manipolazioni varie, affidandosi a strumenti software facilmente
programmabili senza essere costretti a costruire, per ottenere le
stesse trasformazioni, complicate apparecchiature elettroniche
specificatamente dedicate allo scopo.

In principio era il bit
Un punto lo dovremmo dare per assodato: le macchine operano
utilizzando rappresentazioni numeriche. Quando si parla di numeri,
la prima cosa a cui pensiamo è una sequenza di cifre che vanno da
0 a 9 e tutta una serie di numeri che abbiamo in mente: il nostro
numero di telefono, il nostro civico e così via. Tuttavia, in ogni caso,
pensiamo ai numeri immaginandone dieci (cifre). E qui arriva il primo
problema: le macchine, e con loro gli informatici, pensano ai numeri
come sequenze di sole due cifre: 0 e 1. Mi viene in mente una frase
che ho letto da qualche parte e che viene riportata, con qualche
variante, anche su alcune simpatiche magliette:

Al mondo esistono solo 10 tipi di persone.
Quelli che capiscono l’informatica e quelli che non la
capiscono.
È ovvio che, a una prima lettura, la frase può risultare errata. Infatti,
la sequenza di cifre “10”, per la nostra consolidata abitudine nel
gestire numeri decimali, è in palese contrasto con la suddivisione in
due gruppi o tipologie di persone (quelli che conoscono l’informatica
e quelli che non la conoscono). Riconosciamo infatti in quella
sequenza di cifre il valore “dieci”.
Per comprendere appieno il “giochino” della frase in questione è
necessario riflettere sul fatto che tutta la nostra comunicazione è
basata su delle convenzioni. Se dico “casa”, è immediato per tutti
visualizzare nella propria mente il concetto di abitazione, costruzione
in muratura, cemento o quant’altro. Ad ogni modo l’immagine
mentale che costruiamo è precisa. Ciò è ovviamente basato su di
una convenzione: il fatto di associare all’etichetta “casa” un ben
preciso oggetto. Se facciamo un salto indietro nel tempo possiamo
addirittura ricordare i colorati cartelloni usati alle elementari con le
classiche letterine, con una grande “C” e il disegno di una casetta.
Medesima situazione si verifica con i sistemi di numerazione:

associamo a dei simboli un certo valore e dopo un po’ di esercizio
siamo in grado di immaginare nella nostra mente una certa quantità
di oggetti associata a un dato numero. Per ulteriore chiarezza si può
pensare agli antichi romani, che per rappresentare il numero dieci
avrebbero utilizzato il simbolo X.
Dopo queste precisazioni dovrebbe risultare chiaro che i simboli “10”
della frase precedente non rappresentano il numero dieci ma
qualcosa di diverso. Ci aspettiamo infatti che il loro valore sia il
numero decimale 2 (due). Per capire come ciò sia possibile si può
partire osservando come vengono costruiti i numeri decimali.
Consideriamo ad esempio il numero decimale 123; esso può essere
scritto come:
123 = 100 + 20 + 3 = 1 * 102 + 2 * 101 + 3 * 100

ricordando che un qualsiasi numero elevato a 0 dà 1 e che usiamo il
simbolo di asterisco per indicare la moltiplicazione. Come si nota, il
valore delle cifre dipende dalla posizione occupata dalla cifra stessa
all’interno del numero. Si va dalla destra (posizione meno
significativa) alla sinistra (posizione più significativa). Il numero finale
si ottiene sommando le singole cifre, ognuna di esse moltiplicate per
10 elevato alla posizione della cifra all’interno del numero (si parte
dalla posizione zero). La base dieci (sistema decimale)
dell’elevamento a potenza visto è proprio quello che determina il
valore della cifra e il nome della tipologia di rappresentazione dei
nostri numeri: notazione posizionale pesata (ogni cifra ha un peso
in base alla posizione). Per base si intende dunque il numero di cifre
utilizzate per rappresentare i numeri nella specifica notazione.
Dovrebbe risultare ora chiaro che modificando la base della
notazione possiamo ottenere nuovi modi di rappresentare i nostri
numeri. Nello specifico del mondo del computer, e finalmente
possiamo chiudere il cerchio, la base maggiormente utilizzata per la
rappresentazione dei numeri è il due, da cui: sistema binario.
In definitiva, il sistema binario utilizza per la rappresentazione dei
numeri solo due cifre: 0 e 1. La singola cifra binaria (che ribadisco
può assumere il valore 0 oppure 1) prende il nome di bit, ovvero
binary digit (dall’inglese “cifra binaria”).
Il valore di un numero binario viene banalmente ottenuto con la

stessa regola vista prima nel caso dei numeri decimali.
Consideriamo ogni singola cifra e la moltiplichiamo per 2 (il valore
della base) elevato al numero che rappresenta la posizione della
cifra (partendo dalla posizione 0). Ognuno di questi prodotti verrà
sommato per ottenere il valore finale. Facciamo allora un esempio
chiarificatore con il numero binario “10” al fine di risolvere l’enigma
della frase di cui sopra:

10 (in binario) = 1*21 + 0*20 = 2 + 0 = 2 (in decimale)
Come si può osservare, per evitare ambiguità ho dovuto specificare
tra parentesi il sistema (binario o decimale) in cui ricade il numero
specifico. È intuitivo che è un modo poco elegante e nondimeno
scarsamente formale per risolvere l’ambiguità stessa. In generale
quando vi è possibilità di confusione si usa porre al fianco del
numero, come pedice, la base del sistema utilizzato (cioè, come già
detto, il numero di cifre che utilizziamo per rappresentare il numero).
Ad esempio:

102 oppure 1010
Nel primo caso si intende il numero binario “10”, il cui valore in
decimale è 2; nel secondo caso il numero è il familiare numero
decimale 10 (dieci).
In linea del tutto generale possiamo immaginare di avere una serie
di bit del tipo:

aN-1 aN-2 … a2 a1 a0
dove N è un numero di nostra scelta che indica dunque di quanti bit
è composto il nostro numero binario. Il loro valore decimale sarà
allora dato dall’espressione:

aN-1 2N-1 + aN-2 2N-2 + … + a2 22 + a1 21 + a020
Tale espressione è in realtà del tutto generale in quanto si può
facilmente sostituire al 2 la base della specifica notazione (ad
esempio dieci nel caso del classico sistema decimale).

Quanti ne rappresento?
In varie circostanze può essere importante calcolare la grandezza
del numero esprimibile utilizzando un dato numero di bit. Osservate
che con un solo bit gli oggetti differenti che possono essere
rappresentati sono ovviamente solo due (0 oppure 1). Con 2 bit gli
oggetti differenti diventano 4 (00, 01, 10, 11) ovvero 22. Con 3 bit le
combinazioni sono 8 (000, 001, 010, 011, 100, 101, 110, 111) ovvero
23.
È intuitivo verificare che con N bit a disposizione (dove N è un
qualsiasi numero intero positivo) è possibile rappresentare 2N (2
elevato ad N ) diversi possibili oggetti (combinazioni di bit differenti
tra di essi).
D’altra parte, invece, il numero massimo rappresentabile con N bit è
dato da 2N – 1, dove -1 è giustificato dal fatto che bisogna escludere
il numero iniziale zero.

Nibble e Byte
Di norma la gestione dei bit avviene in gruppi di un numero ben
determinato. Quando si gestiscono insieme 4 bit si parla di nibble.
Quando invece, come più comunemente avviene, si gestiscono
gruppi di 8 bit si parla di byte. I multipli più comunemente utilizzati
del byte sono i seguenti:
KB (o kilobyte) =
MB (o megabyte) =
GB (o gigabyte) =
TB (o terabyte) =

103 byte ovvero 1024 byte
106 byte ovvero 1024 kilobyte
109 byte ovvero 1024 megabyte
1012 byte ovvero 1024 gigabyte

Altre basi numeriche
Come visto, la base della notazione utilizzata, ovvero il numero di
cifre utilizzate per comporre i nostri numeri, è l’elemento
fondamentale da considerare nella rappresentazione dei numeri
stessi. In informatica, oltre alla base 2, esistono altre basi
comunemente utilizzate: base 8 e base 16.
È importante notare a questo punto che l’utilizzo di basi diverse da
quella binaria è un modo utilizzato per presentare all’utente
l’informazione immagazzinata all’interno della macchina in una
maniera che sia per lui più intuitiva. Dovrebbe essere scontato
comunque che la macchina al suo interno continuerà a gestire il tutto
in forma binaria (0 e 1). Si parla, infatti, di rappresentazione
esterna dell’informazione o anche alfabeto esterno in
contrapposizione al cosiddetto alfabeto interno, appunto gli 0 e gli
1.
La base 8 genera una rappresentazione nota come ottale. Le cifre
utilizzate vanno ovviamente da 0 a 7.
Tuttavia, per la rappresentazione esterna dei dati, la base più
utilizzata è sicuramente la base 16. Essa genera una
rappresentazione nota come esadecimale e fa uso delle seguenti
cifre:
0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F

Dovrebbe essere abbastanza intuitivo che la lettera ‘A’ corrisponde
al decimale 10, la ‘B’ al decimale 11 e così via fino alla lettera ‘F’
corrispondente al decimale 15. Per semplificarvi la visione di queste
corrispondenze potete osservare la tabella seguente, dove sono
elencati anche i corrispondenti valori binari:

Decimale Binario Esadecimale
0

0 0 0 0

0

1

0 0 0 1

1

2

0 0 1 0

2

3

0 0 1 1

3

4

0 1 0 0

4

5

0 1 0 1

5

6

0 1 1 0

6

7

0 1 1 1

7

8

1 0 0 0

8

9

1 0 0 1

9

10

1 0 1 0

A

11

1 0 1 1

B

12

1 1 0 0

C

13

1 1 0 1

D

14

1 1 1 0

E

15

1 1 1 1

F

Il successo della notazione in base 16 è sicuramente dato dalla
semplicità con cui è possibile trasformare un numero binario in
esadecimale e viceversa. Infatti, per trasformare un numero binario
nel suo corrispettivo in esadecimale è sufficiente raggruppare,
partendo da destra, in gruppi di quattro cifre, i vari bit del numero
binario e convertire ogni gruppo nel corrispondente esadecimale. Un
esempio chiarirà la semplicissima operazione:
10111101012= 10 1111 0101 = 2F516

Analogamente si procede al contrario per ottenere il binario dato il
numero esadecimale.
Ad esempio:
A3F16 = 1 0 1 0 0 0 1 1 1 1 1 1

ovvero si prende ogni singola cifra esadecimale e si scrive al suo
posto il corrispondente valore binario.

Rappresentazione dei dati
alfanumerici
Finora abbiamo parlato solo di numeri. Se tuttavia le macchine si
trovano perfettamente a loro agio nella gestione dei numeri,
sicuramente non altrettanto vale per gli esseri umani. Pensate solo
alle volte in cui avete sentito la frase “io non sono portato per la
matematica” e traete voi stessi le conclusioni. È noto a tutti che il
nostro alfabeto è costituito da una serie di caratteri con i quali
costruiamo le nostre parole. Per risolvere il problema della
rappresentazione di tali caratteri gli informatici hanno creato una
semplice tabella di corrispondenza tra i numeri (binari), che le
macchine possono facilmente masticare, e i caratteri stessi.

Il codice ASCII
Il più noto e utilizzato standard (dobbiamo essere tutti d’accordo sul
metodo di rappresentazione) di codifica dei caratteri e, più in
generale, dei simboli, è noto come codice ASCII, “American
Standard Code for Information Interchange”, ovvero “standard
americano per lo scambio di informazioni”. Notate che a rigore
dovrebbe essere pronunciato come “aschi”. Esso è un sistema di
codifica dei caratteri inizialmente basato su 7 bit, al quale Bob
Bemer, un ingegnere dell’IBM, ha dato il maggior impulso tanto da
essere considerato il “padre” del codice ASCII.
Come successiva implementazione si è passati a un sistema a 8 bit.
In tal modo si raddoppia il numero di caratteri disponibili per un totale
di 256 elementi differenti, potendo quindi rappresentare simboli di
uso meno comune. Tale numero è dato dalla formuletta che abbiamo
visto in precedenza per il calcolo del massimo numero
rappresentabile con N bit. In questo caso N è pari a 8 e quindi
abbiamo 28 uguale a 256. Se non altro prendiamo coscienza del
fatto che le cose che impariamo ci tornano utili.
Non tutte le rappresentazioni di bit hanno come controparte un

classico simbolo come una lettera a una cifra. Alcuni di essi, come
ad esempio i codici corrispondenti ai numeri decimali da 0 a 31 e il
127, sono caratteri non stampabili usati come codici di controllo
come, a puro titolo di esempio, per indicare la fine di una
trasmissione di dati.

Il codice Unicode
Come si può facilmente intuire, i soli 256 simboli del codice ASCII
non sono affatto sufficienti per rappresentare i caratteri degli alfabeti
delle varie lingue presenti sul nostro pianeta. Si è resa quindi
necessaria l’adozione di un altro sistema di codifica: Unicode.
Unicode si basa sulla codifica ASCII, andando tuttavia oltre la
limitazione dell’alfabeto latino potendo codificare i caratteri utilizzati
da tutte le lingue del mondo.
Infatti, seppur originariamente basato su di una codifica a 16 bit con
possibilità di codificare al più 65.536 caratteri, ora invece è
estendibile fino a poterne rappresentare circa un milione. Per la
serie: almeno per un po’ non avremo problemi di spazio di
rappresentazione.

Hardware e software
Un sistemista, mio collega qualche anno fa in un Internet Service
Provider, ripeteva spesso questa frase: “Giusto per non saper né
leggere né scrivere questo controllo lo faccio”. Per chi non avesse
capito è un modo per dire “anche se la cosa è (può sembrare)
scontata è meglio, sempre e comunque, stare attenti”.
In questo contesto, seppur dovreste essere tutti a conoscenza delle
caratteristiche generali e delle differenze tra hardware e software,
così come quelle relative ai vari dispositivi di input e output, è forse
bene spendere comunque qualche parola in proposito.

Hardware
Per hardware (letteralmente “ferramenta”) si intendono tutti i
dispositivi fisici di un elaboratore.
Tutto ciò che è possibile vedere e toccare del nostro sistema:
tastiera, monitor, stampante, pennetta USB sono identificabili come
hardware. L’elemento centrale di un tipico sistema di elaborazione è
senza dubbio il case, noto anche come cabinet oppure chassis,
ovvero il contenitore metallico all’interno del quale sono collocati i
principali elementi costitutivi del nostro sistema di calcolo.
Ovviamente tale case deve poter comunicare con il suo utilizzatore.
Per tale scopo vengono utilizzati una serie di dispositivi noti anche
con il termine di periferiche. Tali congegni vengono di norma
classificati in dispositivi di input (ingresso) e dispositivi di output
(uscita).
I dispositivi di input sono tutte quelle periferiche che consentono
l’ingresso dei dati all’interno dell’elaboratore: mouse e tastiera sono
tra i più classici.
I dispositivi di output hanno il compito inverso rispetto a quelli di
input: sono tutte quelle periferiche che consentono la comunicazione
dei dati verso l’esterno dell’elaboratore: monitor e stampante credo
rappresentino un esempio più che illuminante, avendo l’onere di
trasferire i dati dell’elaborazione dalla macchina verso l’esterno e

quindi di norma verso l’utente.
Intuitivamente si riconoscono dei dispositivi ibridi (quali ad
esempio i supporti di memorizzazione come i dischi fissi) che sono
sia di input che di output, così come i nuovi dispositivi di tipo touch,
spesso di tipo tablet, che integrano contemporaneamente monitor e
possibilità di input.

Organizzazione generale di un sistema di
elaborazione
Il compito fondamentale del sistema è di eseguire una serie di
istruzioni che soddisfino determinate nostre richieste. Una specifica
sequenza di tali istruzioni codificate in modo tale da essere eseguite
dalla macchina, come già lasciato intendere, prende il nome di
programma o software.
Lo schema classico di costruzione di un sistema di elaborazione
prende il nome di architettura di Von Neumann (o macchina di
Von Neumann). L’idea di base di questo sistema, che prende
appunto il nome dal suo ideatore, prevede che il programma, cioè le
istruzioni da far eseguire alla macchina unitamente ai dati sui quali
deve lavorare, sia presente nella memoria del calcolatore. Von
Neumann fu il primo a intuire le potenzialità di avere le istruzioni
direttamente in memoria. Come vedremo a breve, per memoria si
intende un dispositivo hardware in grado di immagazzinare dei dati.
Chi provvede a eseguire effettivamente le istruzioni è un dispositivo
che prende il nome di CPU (Central Processing Unit). I dati da
elaborare e i risultati dell’elaborazione vengono gestiti da unità di
ingresso e uscita (dette anche di I/O ovvero Input/Output). Le varie
parti del sistema sono collegate attraverso un canale di
comunicazione noto come BUS.

La CPU
La CPU (Central Processing Unit), nota anche microprocessore,
rappresenta, come già detto, l’elemento che effettivamente esegue
le istruzioni dei nostri programmi. Per tale motivo essa è spesso
considerata il cuore o il cervello del computer (a seconda della

maggiore importanza reciproca che si attribuisce a questi due
organi). Il senso è che la CPU rappresenta il punto centrale
dell’intero elaboratore e le sue caratteristiche sono i parametri
principali ai quali si guarda per definire la “potenza” dell’elaboratore
stesso.
Fisicamente si tratta di un circuito elettronico estremamente
sofisticato prodotto attualmente da poche aziende specializzate.
Probabilmente la più nota tra tali aziende è Intel.
Semplificando al massimo l’organizzazione interna della CPU
possiamo individuare due componenti principali: ALU e CU.
La ALU (Arithmetic Logic Unit) è una sezione della CPU dedicata
allo svolgimento di operazioni appunto aritmetiche come addizione,
sottrazione e in alcuni casi moltiplicazioni e divisioni. Inoltre svolge
operazioni logiche binarie come AND, NOT, OR e XOR (che
vedremo più avanti). Ancora, svolge operazioni di shifting
(spostamento) o rotazione di sequenze di bit.
La CU (Control Unit) è la sezione che si preoccupa della lettura ed
esecuzione delle istruzioni.

La memoria
Come già accennato, per memoria si intende un dispositivo
hardware in grado di immagazzinare dei dati. Fondamentalmente un
calcolatore dispone di due tipi differenti di memorie, che vengono
classificate come memoria principale (o memoria centrale) e
memoria secondaria, le cui implementazioni pratiche vengono
anche definite con l’appellativo di dispositivi di memorizzazione di
massa.
Il tipo più importante di memoria principale è la memoria RAM
(Random Access Memory), ovvero memoria ad accesso casuale. Il
nome è giustificato dal fatto che l’accesso di un dato da questo tipo
di memoria può avvenire in maniera diretta e immediata
indipendentemente dalla posizione del dato stesso all’interno della
memoria (all’inizio o nella parte finale che sia).
Un’altra caratteristica importante della RAM è che essa è di tipo
volatile, cioè il suo contenuto va perso in assenza di alimentazione
elettrica. Questo è il motivo per cui i programmi vengono salvati sui

dispositivi di memorizza di massa (hard disk e similari).
In un computer è presente comunque un altro tipo di memoria, la
memoria ROM (Read Only Memory), anch’essa di norma
classificata come appartenente alla memoria principale. Si tratta di
dispositivi che riescono a conservare i dati anche in assenza di
alimentazione e per tale motivo vengono utilizzati per contenere i
dati fondamentali relativi all’accesso all’hardware del sistema. Tra
questi la tipologia più importante è data dal BIOS (Basic Input
Output System).
Un’ulteriore tipologia di memoria è rappresentata dalla cosiddetta
memoria cache o più semplicemente cache. Si tratta di un tipo di
memoria molto veloce e costosa utilizzata per immagazzinare
(cache significa “nascondiglio”) i dati che il sistema si presume dovrà
utilizzare di frequente.
I vari dispositivi di memorizzazione come gli hard disk (detti anche
dischi fissi o dischi rigidi), le penne USB e i vari CD o DVD riscrivibili
hanno la capacità di subire una fase di scrittura (output) così come
una fase di lettura dei dati (input) e sono quindi di tipo ibrido.
Come già detto, questi dispositivi prendono il nome di sistemi di
memorizzazione di massa e vengono anche definiti con il termine di
memoria secondaria per distinguerli dalla cosiddetta memoria
principale (RAM, ROM e cache).

Firmware: questo sconosciuto
Altra lezione di vita: le cose del mondo non sono mai tutte nere o
tutte bianche; il colore predominante è il grigio. Esiste, infatti, un
livello particolare di “software-hardware” denominato firmware. Il
firmware è un particolare software installato nell’hardware
direttamente dalla casa produttrice (firm in inglese significa
“azienda”) e che ha il compito di pilotare a bassissimo livello
l’hardware stesso.
Nella categoria del firmware ricade ad esempio il già citato BIOS, un
particolare tipo di software preinstallato nella macchina che serve a
gestire il processo di partenza o inizializzazione della macchina
stessa nel momento in cui la accendiamo.
Tale fase, nota con il termine di bootstrap, ha il compito di verificare

il funzionamento dei vari dispositivi hardware e predisporre la
macchina al successivo caricamento del sistema operativo (ad
esempio Windows). Visivamente tale processo si estrinseca con la
serie di voci di testo che è possibile notare quando appunto
accendiamo la macchina e che indicano il tipo di processore
utilizzato, la quantità di RAM installata e altre varie amenità. Nello
specifico questa fase prende il nome di POST (Power On Self Test),
ovvero autodiagnosi all’avvio.

Il software
Il software è ovviamente l’insieme dei programmi e dei dati che in
generale costituiscono il carburante e il motore stesso della
macchina. Senza software un PC sarebbe un’inutile scatola di
metallo, plastica e quant’altro. Microsoft Windows, Microsoft Word
piuttosto che il fantastico videogioco Halo sono banali esempi di
software.
Come quasi ogni elemento al mondo, anche il software ha le sue
inevitabili classificazioni. Infatti, esso viene di norma differenziato in
software di base e software applicativo.
Il software di base è costituito da programmi (o insiemi di
programmi) di enorme rilievo (ma d’altronde lo dice la parola stessa:
è di base). In questa sottocategoria rientrano, ad esempio, i Sistemi
Operativi (software di sistema), programmi di utilità varia (detti
anche tools) associati al sistema operativo (compressione dati,
manutenzione del sistema ecc.) e infine gli ambienti di sviluppo
(ovvero programmi per creare altri programmi) con di riflesso i
relativi linguaggi di programmazione.
Nella categoria del software applicativo rientrano tutti i programmi
di norma utilizzati dall’utente finale. Word, Excel, un programma di
fotoritocco; sono tutti esempi di software appartenenti a questa
categoria. Software specifici per problemi specifici.
Relativamente alla specificità del software è possibile effettuare
un’ulteriore distinzione tra software di tipo orizzontale e software
di tipo verticale.
Quelli di tipo orizzontale hanno scarsa specificità e sono quindi rivolti
a un’utenza molto vasta: un editor di testi oppure un software di

contabilità generale sono esempi classici ricadenti in tale categoria.
I software di tipo verticale al contrario sono fortemente “tipizzati”.
Essi sono rivolti a ben specifiche tipologie di utenti: un software per
la manutenzione della segnaletica stradale, uno per il controllo di
una centrale termoelettrica, piuttosto che un software per il controllo
del traffico aereo oppure uno per il supporto al calcolo per
costruzioni critiche in zone sismiche sono tutti esempi di software
verticali.

I Sistemi Operativi
I Sistemi Operativi nell’ambito del software di base fanno la parte del
leone. Ciò è tanto vero che spesso software di base e sistemi
operativi vengono considerati addirittura sinonimi. Essi sono gli
intermediari tra le funzionalità dei programmi generici, gli applicativi,
e l’hardware sottostante.
Le varie versioni di Microsoft Windows: 95, 98, 2000, XP, Vista, 7,
8, 10, sono tutti sistemi operativi (sicuramente i più conosciuti).
Sempre per rimanere nel contesto Microsoft è importante citare
l’ormai obsoleto, ma comunque in qualche modo presente, MS-DOS
(o più semplicemente DOS). Ma altri ne esistono e sono di enorme
importanza: Unix e Linux, per citare forse i più importanti, ma
ancora Android e iOS nel settore mobile. Tutti questi hanno
fondamentalmente lo stesso compito: evitare che i vari programmi
applicativi debbano preoccuparsi degli innumerevoli dettagli “di
basso livello” relativi all’hardware.
La questione è presto spiegata. Un applicativo qualsiasi, ad esempio
Microsoft Word, deve poter accedere all’hardware del sistema; per
leggere o scrivere un file su disco deve poter accedere al disco
stesso. Ovviamente, ogni disco ha le sue specifiche caratteristiche
fisiche. A tal proposito pensate alla differenza tra un disco fisso e un
cd-rom. In questa ottica, senza l’intermediazione del sistema
operativo la costruzione di un applicativo da parte di uno
sviluppatore risulterebbe essere un’opera titanica. Ciò che fa
l’applicativo è di limitarsi alla chiamata di una funzionalità messa a
disposizione dal sistema operativo (nota come system call) con la
quale delega il sistema operativo stesso ad eseguire l’accesso

all’hardware per suo conto.
Schematizzando al massimo l’organizzazione di un sistema
operativo, esso può essere visto essenzialmente come composto da
due principali sezioni: una denominata kernel (nucleo), che è quella
a più stretto contatto con l’hardware della macchina, e un’altra
denominata shell (guscio), più vicina all’utente, tanto da essere nota
anche con il termine di interfaccia utente. La shell, infatti, si
preoccupa di intercettare le richieste dell’utente e di passarle agli
strati più interni del sistema operativo per esaudire le richieste
dell’utente stesso.
Schematizzando ulteriormente quest’ultimo aspetto si può dire che
l’interfaccia utente può essere di due tipi fondamentali: interfaccia
grafica oppure interfaccia testuale.
L’interfaccia grafica è ormai familiare per chiunque usi un Personal
Computer oppure un qualsiasi tablet o smartphone. Essa, infatti, è
l’insieme delle icone e delle voci, selezionabili normalmente
attraverso l’utilizzo del mouse o con il tocco delle dita, che
consentono le normali operazioni di lancio di programmi, copia di file
e similari. Viene spesso anche definita come GUI ovvero Graphical
User Interface (appunto interfaccia grafica per l’utente).
L’interfaccia testuale, ormai ahimè sconosciuta ai più, è un metodo
alternativo, ma se conosciuto di enorme e superiore potenza, per
lanciare comandi e programmi sul sistema digitando il testo
appropriato per il comando specifico. Ad esempio, per visualizzare la
lista di determinati file su di una macchina Windows, è sufficiente
scrivere il comando “DIR” in un’apposita finestra nota come Prompt
dei comandi, battere il tasto “Invio” ottenendo un risultato analogo
(ma in semplice testo e senza icone) all’elenco visibile aprendo con
l’interfaccia grafica la cartella “Documenti”.

Software e commerciabilità
Il software, seppur “impalpabile”, è un bene di consumo a tutti gli
effetti. Questa considerazione sfugge ai più. Molti, infatti, ritengono
degni di essere acquistati con denaro contante solo i beni hardware,
probabilmente perché dotati di fisicità. D’altra parte questa
considerazione può forse aiutare a spiegare il fenomeno del

software contraffatto (le cosiddette copie pirata o “craccate”). In
realtà, attualmente il costo effettivo del software supera
abbondantemente quello dell’hardware.
Un’altra considerazione che ritengo degna di nota è relativa al fatto
che il software, in linea del tutto generale, non viene venduto ma
piuttosto dato in licenza. Per comprendere questo aspetto basta
pensare al fatto che se effettivamente il software venisse venduto
all’utente finale, quest’ultimo potrebbe farne delle copie e quindi
rivenderlo a sua volta. Ovviamente questo non è di norma possibile.
Ciò che l’utente ottiene in cambio del denaro è una licenza d’uso
del software stesso. È la licenza a definire diritti e limitazioni
dell’utente nei confronti del software acquistato (ad esempio la
possibilità di utilizzare il software solo su di un singolo computer per
volta).
Tuttavia non esistono solo software a pagamento. Infatti, oltre a
questo tipo di software, spesso indicato come software
commerciale o software proprietario, esistono altre differenti
categorie.
La categoria di software più vicina al software proprietario è lo
shareware.
Un software shareware è un tipo di software proprietario che viene
distribuito liberamente, normalmente tramite Internet, e che è di
solito una versione con una scadenza temporale. Spesso dopo
qualche decina di giorni di utilizzo il programma in questione smette
completamente di funzionare oppure, tramite un’apposita finestra
visualizzata al lancio dell’applicazione (finestra nota come Nag
Screen), invita l’utente ad acquistare il software in questione. Si
tratta, in definitiva, di un software da provare per verificarne l’utilità al
fine di effettuare un acquisto consapevole.
In altri casi, un programma di tipo shareware, pur non avendo un
limite di tempo e di numero di utilizzi ha invece una serie di
limitazioni nelle possibilità d’uso. Potrebbe essere impedito il
salvataggio del proprio lavoro in un file oppure, solo per fare un
esempio, nel caso di un programma che produce immagini, a queste
potrebbe essere sovrapposta una grande scritta che segnala il fatto
che si tratta di software di prova e quindi non licenziato. Ovviamente
dopo l’acquisto tali limitazioni vengono rimosse. Il più delle volte la

procedura prevede, dopo l’acquisto (di norma realizzato tramite
Internet), l’invio di una serie di “codici di sblocco” atti ad abilitare le
totali funzionalità del software stesso.
Generalmente il software di tipo shareware include programmi le cui
licenze hanno costi abbastanza contenuti (normalmente qualche
decina di euro) ma altrettanto spesso risultano essere di buona
qualità. Su Internet i software di tipo shareware vengono anche
definiti come demoware, oppure più spesso come trialware. In
realtà, a voler essere pignoli, qualche seppur piccola differenza tra le
tipologie demo, trial e shareware esiste. In generale una demo è un
software sicuramente limitato nelle funzionalità (viene distribuito a
puro titolo dimostrativo) mentre una versione trial di norma contiene
tutte le funzionalità al fine appunto di rendere possibile la trial (prova)
del software.
In ogni caso è spesso difficile riuscire a identificare queste piccole
differenze e, in linea generale, le tipologie in oggetto possono essere
considerate del tutto simili. A rafforzare questa considerazione c’è da
osservare come le licenze allegate a questo tipo di software siano
specifiche per ogni software e che ogni software house (azienda
produttrice di software) o il singolo sviluppatore rilascino licenze
“personalizzate”. È dunque importante leggere con attenzione le
singole licenze prima di procedere all’acquisto al fine di evitare
spiacevoli sorprese. Ad esempio potrebbe capitare di immaginare di
poter installare il software acquistato su differenti macchine quando
la licenza indica, tra le righe, che essa è invece vincolata a una
singola installazione.

Altre tipologie di software
Le tipologie di software che vi ho presentato fino a questo punto,
come già detto, rientrano nella classificazione di software
commerciale. Tuttavia, oltre a questa categoria, esiste una vera e
propria “galassia” di software non commerciali, di norma
identificati con il termine di software liberi o anche Open Source
(codice a sorgente aperto) e ancora software gratuiti. In realtà
software libero e open source non sono perfettamente sinonimi.
L’essere open source per un software significa dare la possibilità

all’utente di poter osservare, ed eventualmente modificare, il
software stesso e rappresenta quindi un prerequisito per il software
libero. Il termine software libero, invece, serve a esaltare il concetto
relativo alla libertà di usare il software: eseguirlo per qualsiasi scopo,
distribuirlo in un numero qualsiasi di copie ecc. Ma ciò non riguarda
la questione del prezzo: non viene impedito di guadagnare
economicamente dall’eventuale distribuzione di tale software.
Di seguito cerco di chiarire alcuni degli aspetti fondamentali rispetto
a tali categorizzazioni, limitandomi a citare i nomi e gli elementi più
significativi. Infatti, le licenze relative ai software non commerciali
sono, inaspettatamente per un “profano”, davvero tantissime.
Un primo termine che è facile incontrare nel contesto del software
libero è PD. L’acronimo si riferisce al software di tipo Public Domain
(in italiano di Pubblico Dominio). Si tratta di software rilasciato
senza alcuna licenza specifica e quindi non coperto da copyright.
L’autore rinuncia a qualsiasi tipo di diritto sul software in questione.

• Software freeware è un altro appellativo che si
riferisce in generale a software gratuito (free in
questo caso sta appunto per gratuito). Ma bisogna
fare molta attenzione a non usare questo termine
come sinonimo di free software. In quest’ultimo
caso, infatti, il termine free sta a indicare libero e
quindi, free software significa software libero.
Altri termini e relative tipologie di software che si incontrano
facilmente sono:

• Adware: si tratta di un software che viene
distribuito a titolo gratuito ma che contiene varie
forme di pubblicità (la “Ad” iniziale del nome è la
contrazione di advertising, ovvero pubblicità).
Sono programmi da utilizzare con una certa
attenzione, in quanto in alcuni casi possono

nascondere delle funzionalità pericolose per la
privacy dell’utente.
• Donationware: in questo contesto l’autore
richiede una donazione facoltativa per l’utilizzo del
software (a volte anche in favore di terzi, enti
benefici o similari). Essendo la donazione non
obbligatoria, tale software può ricadere nell’ambito
del freeware.
• Abandonware: si tratta di software ormai obsoleti
e non più appetibili dal punto di vista commerciale
per le aziende che li avevano prodotti. Spesso
vengono rilasciati gratuitamente con scopo
pubblicitario per invogliare all’acquisto di nuove
versioni del pacchetto in questione.
Un ultimo nome, proposto dall’autore stesso, per un’altra tipologia di
software, è vivariumware.

• Vivariumware è un neologismo che nasce con
l’intento di dare una collocazione tipologica alle
applicazioni nate in ambito sperimentale e
didattico. Il termine è l’unione delle parole
vivarium, dall’inglese (di derivazione latina) con
significato di “vivaio”, e dalla arcinota parola ware
che, sempre dall’inglese, ha il significato di
materiale. Si tratta, dunque, di materiale da vivaio;
ovvero progetti nati con lo scopo di insegnare un
determinato contesto tecnologico che possono
tuttavia essere i semi di futuri sviluppi. Ci si
riferisce quindi al lavoro prodotto da gruppi di

persone (principalmente ragazzi e di norma in
ambito scolastico come esercitazione all’uso delle
tecnologie informatiche) che si avvicinano alla
produzione di pagine per Internet, così come ai
linguaggi di programmazione. Tra i tanti progetti
realizzati possono di sicuro anche nascere
germogli di creatività e innovazione.

Linguaggi naturali e artificiali
Comunicare è essenziale. Comunicare significa trasmettere
informazione. Si tratta di un processo che utilizziamo ogni giorno per
interagire con il mondo che ci circonda. Qualunque sia la forma di
comunicazione che utilizziamo: scritta, parlata, elettronica, cartacea
tradizionale o qualunque altra cosa vi venga in mente, alla base di
essa vi è un linguaggio.
In generale, un linguaggio può essere visto come costituito da un
insieme di simboli organizzati in modo da costituire parole. A ogni
parola è associato un oggetto o più in generale un concetto.
L’insieme di tutte le parole di un linguaggio prende il nome di
lessico. Si tratta in buona sostanza del dizionario del linguaggio in
questione.
Facciamo un banale esempio: nella lingua italiana i simboli
elementari sono le lettere dell’alfabeto, dalla ‘a’ alla ‘z’. Combinando
in vario modo tali lettere otteniamo le parole del linguaggio: da
“abaco” a “zuzzurellone”, costruiamo il lessico della nostra lingua.
Tuttavia le parole da sole non sono sufficienti a realizzare un
linguaggio. Abbiamo bisogno di una serie di regole grammaticali
che stabiliscano come le parole debbano essere legate tra di esse.
Tali regole prendono il nome di sintassi del linguaggio.
Una qualsiasi proposizione (frase) del linguaggio deve contenere
una certa quantità di informazioni. L’insieme delle regole che
consentono di dare significato al linguaggio prende il nome di
semantica.
I linguaggi utilizzati per comunicare tra esseri umani prendono il
nome di linguaggi naturali; banalmente, in questa categoria
rientrano la lingua italiana, la lingua inglese, il giapponese e tutte le
altre lingue che vi vengono in mente.
Ma come facciamo a comunicare con le macchine? Se è difficile, a
volte, farsi capire da un umano utilizzando la sua stessa lingua
(linguaggio naturale), figuriamoci come può essere complicato
utilizzare il linguaggio naturale con il nostro PC.

NOTA In questo contesto ignoro volutamente ciò che attiene alle
problematiche relative al riconoscimento vocale.
Sin dagli albori dell’informatica sono stati sviluppati tutta una serie di
linguaggi specifici per comunicare le istruzioni da far eseguire alle
macchine: tali linguaggi nel loro complesso prendono il nome di
linguaggi artificiali (o anche linguaggi formali).

I programmi traduttori
Il punto iniziale e finale della comunicazione tra due esseri umani è il
cervello. Con questo voglio dire che l’informazione da trasmettere
proviene da un concetto, un pensiero partorito dalla mente di chi
parla e che deve raggiungere il cervello di chi ascolta. Il cervello del
“mittente” provvede a pilotare l’apparato vocale per creare un flusso
di suoni (le parole) che raggiungeranno l’apparato uditivo del
destinatario della comunicazione. Sarà infine il cervello del
destinatario a separare i singoli suoni per ricostruire le parole (e
quindi poi il significato) relativo al messaggio originario.
È ovvio che in questo contesto non ci soffermiamo sulle dinamiche di
funzionamento del cervello umano. Tutta questa introduzione mi
serviva per porre l’accento sul concetto di cervello, e quindi del suo
“omologo” nel campo dei linguaggi artificiali e quindi delle macchine.
Ebbene, il cervello dei calcolatori elettronici, per quanto complessi
questi possano essere, si basa sulla logica binaria (gli ormai noti
valori 0 e 1). Ciò significa che le istruzioni e i comandi che il cervello
delle macchine può gestire sono sequenze di bit. A ogni sequenza di
bit corrisponde un’azione elementare che tale cervello, la CPU, può
eseguire.
Operazioni classiche possono essere, ad esempio, la lettura di un
elemento specifico dalla memoria del PC, la scrittura in memoria di
un dato valore, la somma tra due valori ecc.
L’insieme di tutte le istruzioni elementari che la CPU può gestire,
unitamente alle regole impiegate per il loro utilizzo, prende il nome di
linguaggio macchina.
Una tipica istruzione in linguaggio macchina è composta da due
parti: la prima, che prende il nome di codice operativo, indica il tipo
di azione che deve essere effettuata e una eventuale seconda parte
che contiene uno o più operandi. Tali operandi specificano le celle di
memoria sulle quali effettuare l’operazione (istruzione) indicata dal
codice operativo.
Come ho già detto, il tutto è espresso attraverso una sequenza di
cifre binarie.

È facile comprendere quale debba essere la difficoltà dal punto di
vista del programmatore umano che deve comunicare con la
macchina utilizzando sequenze di 0 e di 1. In effetti, agli albori
dell’informatica, le cose procedevano proprio in questo modo.
Per rendere più evidente tale difficoltà vi basterà immaginare che
una tipica istruzione in linguaggio macchina è qualcosa del tipo:
0100 0000 0000 1001

Il primo passo compiuto per semplificare tale comunicazione fu
quello di associare dei codici mnemonici alle sequenze di bit
rappresentanti le istruzioni del linguaggio macchina.
Il linguaggio che ne derivò prese il nome di linguaggio assembly.
La precedente istruzione, convertita nel linguaggio diventa allora
qualcosa di più comprensibile come la seguente:
READ 9

Tale conversione si è ottenuta sostituendo, nell’istruzione in
linguaggio macchina, ai prima quattro bit (0100) il codice mnemonico
READ mentre i restanti bit rappresentano l’operando espresso in
notazione decimale (0000 0000 1001 = 9).
Una prima cosa che mi sento di sottolineare è che spesso si
confonde il linguaggio assembly con l’assembler, utilizzando tale
termine come sinonimo di assembly.
In senso più rigoroso, infatti, per assembler si intende il programma
che converte i codici mnemonici dell’assembly nei veri e propri codici
binari del linguaggio macchina. Nel nostro esempio, sarà proprio
l’assembler a sostituire in fase di traduzione al codice READ il
corrispondente binario (0100). Nella Figura 1.1 vi propongo l’output
di un classico programma assemblatore, il MASM, che visualizza il
contenuto di un semplice file eseguibile.
Nella figura in questione sono riconoscibili quattro sezioni (colonne)
fondamentali. La prima mostra l’indirizzo di memoria, in formato
esadecimale, in cui è stata caricata l’istruzione corrispondente alla
specifica riga del file. La seconda colonna mostra, sempre in
esadecimale, l’istruzione vera e propria in linguaggio macchina.
Infine, la terza e la quarta colonna mostrano il codice assembly
corrispondente al codice macchina della seconda colonna. Nella

terza colonna viene visualizzato il codice operativo (push, mov, call)
mentre nella quarta il relativo operando.

Figura 1.1 – Un file eseguibile “disassemblato”.
Un grosso limite del linguaggio assembly è tuttavia insito nella sua
estrema vicinanza all’hardware della macchina. Mi spiego: essendo
composto da istruzioni specifiche della singola CPU, un programma
scritto per una data architettura hardware non può essere utilizzato
su di una macchina con architettura differente. In gergo tecnico si
dice che esso non è “portabile” o, più propriamente, che non ne è
consentita la portabilità.
Un’altra cosa di notevole interesse che vale la pena di sottolineare è
il fatto che tale conversione introduce un concetto di estrema
importanza: la traduzione.
Ciò che infatti resta sotteso a questo contesto è la possibilità di

demandare a uno specifico programma il compito di effettuare la
traduzione, a partire da un linguaggio più vicino all’utente (in questo
caso i codici mnemonici più facilmente gestibili), verso il linguaggio
effettivamente compreso dalla macchina.
Tale “scoperta” ha dato luogo a tutta una serie di nuovi linguaggi
sempre più vicini alla logica umana e sempre più lontani dai dettagli
interni dei vari microprocessori.
Quando si parla di linguaggi a “basso livello” e linguaggi ad “alto
livello” ci si riferisce appunto alla vicinanza, o meno, dello specifico
linguaggio rispetto alla macchina e all’utente. Sarà di basso livello un
linguaggio molto vicino ai dettagli hardware della macchina; sarà di
alto livello, al contrario, un linguaggio vicino al linguaggio naturale e
al modo tipicamente umano di gestire i problemi.

Interpreti e compilatori
In linea del tutto generale tale traduzione può avvenire in due modi
distinti: tramite interpretazione oppure tramite compilazione.
L’interpretazione consiste nella traduzione delle singole istruzioni,
una dopo l’altra, e nella loro immediata codifica in linguaggio
macchina e corrispondente esecuzione.
Una considerazione che risulta naturale in tale contesto di
traduzione è data dal fatto che, affinché sia possibile tale
procedimento, è necessario che sulla macchina che ha in
esecuzione il nostro programma sia presente anche l’apposito
programma traduttore: l’interprete.
“Interprete” è infatti il nome del programma che deve risiedere sul
PC in questione affinché si possa eseguire il nostro programma
scritto in linguaggio di alto livello. In generale, come conseguenza di
tale situazione, i linguaggi che utilizzano questo approccio vengono
definiti linguaggi interpretati.
Per rendere la mia descrizione più concreta mi sento di dover
presentare qualche esempio specifico. Linguaggi tipicamente
interpretati sono quelli utilizzati per le applicazioni rese disponibili su
Internet: JavaScript e PHP, solo per citarne due tra i più diffusi.
Discorso diverso è quello relativo ai linguaggi compilati, ovvero
quelli che si basano sulla compilazione: questi prevedono, come
nel caso di quelli interpretati, la traduzione delle singole istruzioni in
alto livello nelle specifiche istruzioni del linguaggio macchina.
Tuttavia, tali istruzioni non vengono eseguite direttamente; al
contrario, esse vengono salvate, già tradotte in codice macchina, in
specifici file: i file eseguibili.

A spasso con una “macchina virtuale”
Interpretazione e compilazione non sono due mondi completamente
separati. Esistono tuttavia dei linguaggi che si collocano a metà
strada tra i linguaggi macchina (assembly incluso) e i linguaggi ad
alto livello e che prendono il nome di bytecode. Tali linguaggi sono
costituiti da un numero di istruzioni abbastanza limitato e tali da
essere relativamente vicine all’hardware. Ciò rende più semplice
creare degli ambienti traduttori maggiormente efficienti e al
contempo “portabili” su sistemi operativi differenti. Questo è infatti
uno snodo importante!
Quando si scrive del codice e lo si compila, lo si fa per un
determinato e specifico sistema operativo (Windows, Linux o quello
che sia). È il sistema operativo che mette a disposizione le
funzionalità per l’accesso all’hardware sfruttate dagli applicativi. Tali
funzionalità vanno sotto il nome di API, ovvero Application
Programming Interface (Interfaccia di Programmazione per
l’Applicazione). Va da sé che utilizzando una determinata API di uno
specifico sistema operativo ci si lega con la propria applicazione a
quello specifico sistema operativo. Per superare tali problemi di
portabilità, e al contempo per fornire allo sviluppatore il maggior
numero di funzionalità di accesso all’hardware in maniera predefinita
senza che lo sviluppatore sia costretto a codificare in proprio tali
funzionalità, sono nate delle interfacce software da frapporre tra il
sistema operativo e l’applicativo stesso. Concentrando lo sviluppo
del codice riferendosi a tale interfaccia, nota come macchina
virtuale, il nostro programma sarà liberamente utilizzabile su vari
sistemi operativi a patto che su questi sia presente la specifica
macchina virtuale.
Giusto per fare qualche esempio di bytecode possiamo pensare al
bytecode di Java eseguito dalla cosiddetta Java Virtual Machine.
Dal lato Microsoft è presente il Common Intermediate Language
della piattaforma .NET, eseguito dal Common Language Runtime
(CLR), la macchina virtuale per il mondo .NET.
Ovviamente, come detto e come evidenziato dalla Figura 1.2, la

specifica macchina virtuale deve essere presente sul sistema in
questione.

Figura 1.2 – La finestra “Programmi e funzionalità” di Windows con i riferimenti al
framework .NET.

Il C e le sue origini
Il linguaggio C venne sviluppato negli Stati Uniti tra il 1972 e il 1973,
all’interno dei laboratori Bell, ad opera di Dennis Ritchie.

Figura 1.3 – Dennis Ritchie (in piedi) con Ken Thompson (seduto).
Il “C” discende da un altro linguaggio chiamato BCPL implementato
da Martin Richards. Infatti, Ken Thompson realizzò una prima
evoluzione del BCPL nel 1970 denominandola Linguaggio B.
Successivamente, Ritchie migliorò il linguaggio denominandolo C a
confermare una continuità con il linguaggio precedente.
Il C rientra a tutti gli effetti nei linguaggi ad alto livello: tuttavia viene
spesso descritto come “linguaggio di basso livello”, intendendo con
ciò che esso consente di interagire con componenti molto vicine
all’hardware del sistema. Il C può quindi generare programmi di
grande efficienza e velocità. D’altro canto si presta a essere

utilizzato anche in innumerevoli contesti generici, potendo infatti
gestire programmi di notevoli dimensioni e complessità.
Il C ha iniziato a godere di enorme popolarità in seguito alla
pubblicazione del libro The C Programming Language, tradotto
anche in Italia, e realizzato da Ritchie insieme a Brian Kernighan.
L’ottimo libro in questione ha rappresentato il principale riferimento
del linguaggio. Ne è seguita una seconda edizione relativa alla
standardizzazione ottenuta dal C da parte dell’ente internazionale
ISO. Per comprendere l’importanza di questo libro (e quindi anche il
motivo per cui ne riporto in Figura 1.4 la copertina) basta pensare al
fatto che per esso si è addirittura coniato un apposito termine per
definirlo: “The white book” (ovviamente per il colore della sua
copertina).

Figura 1.4 – La mia copia, un po’ logora e custodita gelosamente nella mia
libreria, della prima edizione italiana del manuale di Kernighan e Ritchie.

Il C come primo linguaggio
Il C viene spesso considerato un linguaggio complicato e con una
curva di apprendimento abbastanza alta: ciò significa che la sua
comprensione e il suo relativo utilizzo richiedono una quantità di
tempo non trascurabile. Questo è probabilmente uno dei motivi che
spingono molti autori di testi generici di informatica a privilegiare
l’utilizzo di un altro linguaggio, almeno in apparenza più semplice: il
Pascal.
L’utilizzo del Pascal viene motivato considerando che la sua
semplicità aiuta a comprendere gli aspetti generali dei problemi di
programmazione evitando di impegolarsi con i dettagli specifici del
linguaggio. Ritengo tuttavia che, con uno sforzo minimo, tale
difficoltà possa essere superata ottenendo al contempo enormi
benefici. Tali benefici risiedono innanzitutto nell’apprendimento di un
linguaggio di enorme potenza e diffusione come il C. Il C è, infatti,
facilmente disponibile in vari e differenti ambienti (Windows, Unix,
Linux) consentendo di trasportare i propri lavori con estrema
semplicità.

Ambienti di sviluppo
La semplice traduzione da linguaggio ad alto livello a linguaggio
macchina a volte non è sufficiente. Infatti, in generale c’è bisogno di
una fase preventiva di editazione (scrittura) del codice sorgente
(ovvero delle singole istruzioni del linguaggio di programmazione) e
del suo relativo testing (prova che tutto sia come ci aspettiamo).
Ancora, c’è la necessità di consentire di accedere a un’enorme mole
di esempi reali: con il C, infatti, sono scritti buona parte dei più
importanti e diffusi Sistemi Operativi di cui sopra. Ciò significa avere
un programma che ci faciliti la scrittura del nostro codice nello
specifico linguaggio scelto, eventualmente segnalandoci gli errori
commessi direttamente in fase di editazione supportandoci inoltre
con un help (aiuto) in linea del linguaggio.
Tali software prendono il nome generico di ambienti di sviluppo
spesso anche conosciuti con il termine di IDE, ovvero Integrated
Development Environment (Ambienti di Sviluppo Integrati).
Solo per citarne alcuni: Turbo C, Dev-C++, Visual C++,
Code::Blocks, SharpDevelop, MinGW.

Figura 1.5 – L’IDE di SharpDevelop.

Gli ambienti di sviluppo per il C
Gli ambienti di sviluppo utilizzabili per scrivere programmi in
linguaggio C sono davvero tantissimi. Di seguito vi elenco alcuni tra i
più noti, cercando di suggerire i più adatti a seconda del contesto
d’uso.

Un C con il “Turbo”
Un ambiente spartano ma sufficientemente completo, utile per
muovere solo i primissimi passi con il C, è il “Turbo C” della Borland.
Questo ambiente di sviluppo può essere una scelta iniziale per chi
utilizza ambienti Microsoft Windows su hardware molto scadente dal
punto di vista delle prestazioni.
La versione 2.01 è ormai utilizzabile gratuitamente per scopi
personali, essendo non più aggiornata dalla Borland e facilmente
scaricabile da Internet. Il Turbo C è un ambiente integrato che
consente di scrivere facilmente applicazioni di tipo console DOS
(solo testuali) e un buon banco di prova per sperimentare i rudimenti
della programmazione e conoscere uno dei primi ambienti di
sviluppo per poter poi apprezzare le enormi migliorie apportate dai
moderni compilatori.
Il Turbo C è un ambiente integrato che consente di editare (scrivere)
i sorgenti, di correggerli con l’ausilio di appositi strumenti di
correzione (debugging), di compilarli e di eseguirli.
Una volta installato e “lanciato” (mandato in esecuzione) l’ambiente
si mostra come nella Figura 1.6.

Figura 1.6 – L’ambiente “Turbo C”.
In esso è facile distinguere due zone principali: una prima riga di
menu (File, Edit, Run) contenente tutta una serie di comandi per la
gestione delle operazioni da compiere all’interno dell’ambiente, e
una zona di “editing” in cui è possibile scrivere (editare) il codice
sorgente.
Tuttavia, mi sento di sottolineare come il Turbo C rivesta più che
altro un interesse “storico”. Oggi, infatti, sono disponibili ambienti
più moderni ed evoluti, sicuramente preferibili all’ormai vetusto Turbo
C. Di seguito ve ne presento una panoramica.

L’ambiente Bloodshed Dev-C++
Bloodshed Dev-C++ è un ambiente di sviluppo per Windows gratuito
e completo.
La Figura 1.7 mostra il cosiddetto IDE dell’ambiente in questione.
IDE è, come abbiamo già detto, l’acronimo di Integrated
Development Environment (ambiente di sviluppo integrato) che
mette a disposizione in un unico contesto (appunto integrato) tutti gli
strumenti necessari per editare, compilare ed eseguire il codice.

Figura 1.7 – L’IDE di Dev-C++ in esecuzione su Windows 7.
È importante notare come questi ambienti moderni diano la
possibilità di costruire differenti tipi di programmi. È infatti possibile
realizzare i classici programmi di tipo “console”, cioè i programmi
che “girano” in una finestra DOS, così come programmi che
posseggono una GUI. Come detto in precedenza, questo è il termine
con il quale ci si riferisce a una interfaccia grafica, vale a dire la
classica applicazione con finestre che siete abituati a vedere, ad
esempio, all’interno del sistema operativo Windows. Non a caso, tale
tipo di applicazione viene anche definito Windows Application.
Ancora, è possibile creare file di tipo dll.
Per rendere possibile tale varietà di realizzazioni questi ambienti
fanno uso del concetto di progetto. Un progetto, realizzato e
descritto tramite uno specifico file (noto appunto come file di
progetto) definisce le caratteristiche della specifica applicazione e
contiene l’elenco dei differenti file di codice sorgente che vanno a
comporre l’intera struttura del programma. La Figura 1.8 mostra una
finestra, propria dell’ambiente Dev-C++, all’interno della quale è

possibile definire le caratteristiche generali del progetto stesso.
Da notare infine come sia possibile, attraverso lo stesso ambiente di
sviluppo, creare sia progetti scritti in C che progetti in C++ (il
linguaggio che rappresenta un’evoluzione del C originario).

Figura 1.8 – La finestra di scelta delle caratteristiche del progetto.
Dev-C++ non viene più aggiornato dal lontano 2005 ma nonostante
ciò, data la sua semplicità d’uso, risulta molto utilizzato soprattutto in
ambito didattico.

Orwell Dev-C++
Come detto, Bloodshed Dev-C++ non è più aggiornato da ormai
diversi anni. Uno dei problemi collegati a tale situazione è il fatto che
esso non risulta del tutto compatibile con i nuovi sistemi operativi,
come ad esempio Windows 8 e 10. Nel caso specifico di tali sistemi
operativi, le versioni in questione presentano dei problemi di
compatibilità relativi in particolare al compilatore integrato
nell’ambiente. Per questo motivo vi suggerisco di scaricare e
utilizzare una versione derivata da quella originale, un cosiddetto
fork, manutenuto da un programmatore di nome Orwell. Tale
versione è disponile all’indirizzo orwelldevcpp.blogspot.it ed è nota
come Orwell Dev-C++.
Uno dei vari aspetti interessanti di tale versione è che essa è
disponibile sia in 32 che 64 bit. Sul sito, in lingua inglese, troverete

tutte le informazioni di cui doveste necessitare. È inoltre disponibile
una versione portable, ovvero portabile. Si scarica un file
compresso e si decomprime l’intera struttura di cartelle in una
posizione a piacere del proprio disco. Non è quindi necessaria
l’installazione e per lanciare l’ambiente è sufficiente fare un doppio
clic sull’eseguibile dell’ambiente.
Orwell Dev-C++ è uno degli ambienti di sviluppo che vi proporrò in
questo testo. Occorre notare come esso venga utilizzato come
strumento ufficiale nelle Olimpiadi di Informatica. Nel sito di
riferimento di tale importante competizione, www.olimpiadiinformatica.it, sono disponibili per il download varie versioni di DevC++, unitamente ad altro materiale di grande interesse.

L’ambiente Code::Blocks
Code::Blocks è un altro ambiente gratuito. Esso è reperibile
all’indirizzo www.codeblocks.org.
Si tratta di un ambiente più evoluto e leggermente più complicato
nell’uso rispetto a Dev-C++. Code::Blocks può essere una valida
scelta da utilizzarsi dopo aver familiarizzato con gli aspetti di base
del C/C++ utilizzando il più semplice Dev-C++, oppure come prima
scelta d’uso nel caso di coloro che non volessero utilizzare, per un
qualsiasi motivo, ambienti Microsoft Windows. Infatti, Code::Blocks
oltre che per Windows, è disponibile per Linux e per Mac.

Figura 1.9 – L’IDE di Code::Blocks.

Microsoft Visual C++
Tra i più completi e potenti ambienti disponibili sul mercato, Visual
C++ è l’ambiente di sviluppo per C e C++ di casa Microsoft.
Microsoft ha reso disponibile tale compilatore anche in una versione
gratuita denominata Express Edition e la nuova Visual Studio
Community. Si tratta di versioni con alcune limitazioni, che
comunque non ne inibiscono le funzionalità principali, segnando
d’altro canto come punto a favore il fatto che la licenza consente di
creare anche software di tipo commerciale. Il sito di riferimento è
ovviamente www.microsoft.com.

GCC: GNU Compiler Collection
GCC è un ambiente di compilazione nato inizialmente per
supportare solo il C, tanto che il senso dell’acronimo era “GNU C
Compiler”.

Successivamente esso fu esteso per supportare il C++ e ancora più
tardi per consentire l’uso di altri linguaggi come il Fortran, il Pascal e
altri ancora.
GCC nasce in ambiente Unix-Linux e il suo uso classico prevede
l’interfaccia testuale. Il sito ufficiale è gcc.gnu.org.
Per poter utilizzare GCC sotto Windows è possibile fare riferimento
al sistema MinGW ovvero “Minimalist GNU for Windows” disponibile
all’indirizzo www.mingw.org.

Creare programmi con interfaccia
grafica
Come già accennato, i programmi che vi aiuterò a sviluppare nei
capitoli seguenti sono di tipo testuale e sono quindi privi di
interfaccia grafica (finestre, bottoni, menu ecc.). Sarà solo nel
Capitolo 27 che vi darò indicazioni dettagliate e puntuali per
realizzare applicazioni di tipo Windows.
Il motivo è dato dal fatto che il C non prevede in maniera naturale la
gestione di questi oggetti, come avviene al contrario in ambienti
come Visual Basic. Per poter realizzare interfacce grafiche è
necessario allora utilizzare delle apposite librerie: MFC, GTK, QT o
altre ancora. Rimane comunque il fatto che la conoscenza di quanto
affronteremo di seguito è indispensabile per poter gestire
successivamente l’utilizzo di una qualsiasi di tali librerie.

2
Salve, mondo
Parlare è facile. Mostrami il codice.
Linus Torvalds
È abitudine consolidata, nel momento in cui si introducono i
rudimenti di un qualsiasi linguaggio di programmazione, presentare
immediatamente un primo esempio di programma il cui risultato
deve essere semplicemente la stampa a video delle parole “Salve,
mondo”.
Credo che il risultato di presentare da subito un esempio funzionante
sia duplice. Da un lato si riesce a fornire immediatamente la filosofia
e il carattere del nuovo linguaggio. Al contempo si riesce a
coinvolgere, quasi emotivamente, il neofita che, messo alla prova,
ottiene da subito i primi risultati superando nei fatti una naturale
incertezza e diffidenza nei confronti della sua iniziale ignoranza.
Non vedo quindi ragione per cambiare la tradizione del “Salve,
mondo” per cui pronti... si parte:
#include <stdio.h>
/* Il mio primo programma C */
main()
{
printf("salve, mondo");
}

Anche se molto semplice (ma sappiamo che prima di correre

dobbiamo almeno imparare a camminare) questo pezzo di codice
racchiude in sé diversi elementi relativi al linguaggio che sono di
notevole importanza.
Prima importante premessa: attenzione alla differenza tra
minuscole e maiuscole. Il C è molto formale a tal proposito, per cui
si aspetta che le istruzioni vengano scritte rispettando tale regola,
detta in gergo di case sensitive. Per cui, scrivere Main anziché main
comporterà la segnalazione di un errore da parte del compilatore.
Innanzitutto osserviamo che esso inizia con la dicitura:
#include <stdio.h>

Il C, contrariamente a quanto si potrebbe pensare data la sua
potenza, è un linguaggio molto povero; la maggior parte delle sue
funzionalità sono infatti incapsulate in file esterni. È il caso anche
delle funzioni di input e output che nello specifico fanno riferimento al
file “stdio.h”. Per input e output si intende ovviamente la possibilità
riservata al nostro programma di acquisire dati, ad esempio dalla
tastiera (input), e di fornire dati verso l’esterno (output) in generale
attraverso il monitor.
La riga seguente:
/* Il mio primo programma C */

introduce l’uso dei commenti nel codice. Un commento è un testo
descrittivo che viene ignorato dal compilatore ma che è comunque di
fondamentale importanza. Esso serve a chi legge il codice sorgente
per capire cosa faccia un determinato pezzo di codice. Anche se tale
codice può sembrare scontato per chi lo sta scrivendo, potrebbe
risultare oscuro per chi dovesse andare a modificarlo in un secondo
tempo. Tale persona potrebbe essere anche l’autore stesso. Non
sottovalutate, infatti, la capacità di dimenticare le cose che ognuno di
noi ha innata.
Abituarsi sin dall’inizio a commentare con attenzione ciò che
codifichiamo potrà farci risparmiare tempo in futuro ed evitarci
pericolose maledizioni da parte di chi dovrà interpretare ciò che
avevamo in testa.
Il funzionamento in C dei commenti è molto semplice: ogni
commento deve iniziare con la simbologia /* e terminare con */.

Tutto ciò che si trova all’interno di questi marcatori, come detto,
viene totalmente ignorato in fase di compilazione.
Proseguendo nell’analisi del nostro codice incontriamo un’istruzione
main() che è di fondamentale importanza in quanto essa rappresenta
il punto di ingresso del programma. Ciò riguarda il fatto che ogni
programma scritto in C deve avere una istruzione main per consentire
alla macchina di comprendere da dove deve iniziare a eseguire le
istruzioni. A voler essere più precisi, l’istruzione main è più
propriamente definibile come funzione, vale a dire un pezzo di
codice che viene eseguito tutto di un fiato dalla prima riga fino
all’ultima (a meno che non si chieda il contrario in maniera esplicita).
Come tutte le sequenze di istruzioni che identificano un blocco a sé
stante, essa deve essere delimitata dall’apertura e dalla chiusura di
parentesi graffe {}.

Se le parentesi graffe non sono presenti sulla tastiera è
possibile inserirle digitando sul tastierino numerico il
numero decimale corrispondente nel codice ASCII al
simbolo della parentesi, avendo l’accortezza di tenere
premuto il tasto ALT. Nello specifico, per inserire la
parentesi graffa aperta è necessario digitare ALT+123
NOTA (tenere premuto il tasto ALT, digitare il numero 123 e poi
rilasciare). Per la parentesi graffa chiusa, digitare
ALT+125.
In alternativa le combinazioni CTRL + ALT + SHIFT + [ e
CTRL + ALT + SHIFT + ]
Sulle tastiere Mac di casa Apple è sufficiente utilizzare le
combinazioni ALT + SHIFT + [ e ALT + SHIFT + ]
Veniamo ora al cuore del nostro programma: la fase di stampa della
stringa, ovvero della sequenza di caratteri, "salve, mondo".
L’istruzione che consente la stampa è printf. Essa deve includere tra
parentesi tonde ciò che vogliamo stampare a video. Si deve avere
l’accortezza di racchiudere il tutto tra doppi apici onde evitare
spiacevoli messaggi di errore da parte del compilatore.
Ok, ancora un paio di note e il nostro primo programma non avrà più

segreti.
La prima nota riguarda il punto e virgola posto alla fine
dell’istruzione. Ogni istruzione (tranne rari casi che vedremo in
seguito) deve essere terminata con un punto e virgola. Ciò risulta
indispensabile per far comprendere al compilatore dove un’istruzione
inizia e dove essa finisce.
L’ultima nota riguarda gli spazi che sono stati posti all’inizio
dell’istruzione printf. Tali spazi, noti come indentazione del codice,
servono a rendere più leggibile il codice stesso separando in
maniera visiva blocchi di codice omogeneo. Tali spazi sono, come
per i commenti, ignorati dal compilatore ma estremamente importanti
per il programmatore, al fine di dare leggibilità e facilità di
interpretazione a ciò che scriviamo. Valgono qui un po’ le stesse
avvertenze che ho dato relativamente ai commenti: non sottovalutate
le maledizioni che vi potrebbero mandare i programmatori chiamati a
revisionare ed eventualmente modificare il vostro codice.
In realtà più che spazi è assolutamente consigliato usare il tasto di
tabulazione, di norma etichettato con due frecce orizzontali che si
contrappongono e situato sopra il tasto di “blocca maiuscole”. Tale
tasto, di norma chiamato tab, inserisce appunto un carattere di
tabulazione, ovvero un singolo carattere che rappresenta di norma
tre o più singoli spazi. L’uso di tale carattere consente indubbi
vantaggi nella formattazione del codice.
Già che sto andando lungo con note e commenti aggiungo un’altra
considerazione, forse scontata ma che vale la pena comunque di
ribadire. Un programma è per certi aspetti una cosa viva; è difficile
che un certo software, una volta realizzato, non necessiti di ulteriori
interventi. Al contrario la norma è che esso richiederà, anche dopo il
suo completamento, una serie di interventi successivi atti a
correggere eventuali errori di programmazione (bugs) o
l’implementazione di nuove funzionalità.

“Salve, mondo” con Dev-C++
Abbiamo già ampiamente descritto come sia importante l’aspetto
pratico nell’attività di programmazione; non è sicuramente mia
intenzione smentirmi proprio in questa fase iniziale, per cui:
passiamo all’azione!
Per farlo vi propongo la realizzazione del nostro semplice “salve,
mondo” utilizzando l’ambiente di sviluppo Orwell Dev-C++ per il
quale vi illustrerò una serie di operazioni da seguire passo-passo per
compilare il vostro primo programma C.

NOTA

Come già indicato nel precedente capitolo, nel caso di utilizzo sul Sistema
Operativo Windows 8 o superiore la versione originale di Dev-C++ presenta
dei problemi di compatibilità relativi al compilatore integrato nell’ambiente.
questo è il motivo principale per cui vi suggerisco di scaricare e utilizzare la
versione derivata da quella originale denominata Orwell Dev-C++. Tale
versione è disponibile all’indirizzo: orwelldevcpp.blogspot.it.

La procedura di installazione non presenta problemi particolari per
cui presumo che nel giro di pochi minuti sarete pronti a seguirmi nel
lancio dell’ambiente Dev-C++.
La prima operazione da realizzare è la creazione di uno specifico
progetto; per farlo agite sulla voce “Nuovo” del menu “File”
selezionando l’elemento di menu “Progetto” (Figura 2.1).
La successiva finestra di dialogo consente di impostare i principali
parametri richiesti dalla nostra applicazione.
Come si evince dalla Figura 2.2 è necessario impostare innanzitutto
il tipo di progetto su “Console Application”. Ciò consentirà la
realizzazione di programmi di tipo testuale che girano all’interno di
un a finestra di tipo DOS.
Nelle opzioni del progetto è molto importante scegliere un nome
consistente attinente al progetto che stiamo realizzando; sarà infatti
tale nome a rappresentare, oltre che il nome del progetto, il file
eseguibile stesso. Nel nostro caso, avendo scelto come nome
“SalveMondo”, l’applicazione avrà il nome di file SalveMondo.exe.

Figura 2.1 – Creazione di un nuovo progetto con Dev-C++.

Figura 2.2 – La finestra per l’impostazione dei parametri del
progetto.
Cliccando sul bottone “Ok” vi verrà chiesto si salvare il file di
progetto con il nome “SalveMondo.dev”. Prima di confermare tale
scelta è di assoluta importanza scegliere una cartella specifica per il
progetto in fase di creazione. Vi consiglio quindi caldamente di
crearne una con lo stesso nome del progetto. Sottolineo come sia di

estrema necessità creare una cartella separata per ogni singolo
progetto al fine di evitare che file di differenti progetti vadano a
sovrascriversi gli uni con gli altri se presenti nella stessa cartella.
Dopo la conferma del salvataggio del file di progetto l’ambiente
dovrebbe presentarsi come mostrato in Figura 2.3.

Figura 2.3 – L’ambiente di sviluppo dopo la conferma del nome del
file di progetto.
Come è possibile notare osservando la Figura 2.3, è l’ambiente
stesso a provvedere al nostro posto alla predisposizione dello
scheletro del programma impostandoci un file di codice come quello
che vi riporto di seguito.
#include <stdio.h>
#include <stdlib.h>
/* run this program using the console pauser or add your own
getch, system(“pause”) or input loop */
int main(int argc, char *argv[]) {
return 0;
}

Come si può vedere, l’ambiente predispone direttamente gli “include”
indispensabili e, in questo caso, suggerisce anche l’uso della
chiamata di sistema “PAUSE”. L’intestazione della funzione main,
con i due parametri argc e argv al momento può essere ignorata
(chiarirò il loro scopo più avanti). È possibile lasciare il main inalterato
così come proposto oppure scrivere più semplicemente solo:
main()

Ma attenzione: di main c’è né uno solo!

L’importanza di fare una pausa
I nostri programmi vengono eseguiti all’interno di una finestra (detta
console). Normalmente questi programmi, una volta mandati in
esecuzione, eseguiranno il loro compito e alla fine termineranno
facendo chiudere la finestra all’interno della quale vengono eseguiti.
Per evitare che il programma si chiuda senza darci il tempo di
osservare l’output da esso prodotto dobbiamo costringerlo a
effettuare una pausa. Per far ciò possiamo utilizzare un comando
che pone il programma in pausa e attende la pressione di un tasto
qualsiasi per continuare. In ambiente DOS tale comando è “pause”.
Ciò dovrebbe aver chiarito il senso dell’istruzione:
system("PAUSE");

di cui viene suggerito l’uso nel commento presente subito dopo la
sezione degli include. dal nostro ambiente di sviluppo.

NOTA

In realtà, quando si effettuano delle prove del codice, tale istruzione è
indispensabile solo nel caso di utilizzo della vecchia versione Bloodshed.
Infatti, nel caso della versione Orwell, l’esecuzione all’interno di tale
ambiente avviene sfruttando il console pauser, ovvero una shell che
prevede automaticamente il blocco momentaneo del programma alla fine
dell’esecuzione di tutte le istruzioni presenti.
Infine vi faccio notare l’istruzione return 0. Si tratta del modo con cui il
programma, terminando, comunica il suo stato a chi lo ha chiamato (ad
esempio un altro eseguibile o un particolare file di tipo batch).

Per convenzione, return 0 significa qualcosa del tipo “tutto è andato
bene”. Volendo segnalare specifici stati di errore con il quale si
potrebbe chiudere il programma potremmo usare degli interi (1, 2 e
così via). Il tutto è demandato al programmatore.
Ma ora, bando alle ciance; per completare il tutto non ci resta che
aggiungere la nostra istruzione printf per la stampa della stringa
“Salve, mondo” ottenendo quanto segue:
#include <stdio.h>
#include <stdlib.h>
int main(int argc, char *argv[])
{
printf("salve, mondo");

system("PAUSE");
return 0;
}

Da notare come, nel codice appena presentato, ho eliminato il
commento proposto in automatico da Orwell Dev-C++. Ho, inoltre,
spostato l’apertura della parentesi graffa su di una linea separata
proponendo così un differente stile di formattazione del codice.
Finalmente ci siamo: non ci resta che compilare il nostro primo
applicativo. Per farlo agiamo sul menu Esegui e quindi sulla voce
Compila (Figura 2.4).
Una volta cliccato sulla voce di menu in questione l’ambiente ci
chiederà di salvare, con nome main.c, il file corrente. Questa
richiesta potrebbe lasciare perplessi i meno esperti i quali
ricorderanno di aver già effettuato in precedenza un salvataggio di
un file. Ma attenzione: il file salvato in precedenza era il file di
progetto, ovvero il file che contiene le informazioni generali sul
progetto stesso. Il file che l’ambiente ci chiede invece di salvare in
questa fase è il vero e proprio file di codice sorgente; tale file ha
estensione .c. Inoltre, per comodità di gestione, conviene
confermarne il nome main.c, contenendo tale file proprio la funzione
main.

Figura 2.4 – La compilazione del progetto.
A questo punto dovrebbe essere ancora più chiaro il motivo per cui
vi chiedevo di realizzare una specifica cartella per ogni specifico
progetto: differenti file main.c potrebbero sovrascriversi gli uni con gli
altri se differenti progetti dovessero utilizzare e condividere la stessa
cartella.
Se tutto sarà andato per il verso giusto l’ambiente mostrerà un log di

compilazione in tutto simile a quella che vi presento nella Figura 2.5.
Da tale messaggio si evince come lo status sia quello di completato,
con numeri di errori e warnings pari a zero.

Figura 2.5 – La conferma dell’avvenuta compilazione.
È forse utile qualche parola su tali elementi. Per errore si intende
una situazione talmente grave da impedire la compilazione del
nostro programma. Il caso più classico è la mancanza del simbolo
punto e virgola richiesto per terminare un’istruzione.
Un warning, invece, è “semplicemente” un avvertimento: il sistema
ci segnala una situazione che teoricamente potrebbe causare
qualche malfunzionamento o comportamento anomalo. Tuttavia ciò
non impedisce la compilazione e la relativa creazione del file
eseguibile.
Ma se avete fatto le cose per bene dovreste avere sul vostro hard
disk, nella cartella scelta per il progetto, il file eseguibile con il nostro
primo programma. Per essere il più chiaro possibile vi mostro nella
Figura 2.6 l’intero insieme di file prodotti durante questa prima breve
sessione di lavoro.

Figura 2.6 – Il contenuto della cartella relativa al nostro primo
programma.
All’interno della cartella riconoscerete innanzitutto il file main.c.
Tale file, come già detto, non è altro che un semplice file di testo

contenente il nostro codice sorgente. Per averne la prova, se proprio
non vi fidate, potete utilizzare il semplice Blocco note di Windows
che mostrerà che non stavo mentendo. Ne avete prova nella Figura
2.7.

Figura 2.7 – Il contenuto del file main.c mostrato nel Blocco note.
Sempre nella stessa cartella troviamo, ovviamente, il file di progetto
SalveMondo.dev. Tale file è anch’esso di testo puro e contiene le
informazioni di base del nostro progetto in una modalità classica
usata dai file .ini di Windows (Figura 2.8).

Figura 2.8 – Il contenuto del file di progetto mostrato nel Blocco
note.
Ma sicuramente il file più importante è quello eseguibile, il nostro
primo vero e proprio programma: SalveMondo.exe.
Per lanciare il nostro programma sarà allora sufficiente fare un
doppio clic sul file in questione all’interno della nostra cartella

ottenendo l’esecuzione del programma stesso, così come mostrato
in Figura 2.9.

Figura 2.9 – Il programma “SalveMondo” in esecuzione all’interno
della console DOS.
Non è niente di eccezionale, ma è sempre preferibile partire dalle
cose semplici. Una volta afferrati i meccanismi di base sarà possibile
realizzare programmi man mano più complessi senza eccessive
difficoltà.
Incidentalmente faccio ancora notare, se mai ce ne fosse ancora la
necessità, che la dicitura “premere un tasto per continuare . . .” è il
risultato dell’istruzione system("PAUSE"), che impedisce alla finestra
DOS di chiudersi lasciandoci la possibilità di visualizzare l’output del
nostro programma.
C’è da dire che, durante lo sviluppo del codice, lanciare
l’applicazione dall’interno della cartella non è molto pratico. Infatti, di
norma la codifica delle istruzioni procede per raffinamenti successivi
che vanno verificati con una compilazione e la successiva
esecuzione. Per agevolare tale fase di testing l’ambiente di sviluppo
mette a disposizione il comando Compila & Esegui presente nel
menu Esegui (Figura 2.10).

Figura 2.10 – La voce di menu Compila & Esegui.
Tale comando provvede a compilare il progetto e a lanciare in
automatico l’esecuzione del file appena compilato. Il tutto con un
notevole risparmio di tempo.
Per completare la panoramica delle attività svolte dall’ambiente di
sviluppo non ci rimane che analizzare gli altri due file presenti nella
cartella del progetto: Makefile.win e main.o.
Il primo, Makefile.win, è il cosiddetto makefile, ovvero un file di
testo, una parte del quale è visibile in Figura 2.11, che contiene le
disposizioni e le opzioni che il compilatore, richiamato dall’ambiente
di sviluppo, deve eseguire per convertire il nostro codice sorgente in
codice macchina e quindi in un file eseguibile.

Figura 2.11 – Il contenuto del file Makefile.win.
Qualche parola, infine, sul file main.o. Tale file risulta essere il
prodotto intermedio tra il file sorgente e l’eseguibile finale. Esso
prende di norma il nome di file oggetto. Si tratta di un file binario
che per poter diventare file eseguibile a tutti gli effetti deve ancora
passare attraverso una fase nota con il nome di linking. Tale fase,
realizzata da un componente noto appunto come linker, consente di
collegare al file oggetto eventuali funzioni di cui dovesse
necessitare. Solo alla fine di tale fase verrà prodotto il file eseguibile
finale.

Salutiamo il mondo da Code::Blocks
Nel precedente capitolo vi ho proposto una carrellata di ambienti di
sviluppo. Credo sia importante poter scegliere gli strumenti software
che più si adattano alle nostre esigenze e, perché no, ai nostri
peculiari gusti personali. È in questa ottica che vi fornisco una veloce
panoramica relativa all’uso dell’ambiente di sviluppo Code::Blocks,
anch’esso gratuito.
L’ultima
versione
disponibile
la
trovate
all’indirizzo:
www.codeblocks.org. A tal proposito può far sorridere quanto
riportato nelle FAQ (Frequently Asked Questions), ovvero le
domande più frequenti relative allo specifico argomento sul sito in
questione:
Domanda: Quando verrà rilasciata la prossima versione stabile di
Code::Blocks?
Risposta: Quando essa sarà pronta.
Domanda: Ma quando sarà pronta?
Risposta: Quando essa verrà rilasciata.
Si capisce il tono informale e scherzoso degli autori. Più volte mi
vedrete ribadire ed evidenziare questo senso di leggerezza e
divertimento con il quale gli informatici trattano il mondo della
programmazione e più in generale dell’informatica. Più saprete
vivere con questo spirito il contesto dello sviluppo software e più
semplice e soddisfacente sarà la vostra vita “digitale”.
Uno degli aspetti interessanti di Code::Blocks è la sua disponibilità
su più piattaforme: Windows, Mac e Linux. Per il download dovete
ovviamente fare riferimento alla cosiddetta binary release. Si tratta
della versione binaria da installare. Le altre versioni si riferiscono
invece al “source code”, ovvero al codice sorgente. Sempre in
relazione alla versione binaria, ne esiste una di dimensioni più
leggere che contiene il solo IDE senza il compilatore. Potrebbe
invece convenire, per semplicità di installazione, scaricare quella
comprensiva di compilatore. È sempre importante leggere con
attenzione le varie note proposte sui vari siti sui quali ci troviamo a
ricercare e scaricare materiale. Tali siti e i loro contenuti possono

infatti variare con una certa frequenza. Nel caso doveste avere
problemi di traduzione dall’inglese potrete sempre utilizzare i vari
servizi di traduzione presenti su Internet.
Una volta scaricato, installato e lanciato l’ambiente, siete pronti per
creare il vostro primo “Salve mondo” con questo nuovo strumento di
sviluppo. Per creare un nuovo progetto selezionate la voce New Project all’interno del menu File (Figura 2.12). In effetti, il supporto
per le lingue diverse dall’inglese di Code::Blocks non è quello di
Dev-C++. In ogni caso ci si deve abituare a usare ambienti in lingua
inglese e anche a trovare documentazione in tale lingua. La
percentuale di sviluppatori che usano l’italiano è ovviamente minima
rispetto alla quasi totalità che usa l’inglese come lingua principale
per lo scambio di informazioni. In buona sostanza vi sto esortando,
nel caso ne aveste bisogno, ad affiancare alla lettura del manuale
che avete dinanzi anche un corso di lingua inglese.

Figura 2.12 – La voce di menu per la creazione di un nuovo progetto
con Code::Blocks.
A questo punto dovreste, come già visto nel caso di Dev-C++,
selezionare come tipo di progetto “Console application” (Figura
2.13).
Procedendo con il wizard, ovvero la procedura guidata, potrete
selezionare il linguaggio scelto, nel nostro caso il C piuttosto che il
C++, che vedremo invece più avanti durante il nostro viaggio.
La finestra di dialogo successiva (Figura 2.14) consente la scelta del
nome del progetto e la relativa cartella nella quale saranno salvati i

file della nostra applicazione.
Vi faccio notare come nel caso di Code::Blocks sarebbe possibile
scegliere un nome di file differente per il titolo del progetto rispetto al
nome del file usato per salvare le informazioni sul progetto stesso.
Infine, viene visualizzata la finestra nella quale potremmo
selezionare uno specifico compilatore e dare specifiche indicazioni
per le versioni debug e versioni release del progetto (Figura 2.15).

Figura 2.13 – La scelta del progetto di tipo console con Code::Blocks.

Figura 2.14 – La finestra di dialogo per l’indicazione del nome del
progetto.

Figura 2.15 – La finestra di dialogo finale per la creazione del
progetto con Code::Blocks.

Vale la pena di spendere qualche parola a proposito di tali versioni.
Come vedremo in dettaglio più avanti, per poter debuggare, ovvero
effettuare il debug e quindi eliminare errori dal nostro codice, è
necessario che l’ambiente inserisca nel file eseguibile una serie di
informazioni addizionali che ci consentano appunto tali operazioni.
Tale file prende il nome di versione di debug.
Ovviamente si tratta di un file più grande del necessario rispetto a
quello che dovrà essere l’eseguibile finale. Tale file, infatti, una volta
testato e compilato non avrà alcuna necessità di contenere
informazioni addizionali di debug. Anzi, oltre alla questione della
dimensione la presenza di tali informazioni rappresenta un rischio
per la sicurezza dell’eseguibile stesso che potrebbe essere più
facilmente decompilato, ovvero potrebbe essere più facile capirne il
funzionamento interno da parte di malintenzionati che potrebbero
modificarlo per scopi diversi da quelli per i quali è stato creato. Per
fare un esempio, una possibile protezione posta al suo interno
potrebbe essere più facilmente rimossa in caso di presenza di
informazioni di debug.
E dunque, una volta confermate tutte le scelte effettuate durante la
procedura guidata, l’ambiente mostrerà a video un modello, noto
come template, così come visto per Dev-C++ con le istruzioni
minimali necessarie per poter compilare il progetto (Figura 2.16).

Figura 2.16 – Code::Blocks mostra il template predefinito per un
nuovo progetto.
Le istruzioni, che riporto di seguito, sono in effetti del tutto simili a
quanto già visto per Dev-C++ e quindi per esse non spenderò più di
tanto altre parole.
#include <stdio.h>
#include <stdlib.h>
int main()
{
printf("Hello world!\n");
return 0;
}

Una cosa da notare è il fatto che, nel caso di Code::Blocks, è
l’ambiente stesso a predisporre per noi l’istruzione che ci consente di
salutare il mondo. Per quanto riguarda la compilazione del nostro
eseguibile, troverete tale funzionalità con il nome di Build, all’interno
dell’omonimo menu. Per quanto riguarda invece la funzionalità
Compila & Esegui di Dev-C++ ne troverete una analoga sempre
all’interno dello stesso menu con il nome Build and run.

3
Le variabili e il mondo esterno
Chiunque abbia perso la nozione del

tempo mentre usava un computer
conosce la propensione a sognare,
il bisogno di realizzare i propri sogni e
la tendenza a saltare i pasti.
Tim Berners-Lee
Uno degli aspetti basilari del software è la sua capacità di adattarsi a
risolvere determinati problemi indipendentemente dai dati specifici a
essi legati. Mi spiego: un programma che serve per ordinare un
insieme di numeri interi deve poter funzionare su qualsiasi sequenza
di numeri interi forniti in input e non solo su una sequenza specifica.
Il concetto cardine alla base di questa considerazione è quello di
variabile.
Una variabile può essere immaginata come una scatola che rechi
un’etichetta con un nome che ne indichi il possibile contenuto. In tale
scatola potremo andare a inserire tutti gli oggetti del tipo specifico

per cui la scatola stessa è stata costruita. Immaginiamo, ad
esempio, delle scatole con la scritta “luci di natale”; in tali scatole
andremo a riporre tutte le lucine che utilizziamo per i nostri addobbi
natalizi (ma sicuramente non i pastori del presepe, per i quali
avremo una scatola separata con appropriata etichetta).

Figura 3.1 – Una rappresentazione per il concetto di variabile.
Nel caso di programmi per computer le tipologie di scatole servono a
contenere dati come numeri, singoli caratteri, insiemi di caratteri e
altri oggetti similari.
Prima di poter utilizzare una variabile è buona norma dichiararne il
nome e la relativa tipologia. In realtà, nel caso del linguaggio C,
questa più che essere una prassi consigliata è un obbligo assoluto:
ogni variabile deve essere esplicitamente e preventivamente
dichiarata in una forma come la seguente:
int x;

dove int specifica il tipo della variabile (in questo caso un numero
intero) e x il nome della variabile stessa. Tale fase e la relativa
istruzione prendono il nome di dichiarazione della variabile.
Il seguente semplice esempio illustra come dichiarare una variabile
all’interno di un programma.
#include <stdio.h>
#include <stdlib.h>
int main(int argc, char *argv[])
{
int x;
x = 3;
system("PAUSE");

return 0;
}

La prima istruzione all’interno del main serve a dichiarare la variabile
x, la seconda assegna alla variabile x il valore 3.
Ovviamente un tale programma non ha nessun senso, in quanto non
è previsto alcun tipo di output da parte del programma stesso.
Vediamo allora come porre rimedio a questa situazione facendo sì
che il nostro codice stampi il valore della variabile x.
#include <stdio.h>
#include <stdlib.h>
int main(int argc, char *argv[])
{
int x;
x = 3;
printf("Il valore della variabile e': %d", x);
system("PAUSE");
return 0;
}

Nella Figura 3.2 vi mostro il risultato dell’esecuzione del codice
appena visto.

Figura 3.2 – La stampa del valore della variabile.
La novità sostanziale di questo pezzo di codice è il nuovo uso che
facciamo della funzione printf. Nel capitolo precedente avevamo
visto come utilizzare la funzione printf per stampare una stringa
costante (il nostro “Salve, mondo”). In questo caso abbiamo la
necessità di inserire nella stampa anche il valore della variabile.
L’errore più comune commesso da chi tenta di stampare una
variabile per la prima volta è di utilizzare un’istruzione come la
seguente:

printf("Il valore della variabile e': x"); /* ERRATO */

A scanso di equivoci ho posto un commento dopo l’istruzione per
segnalare che si tratta di un uso scorretto della printf. Infatti, il
risultato di una simile istruzione sarebbe quello di stampare il nome
della variabile e NON il suo contenuto. Per farlo dobbiamo invece
posizionare, all’interno della stringa che vogliamo stampare, una
speciale combinazione di caratteri che faccia capire al sistema che
quello che stiamo indicando non è un semplice carattere ma un sorta
di segnaposto. Tale segnaposto rappresenta quindi la posizione
nella quale il compilatore andrà a sostituire il valore della variabile
indicata nella seconda parte della funzione printf. Come visto tale
segnaposto è dato dai simboli %d.

Figura 3.3 – L’uso del segnaposto %d per la stampa del valore di
una variabile.
In realtà il vero carattere speciale del nostro segnaposto è il simbolo
di percentuale %, mentre il simbolo ‘d’ che segue serve a indicare che
ciò che vogliamo stampare è un intero. Più avanti vi mostrerò come
cambia il segnaposto in caso di stampa di valori differenti dagli interi
come, ad esempio, nel caso di numeri con la virgola oppure di
caratteri generici.

NOTA Se fate bene attenzione al contenuto della printf scoprirete
che nella frase “Il valore della variabile e’:” la voce verbale
e’ (terza persona singolare del verbo essere) non è un
singolo carattere ma viene scritta combinando la lettera “e”
seguita da un apostrofo. Il motivo è dato dal fatto che il
simbolo “è” rappresenta un carattere speciale che darebbe
un risultato non corretto in fase di stampa come potete
osservare nella Figura 3.4.

Figura 3.4 – L’errata visualizzazione del carattere “è” (ovvero la “e”
accentata).

Andiamo a capo
Come potete notare dall’output della finestra console, la
visualizzazione della stringa con la stampa del valore della nostra
variabile di esempio si accoda all’output della funzione
system("PAUSE"); che visualizza il messaggio “Premere un tasto per
continuare . . .”.
Il motivo è dato dal fatto che la funzione printf non inserisce
automaticamente nel suo output il carattere di ritorno a capo; questo
deve, invece, essere esplicitamente inserito con una specifica
sequenza di caratteri speciali: \n. Tale sequenza è realizzata
attraverso il simbolo noto come backslash, ovvero la barra
rovesciata e la lettera n. Tale lettera ha appunto il significato di
newline, ovvero “nuova linea”. Di seguito vi presento un esempio di
come deve essere modificata l’istruzione printf e poi chiarisco i
dettagli:
printf("Il valore della variabile e': %d\n", x);

Come potete osservare all’interno della stringa da stampare, e più
precisamente nel punto in cui vogliamo forzare un ritorno a capo su
di una nuova linea, inseriamo la sequenza “\n”.
L’effetto, mostrato nella Figura 3.5, sarebbe lo stesso se
utilizzassimo la sequenza “\n” in una differente printf:
printf("Il valore della variabile e': %d", x);
printf("\n");

Figura 3.5 – L’effetto dell’uso della sequenza “\n” per forzare il
ritorno a capo.

NOTA

Tale sequenza, che prende il nome di “sequenza di controllo” o più spesso
di “sequenza di escape”, utilizzata per il cosiddetto newline, non è la sola
possibile. Infatti, ad esempio, la sequenza "\t" serve per inserire un
carattere di tabulazione oppure "\a" per forzare un piccolo effetto di avviso
sonoro.

Input e output di base
Ok, qualche paletto fondamentale lo abbiamo posto. Tuttavia, non ci
vuole un genio della programmazione per capire che il precedente
programma non ha alcun senso o utilità pratica in quanto non
prevede la gestione dell’input.
Vi propongo quindi, con il seguente programma, un uso un po’ più
realistico di una variabile presentandovi in questo modo la funzione
scanf, che rappresenta uno dei modi predefiniti di gestire l’input con il
linguaggio C. Richiediamo allora all’utente del nostro programma la
digitazione di un numero, associamo il numero digitato ad una
variabile di tipo intero, stampando successivamente la variabile
stessa (o meglio, il suo contenuto).
#include <stdio.h>
#include <stdlib.h>
int main(int argc, char *argv[])
{
int x;
scanf("%d", &x);
printf("Il numero digitato e': %d \n", x);
system("PAUSE");
return 0;
}

Subito dopo il main dichiariamo la variabile di nome x specificando
che è di tipo intero. L’istruzione scanf preleva da tastiera ciò che
digitiamo e cerca di considerarlo come numero intero (attraverso la
simbologia "%d") e lo associa a x (utilizzando il simbolo &).
Infine, l’istruzione printf combina in una stringa finale il risultato
voluto.
Come potete osservare non c’è niente di particolarmente complesso
se non il fare attenzione alla giusta sintassi della funzione scanf.
Tuttavia, colgo l’occasione per mostrarvi un aspetto cruciale di quello
che va sotto il nome di interfaccia user friendly (letteralmente
interfaccia amichevole con l’utente) invitandovi a osservare la Figura

3.6:

Figura 3.6 – L’interfaccia scarsamente “amichevole” di un
programma.
Il nostro programma, quando parte, subito dopo la dichiarazione
della variabile x, passa all’esecuzione dell’istruzione scanf. Tale
istruzione visualizza a video un trattino lampeggiante che rimane in
attesa del nostro input. Nel momento in cui inseriamo un numero
qualsiasi, e lo confermiamo con il tasto “Invio”, la scanf si “completa”
assegnando a x il valore inserito mentre la printf successiva
provvede a stampare tale valore. Si intuisce come un ipotetico
utente del nostro programma possa rimanere quantomeno perplesso
all’avvio della nostra applicazione: trovarsi di fronte una finestra con
un trattino lampeggiante senza una minima indicazione di quanto
richiesto può lasciare interdetti molti utenti. Se poi ci aggiungiamo il
fatto che molti dei nostri utenti potrebbero essere, più che degli
utenti, dei veri e propri “utonti”, ovvero “utenti tonti”, potete
immaginare il risultato che potremmo ottenere.
Il senso di tutto ciò è che dobbiamo rendere i nostri programmi nella
maniera più esplicita possibile rispetto a ciò che essi richiedono agli
utenti, fornendo sempre un’interfaccia che sia la più chiara e
comunicativa possibile. Nello specifico facciamo quindi una
piccolissima modifica al nostro codice aggiungendo, prima della
scanf, una istruzione printf con la quale richiediamo all’utente di
inserire un certo valore numerico.
printf("Inserisci un numero: ");
scanf("%d", &x);

Il risultato finale sarà ciò che vi mostro nella Figura 3.7.

Figura 3.7 – L’interfaccia maggiormente user friendly del nostro
programma.

Tipologie di variabili
Nel linguaggio C, oltre al semplice tipo int, esistono diversi tipi di
variabili fondamentali:

• char un carattere;
• short intero piccolo;
• int intero standard;
• long intero grande;
• float numero in virgola mobile in singola
precisione;
• double numero in virgola mobile in doppia
precisione.
È possibile “qualificare” ulteriormente questi tipi di dati utilizzando
l’attributo unsigned come ad esempio: unsigned char, unsigned short,
unsigned long. In questo modo gli elementi gestiti verranno considerati
senza segno con l’ovvia conseguenza di poter gestire numeri positivi
più grandi.
Da notare come la grandezza dei numeri esprimibili con i vari tipi di
variabili dipenda dalla specifica architettura hardware e software
utilizzata.
Per conoscere con esattezza quanti byte vengono riservati per la
rappresentazione della specifica variabile su di una specifica
architettura hardware è possibile utilizzare la parola chiave del C
definita come sizeof. Tale operatore è applicabile sia al tipo della
variabile sia alla variabile specifica.

Figura 3.8 – L’uso dell’istruzione sizeof consente di determinare lo
spazio occupato da uno specifico tipo di variabile.
A titolo di esempio vi mostro come sia possibile capire quanti byte
vengano utilizzati per un intero:
int x;
printf("Dimensione intero: %d byte\n", sizeof(int));
printf("Dimensione variabile x: %d byte\n", sizeof(x));

Le due printf produrranno ovviamente, come mostrato in Figura 3.8,
lo stesso risultato essendo la prima applicata al tipo di variabile int e
la seconda alla specifica variabile x appunto di tipo intero.
Per ottenere una panoramica generale sull’occupazione di memoria
da parte delle varie tipologie di variabili potete fare riferimento alle
seguenti istruzioni:
printf("Dimensione char: %d byte\n", sizeof(char));
printf("Dimensione short: %d byte\n", sizeof(short));
printf("Dimensione int: %d byte\n", sizeof(int));
printf("Dimensione long: %d byte\n", sizeof(long));
printf("Dimensione float: %d byte\n", sizeof(float));
printf("Dimensione double: %d byte\n", sizeof(double));

che produrranno qualcosa di simile a quanto mostrato in Figura 3.9.

Figura 3.9 – L’occupazione di spazio di memoria dei vari tipi di
variabili.

Anche l’occhio vuole la sua parte
Sicuramente il codice appena scritto raggiunge lo scopo di
visualizzare l’occupazione di memoria dei vari tipi di variabili.
Tuttavia, osservando con un mimino di attenzione la Figura 3.9
potrete notare come l’output appare disordinato e ripetitivo. La
definizione di disordinato nasce dal fatto che i numeri che esprimono
l’occupazione in byte dei vari tipi di variabili non sono incolonnati
mentre la definizione di ripetitivo scaturisce dal fatto che la parola
“Dimensione”, così come la parola “byte”, vengono inutilmente
ripetute per ogni singola riga.
Una possibile soluzione per ottimizzare il risultato visivo in output
può essere data dal seguente nuovo codice:
#include <stdio.h>
#include <stdlib.h>
int main(int argc, char *argv[])
{
printf(" - Le variabili del C: occupazione di memoria in
byte - \n\n");
printf("char:\t%d\n", sizeof(char));
printf("short:\t%d\n", sizeof(short));
printf("int:\t%d \n", sizeof(int));
printf("long:\t%d \n", sizeof(long));
printf("float:\t%d \n", sizeof(float));
printf("double:\t%d \n", sizeof(double));
printf("\n");
system("PAUSE");
return 0;
}

Tale codice produrrà l’output mostrato nella Figura 3.10.

Figura 3.10 – Una versione migliorata del programma relativo
all’occupazione di memoria delle variabili.
Come potrete facilmente osservare, la prima variazione rispetto alla
versione precedente riguarda l’utilizzo di una sorta di titolo con tanto
di doppio “\n” per lasciare un po’ di spazio tra il titolo stesso e le
colonne dei risultati. Inoltre, nell’output delle colonne ho utilizzato la
sequenza di escape “\t” che inserisce, piuttosto che un semplice
spazio, un carattere di tabulazione. Ciò consente un elegante
allineamento dei valori numerici. Infine, un’ulteriore sequenza di
escape “\n” consente di inserire una riga vuota prima del messaggio
generato dal comando “PAUSE”.

I nomi delle variabili
I nomi delle variabili devono sottostare ad alcune restrizioni, semplici
ma assolutamente da rispettare. I nomi possono essere costituiti da
lettere e numeri ma il primo carattere deve essere sempre una
lettera.
Non è consentito utilizzare spazi all’interno di un nome di variabile
ma è possibile, per maggiore chiarezza e leggibilità, utilizzare il
simbolo di sottolineatura _ per unire più parole. Tale simbolo è più
noto con il termine inglese di underscore.
Da notare che si fa differenza tra lettere minuscole e maiuscole, per
cui x e X sono due variabili diverse. È consuetudine utilizzare le
lettere minuscole per i nomi delle variabili mentre si utilizzano le
maiuscole per le costanti di cui parliamo qui di seguito.

Le costanti
Non tutto nel mondo che ci circonda varia sistematicamente. Vi sono
determinate situazioni fisse e invariabili all’interno di un dato
contesto. Questi valori sono detti costanti e devono essere inseriti,
quando richiesto, all’interno dei nostri programmi.
Tuttavia, un numero è normalmente qualcosa di abbastanza “freddo”
e non sempre esplicativo. Noi umani siamo più abituati a gestire dei
nomi, ai quali più facilmente riusciamo ad associare un concetto.
È possibile, in C, associare a un dato valore costante una sigla di
nostra scelta nel modo seguente:
#define PI_GRECO 3.14

Con questa direttiva, da inserire prima del main, avremo la possibilità
di utilizzare la sigla PI_GRECO al posto del numero 3,14 ovunque venga
richiesto. Otteniamo in questo modo una maggiore leggibilità del
programma, da parte nostra o di qualunque altro programmatore che
si troverà alle prese con il nostro codice. Incidentalmente vi faccio
notare come, in un numero, la virgola venga sostituita dal punto.
Come detto, la prassi vuole che i nomi delle costanti siano scritti in
maiuscolo.
Ritengo utile proporvi in questo contesto un semplice e classico
esempio di uso di costanti relativo al calcolo dell’area di un cerchio,
che utilizza appunto il numero pi greco. Il programma si limiterà a
chiedere all’utente il valore del raggio e calcolerà la relativa area con
la nota formula per la quale si moltiplica il raggio per se stesso e
quindi per pi greco. Vi anticipo, rispetto a quanto vi proporrò più
avanti, che la moltiplicazione si ottiene utilizzando il simbolo *,
ovvero l’asterisco, più comunemente chiamato star come in lingua
inglese.
#define PI_GRECO 3.14
#include <stdio.h>
#include <stdlib.h>
int main(int argc, char *argv[])
{

float raggio;
float area;
printf("Inserisci il raggio del cerchio: ");
scanf ("%f", &raggio);
area=raggio*raggio*PI_GRECO;
printf("L'area del cerchio e': %f\n", area);
system("PAUSE");
return 0;
}

Vale forse la pena spendere qualche parola sull’istruzione:
area=raggio*raggio*PI_GRECO;

Si tratta, come vedremo più in dettaglio nel prossimo capitolo, di una
classica istruzione di assegnazione di valori a una variabile. La
macchina esegue innanzitutto l’operazione di moltiplicazione posta
sulla destra del segno di uguale e, solo successivamente a tale
calcolo, assegna il risultato alla variabile area presente sulla sinistra.
Un altro aspetto utile relativo all’uso delle costanti può in alcuni casi
essere quello di avere una maggiore possibilità di intervenire per una
eventuale modifica del valore della costante. Infatti, non saremo
costretti a cercare tutte le occorrenze all’interno del programma; sarà
sufficiente una modifica nella direttiva #define una volta per tutte.
Un’altra possibilità nella gestione delle costanti è l’uso del
modificatore const:
const int x = 3;

La parola chiave const istruisce il compilatore a rendere la variabile in
questione non modificabile durante l’esecuzione del programma,
mettendoci al riparo da eventuali possibili errori di programmazione
costringendola di fatto a essere una costante.

Quando le costanti sono tante: le
enumerazioni
È abbastanza comune che all’interno di un certo problema da gestire
si presentino al nostro esame diversi elementi che risultano essere
di tipo costante e organizzati in gruppi. Qualche classico esempio
che potrà risultare chiarificatore può essere l’elenco dei giorni della
settimana (lunedì, martedì ecc.), l’elenco dei mesi dell’anno
(gennaio, febbraio ecc.) o i semi di un mazzo di carte (cuori, quadri,
fiori, picche), solo per citarne alcuni.
Per poter gestire tali gruppi di elementi in maniera agevole
potremmo pensare di creare una costante per ogni singolo
elemento. Tuttavia, tale scelta presenta diversi aspetti critici. Forse il
primo e più banale è dato dalla scelta del nome e dall’attenzione che
dobbiamo porre su come tale nome viene scritto e quindi
successivamente utilizzato nelle varie operazioni svolte dal nostro
programma. Nel caso dei giorni della settimana, lunedì potremmo
scriverlo come Lunedì oppure lunedi, solo per fare un esempio.
La scelta più complessa potrebbe però riguardare il tipo di dati. Un
non esperto potrebbe pensare di trattare tale elemento come un
nome. Scopriremo più avanti quanto è complesso gestire i nomi
intesi come sequenze di caratteri. Tali elementi vengono definiti
stringhe e comportano diversi tipi di problemi. Un’alternativa può
essere associare all’elemento costante un numero intero (1, 2, 3 e
così via). Potremmo ad esempio pensare di associare, nel caso dei
giorni della settimana, il valore 1 al lunedì, il valore 2 al martedì e via
dicendo. Tuttavia in questo caso dovremo sempre ricordarci che
lunedì corrisponde a 1. Se per noi, infatti, il primo giorno della
settimana è appunto il lunedì, cosa diversa avviene nel mondo
anglosassone nel quale si parte dalla domenica; ricorderete l’elenco
dei giorni in inglese: Sunday, Monday ecc. (da notare come in
inglese i giorni della settimana si scrivano con l’iniziale maiuscola,
contrariamente a quanto facciamo noi italiani).
Si capisce quindi che organizzare “manualmente” questa struttura è

comunque abbastanza artificioso. Fortunatamente il C consente di
manipolare queste situazioni con una specifica parola chiave enum.
Il nome è giustificato dal fatto che tali situazioni prendono il nome di
enumerazioni. Tale termine è un semplice sinonimo di elencazione.
Con le enumerazioni possiamo associare un nome costante a un
numero intero in maniera semplice e diretta.
Supponiamo di voler gestire l’elenco dei mesi dell’anno. La
dichiarazione dell’enumerazione potrebbe essere la seguente:
enum mesi {gennaio = 1, febbraio, marzo, aprile, maggio,
giugno, luglio, agosto, settembre, ottobre, novembre,
dicembre};

oppure, analogamente, ma in maniera decisamente più chiara:
enum mesi
{
gennaio = 1,
febbraio,
marzo,
aprile,
maggio,
giugno,
luglio,
agosto,
settembre,
ottobre,
novembre,
dicembre
};

Vediamo di chiarirne il significato. L’enumerazione assegnerà al
nome gennaio il valore 1. In automatico il nome seguente febbraio
assumerà il valore 2, marzo il 3 e così via fino a dicembre che prenderà il
valore 12.
Il valore 1 al primo elemento è stato forzato da noi con una specifica
assegnazione. Nel caso in cui non avessi proceduto
all’assegnazione, il valore predefinito sarebbe stato zero con la
conseguenza che dicembre si sarebbe visto assegnare il valore 11.
In ogni caso, possiamo assegnare ai vari singoli elementi specifici
valori di nostro interesse. Gli elementi non valorizzati prendono
come valore quello dell’elemento precedente incrementato di una
unità.

A dimostrazione del fatto che abbiamo comunque a che fare con
valori di tipo intero, considerate il seguente pezzo di codice relativo
all’enumerazione prima proposta:
printf("L'ultimo mese dell'anno e': %d\n", dicembre);

L’invito che vi rivolgo, convinto e pressante, è sempre quello di
sperimentare personalmente i pezzi di codice proposti, modificandoli
per soddisfare i vari dubbi di utilizzo che inevitabilmente si
presentano utilizzando un dato costrutto.

4
Operiamo sui dati
Un buon programmatore è in grado
di superare un linguaggio scarso o
un sistema operativo confuso, ma
anche

un

grande

programmazione

ambiente

di

salverà

un

non

cattivo programmatore.
Brian Wilson Kernighan

Aiuto: quanti problemi!
Anche il più sprovveduto e distratto dei lettori potrà capire che un
programma che legge un numero e lo restituisce così come lo
abbiamo inserito vuole rappresentare un esempio introduttivo e non
sicuramente un qualcosa di minimamente utile sul piano pratico. Un
pappagallo in carne e penne sarebbe certamente più simpatico.
Preparare una torta, individuare il numero massimo tra un insieme di
numeri dati, aprire una porta. I problemi che si possono immaginare
sono innumerevoli. In generale, un problema è una situazione da
risolvere per ottenere un certo risultato. Una gustosa torta, la
soluzione a un quesito matematico, uscire da un ambiente chiuso.
In realtà, anche se in un primo momento può risultare strano, solo
una piccola parte dell’universo dei problemi risulta essere risolvibile.
In ogni caso la risoluzione di un problema prevede innanzitutto la
comprensione dei dati iniziali a disposizione (input) e ciò che si
vuole ottenere (output). Tale fase va sotto il nome di analisi. A
questo punto, sfruttando l’analisi, è necessario individuare i passi,
vale a dire le operazioni che bisogna compiere (procedura) per
ottenere il risultato atteso (Figura 4.1).

Figura 4.1 – I passi necessari per la risoluzione di un problema.
La procedura da seguire per risolvere un dato problema è in
informatica universalmente nota con il termine di algoritmo.

Algoritmo, la parola magica
Il termine algoritmo deriva dal soprannome di un matematico arabo
del nono secolo, Al-Khuwarizmi. Tuttavia tale termine ha cominciato
a interessare matematici e filosofi solo quando, grazie al progresso
tecnologico, si iniziava ad intravedere la possibilità che delle
macchine reali potessero risolvere in modo automatico determinati
tipi di problemi.
Un’eccellente definizione di algoritmo la ritroviamo in “The Art of
Computer Programming” di Donald E. Knuth.

Figura 4.2 – Donald E. Knuth.
Knuth è un matematico e il suo lavoro “The Art of Computer
Programming” è sicuramente uno dei testi più completi relativi alle
metodologie di soluzione dei problemi tramite calcolatore. Per Knuth,
e noi siamo d’accordo con lui, un algoritmo è un insieme di regole
(ovvero istruzioni) aventi le seguenti cinque caratteristiche:

• deve essere finito e concludersi dopo un numero
finito di operazioni;

• deve essere definito e preciso (le istruzioni non
devono essere ambigue);
• se ci sono dati in ingresso (input), il campo di
applicazione deve essere precisato;
• deve fornire almeno un risultato (dato in uscita –
output);
• deve essere eseguibile: tutte le operazioni devono
poter essere eseguite correttamente, e in tempo
finito, da un essere umano che utilizza mezzi
manuali.
Come scoprirete nel prosieguo del nostro viaggio nel mondo della
programmazione, individuare un algoritmo adatto a risolvere un dato
problema non è, in generale, cosa semplice. La questione non
riguarda solo l’efficacia, cioè il fatto che l’algoritmo risolva il
problema in esame. Un altro elemento critico è infatti l’efficienza,
ovvero quanto costa, in termini di risorse, l’esecuzione del nostro
algoritmo.
Vi faccio un esempio banale ed estremo: immaginate un programma
per le previsioni meteo per il giorno successivo che impiega due
giorni per “tirar fuori” i risultati. Banalmente si tratta di un algoritmo
inefficiente anche se potenzialmente efficace.
Oltre al tempo, un aspetto critico è anche quello relativo alle risorse
hardware della macchina come, ad esempio, una possibile
eccessiva occupazione di memoria.
Per rendere palese la complessità, ma se volete anche la bizzarria,
del mondo che ci accingiamo ad affrontare, può essere utile proporvi
uno dei più “strani” algoritmi presenti nel mondo della
programmazione: l’algoritmo dello struzzo.
Come l’animale citato nel nome di tale algoritmo, il programmatore
nasconde la testa sotto la sabbia nel momento critico in cui si
presenta un grosso problema. In realtà ciò che si fa è di ritenere
eccessivamente costoso realizzare una soluzione al possibile
problema, presupponendo che questo si possa verificare con una
frequenza così rara da non giustificare i costi per scrivere e gestire

una procedura che risolva il problema in questione.

I diagrammi di flusso
Una volta definito il problema e individuato un possibile algoritmo di
risoluzione si dovrebbe procedere con la scrittura, nota come
codifica, delle istruzioni dell’algoritmo in un certo linguaggio di
programmazione.
Vi faccio notare che parlo di un “possibile” algoritmo in quanto è
ovvio che, in generale, possono esistere modi differenti e quindi
differenti algoritmi per risolvere un dato problema.
In ogni caso tra queste due fasi potrebbe esserne inserita un’altra di
una certa importanza. Tale fase consiste nell’utilizzare una
rappresentazione simbolica per rendere schematico e semplice da
interpretare l’algoritmo stesso: il diagramma di flusso, in inglese
flow-chart (noto anche come diagramma a blocchi).

Figura 4.3 – Il diagramma di flusso come metodo per schematizzare
un algoritmo.
Come detto, un diagramma di flusso è una rappresentazione
simbolica dei passi da eseguire. I principali simboli utilizzati sono:

• un rettangolo per le istruzioni;
• una freccia che indica l’ordine delle istruzioni da
eseguire;
• un rombo per una condizione di test.

Figura 4.4 – I principali simboli di un diagramma di flusso

Il modo migliore per imparare a usare nuovi contesti è come sempre
quello di verificarli attraverso degli esempi. Quello che vi propongo,
relativamente ai simboli appena presentati, è tanto banale e
quotidiano da poter sembrare estraneo al mondo dell’informatica. Si
tratta di un diagramma di flusso per il problema dell’apertura di una
porta. Al contrario, ritengo questo esempio tanto semplice quanto
efficace.
Come si può notare dalla Figura 4.5, le varie azioni che devono
essere realizzate vengono poste in sequenza all’interno del simbolo
del rettangolo.
Nel momento in cui bisogna verificare una condizione (nel caso in
questione se la porta si apre o meno) si inserisce il simbolo del
rombo, riportando al suo interno la condizione posta. Da notare
come il rombo sottintenda esso stesso una domanda: ciò spiega il
motivo per cui la condizione viene scritta senza il punto interrogativo.
In generale, un diagramma di flusso viene letto dall’alto verso il
basso seguendo il senso delle frecce. Per aiutare la leggibilità del
diagramma a volte si fa uso di due ulteriori simboli: una ellissi per
indicare l’inizio e la fine del diagramma e un parallelogramma per
denotare un momento di ingresso o di uscita di dati (Figura 4.6).
Vi propongo ora un esempio più attinente al contesto informatico per
dare maggiore concretezza a quanto sto esponendo:

• Problema: dati due numeri in input, individuarne il
maggiore.
• Algoritmo:
–leggiamo il primo numero;
–leggiamo il secondo numero;
–confrontiamo i due numeri letti e stampiamo il
maggiore.

Figura 4.5 – Diagramma di flusso relativo all’algoritmo per il
problema dell’apertura di una porta.

Figura 4.6 – Le ellissi con l’etichetta “inizio” e “fine” e il simbolo per
le operazioni di I/O.
Come si evince dal diagramma della Figura 4.7, quando si passa
dall’algoritmo al diagramma stesso si cerca di essere il più formali
possibile. Infatti, mentre nell’algoritmo ci riferiamo alla lettura
generica di due numeri, nel diagramma di flusso utilizziamo al loro

posto delle lettere (nell’esempio, la lettera ‘A’ per il primo numero e
la lettera ‘B’ per il secondo). Questo, ovviamente, semplifica
enormemente la definizione della procedura.
Per il resto lo schema dovrebbe risultare autoesplicativo. Le lettere
utilizzate all’interno delle procedure sono le variabili: esse
rappresentano, infatti, dei contenitori per delle quantità (in questo
caso dei dati numerici) non note a priori (appunto variabili).

Figura 4.7 – Diagramma di flusso per l’individuazione del maggiore
tra due numeri.
Aggiungo come dettaglio che in relazione al parallelogramma che
indica in un solo passo la lettura di A e di B, “LEGGI A, B”, avremmo
potuto indicare due simboli separati, uno per la lettura di A, “LEGGI
A”, e un altro per la lettura di B, “LEGGI B”. Tuttavia, almeno in
questo caso si sarebbe trattato di un’operazione del tutto superflua.
Dovrebbe essere chiaro che ai vari simboli presenti nel diagramma
di flusso corrisponderanno delle specifiche istruzioni reali nello
specifico linguaggio di programmazione scelto. A puro titolo di
esempio vi mostro l’equivalenza tra il parallelogramma relativo alla
lettura dei due numeri del precedente esempio e le corrispondenti
istruzioni reali che dovrebbero essere comunicate alla macchina per
implementare la funzionalità di input richiesta.

Le istruzioni scanf della Figura 4.8 dovrebbero risultarvi già familiari
per quanto vi ho presentato nel precedente capitolo. La cosa che mi
preme qui sottolineare è che, in linea generale, un diagramma di
flusso è indipendente dal linguaggio reale che verrà adoperato per
l’effettiva implementazione del programma. Al posto delle istruzioni
in “C” (ovvero in linguaggio C) potremmo pensare a un linguaggio
diverso (ad esempio il Pascal), ma in ogni caso il diagramma, che è
di tipo generico, sarebbe rimasto sostanzialmente immutato.

Figura 4.8 – Corrispondenza tra diagrammi di flusso e istruzioni
reali.

Operatori aritmetici
Come appena visto, un’applicazione informatica deve normalmente
effettuare delle elaborazioni sui dati di un certo problema. Sarà
capitato a molti di vedere in abitazioni in costruzione dei calcoli fatti a
mano dai muratori sui controtelai delle porte o sugli intonaci ancora
da imbiancare: somme e moltiplicazioni relative a quantità di
cemento o numero di mattonelle da impiegare nei lavori. Ebbene,
quel tipo di operazioni fatte a mano devono essere tradotte in
linguaggio informatico per far sì che si possa realizzare un
programma capace di essere utilizzato più volte, evitando di
imbrattare interi edifici con schizzi a matita. In buona sostanza
stiamo parlando di operatori sui dati.
Tra i tipi di operatori, i più semplici e intuitivi sono sicuramente gli
operatori aritmetici.
+
*
/
%

somma
sottrazione
moltiplicazione
divisione
modulo (resto intero di una divisione)

Vale a dire le classiche operazioni alle quali siamo abituati sin dalle
elementari. Per utilizzarli è sufficiente inserirli all’interno delle nostre
espressioni potendo combinare insieme variabili e costanti.
Un esempio chiarirà di cosa sto parlando. Supponiamo di voler
scrivere un programma che calcoli e stampi il numero precedente e il
numero successivo di un intero letto da tastiera. Di seguito vi
presento una possibile soluzione.
/* calcola il precedente e successivo di un numero inserito da
tastiera */
#include <stdio.h>
#include <stdlib.h>
int main(int argc, char *argv[])
{
int x, prec, succ;
printf("Dammi un numero: ");

scanf("%d", &x);
prec=x-1;
printf("Il numero precedente e': %d\n", prec);
succ=x+1;
printf("Il numero successivo e': %d\n", succ);
system("PAUSE");
return 0;
}

Il tutto dovrebbe essere abbastanza intuitivo. Dichiariamo
innanzitutto tre variabili; la x per il numero input, prec e succ
rispettivamente per il precedente e il successivo.
Dopo aver preso in input con una scanf il numero letto da tastiera,
assegnandolo alla variabile x, calcoliamo il precedente di x. Da
notare il fatto che espressioni del tipo:
prec = i-1;

sono delle istruzioni a tutti gli effetti e richiedono quindi il classico
punto e virgola finale. Un’operazione del tutto analoga viene
realizzata per il calcolo del successivo.
Sebbene il tutto funzioni senza problemi, ci tengo a sottolineare
come il pezzo di codice proposto possa essere migliorato in
relazione alla sua “eleganza”. A ben guardare un occhio attento
noterà che c’è un po’ di confusione riguardo alle operazioni di
calcolo vero e proprio e a quelle di output. È invece buona norma
cercare di tenere sempre separate le sezioni di input, di calcolo e di
output dei dati. Nel contesto specifico sarà sufficiente riorganizzare il
codice come vi mostro di seguito. Mi sono aiutato con dei commenti
per chiarire meglio l’organizzazione del sorgente stesso.
#include <stdio.h>
#include <stdlib.h>
int main(int argc, char *argv[])
{
//sezione dichiarativa
int x, prec, succ;
//sezione input
printf("Dammi un numero: ");
scanf("%d", &x);

//elaborazione
prec=x-1;
succ=x+1;
//sezione output
printf("Il numero precedente e': %d\n", prec);
printf("Il numero successivo e': %d\n", succ);
system("PAUSE");
return 0;
}

printf, la stampa e le specifiche di
formattazione
Voglio farvi notare incidentalmente una particolarità sulla
formattazione dei dati, ovvero lo stile di presentazione con il quale
sono organizzati in stampa i dati stessi. Oltre al qualificatore %d per la
stampa dei numeri interi, con la printf esistono qualificatori per la
stampa di caratteri, così come di altri tipi numerici.
Ve li presento brevemente di seguito in quanto ci serviranno nel
prosieguo:
%d – intero decimale
%i – intero decimale
%ld – decimale di tipo long
%f – numero reale
%c – carattere singolo
%s – stringa di caratteri
%o – numero ottale
%x – numero esadecimale
%u – numero senza segno
%e – formato scientifico
%% – per visualizzare il carattere % stesso

Oltre alla lettera che indica la tipologia del dato da stampare, è
possibile utilizzare, prima di quest’ultima, altre opzioni di formato al
fine di predisporre l’output in maniera più formale e professionale
(allineamento, numero di cifre decimali ecc.).

• Il simbolo – (meno) indica che si richiede un
allineamento a sinistra.
• Il simbolo + indica che il numero dovrà essere
stampato sempre con il segno.
• 0 (zero) indica, per rappresentazioni numeriche,
che dovranno essere inseriti tanti zeri quanti ne

serviranno per raggiungere l’ampiezza del campo
richiesta.
• Un numero specifica l’ampiezza minima del campo
(per le stringhe il massimo numero di caratteri da
scrivere).
• Un punto per separare l’ampiezza del campo dal
grado di precisione.
Vi propongo allora il seguente esempio minimale:
#include <stdio.h>
#include <stdlib.h>
int main(int argc, char *argv[])
{
const float pi = 3.14159;
printf("%10.2f\n", pi);
printf("%010.2f\n", pi);
printf("%+10.2f\n", pi);
system("PAUSE");
return 0;
}

Il codice stamperà, così come mostrato in Figura 4.9, un numero con
la virgola con due cifre decimali occupando dieci posizioni. Per la
prima stampa gli spazi iniziali vengono lasciati vuoti. Per la seconda
stampa vengono invece visualizzati degli zeri a causa dell’utilizzo
nelle direttive di formattazione che vedono uno zero prima del
numero 10 che indica quante posizioni si dovranno utilizzare in fase
di stampa. La terza visualizzazione forza la presenza del segno del
numero stampato, in questo caso il + (più).

Figura 4.9 – Il risultato dell’utilizzo di alcuni parametri di
formattazione.
In ogni caso provare le varie combinazioni è il miglior modo per
capire il funzionamento delle varie opzioni e per farmi risparmiare
spazio per argomenti più importanti.

Il casting delle variabili
Il nome del paragrafo potrebbe suggerire un qualcosa di collegato al
mondo dello spettacolo: niente di più lontano dalla verità. Il casting,
nel contesto informatico, non ha assolutamente a che fare con la
selezione di un certo sviluppatore come attore in un qualche film ma
piuttosto con l’attribuzione del tipo di dati più adatto a una data
variabile per una determinata circostanza implementativa. Il motivo
per cui ve lo presento subito dopo gli operatori aritmetici è dato dal
fatto che talvolta l’esecuzione di certe operazioni tra tipi di dati può
dare risultati del tutto inaspettati.
Ma andiamo con ordine ponendoci questa domanda: cosa accade
quando assegno a una variabile il valore di un’altra variabile
appartenente a un tipo di dati diverso? Mi spiego meglio; quando
scrivo qualcosa come:
x = y;

se x e y sono dello stesso tipo, semplicemente il valore di y viene
copiato in x. Tuttavia, se x è, ad esempio, di tipo intero e y di tipo
float, inevitabilmente la parte frazionaria di y verrà persa
nell’assegnazione del valore a x, al limite con un avvertimento (un
warning) da parte del compilatore.
Ad esempio, il seguente codice:
#include <stdio.h>
#include <stdlib.h>
int main(int argc, char *argv[])
{
int x;
float y = 5.5;
x = y;
printf("Il valore di x e': %d\n", x );
printf("Il valore di y e': %.2f\n", y );
system("PAUSE");
return 0;
}

produrrà come output:
Il valore di x e': 5

Il valore di y e': 5.50

In generale, infatti, le uniche conversioni che non generano problemi
sono quelle che consentono di ampliare la dimensione di una
variabile. Ad esempio, nessun problema, ovviamente, nel caso
contrario a quello appena visto in cui assegniamo un intero a una
variabile float, ottenendo come risultato che la variabile float avrà
come parte intera il valore intero del numero assegnato e come
parte frazionaria il valore zero.
Il valore di x e': 6
Il valore di y e': 6.00

Questi tipi di conversione vengono detti conversioni implicite in
quanto realizzate automaticamente dal compilatore. In altri casi,
però, è necessario “forzare” un tipo di variabile a essere diversa da
quella che risulterebbe in maniera naturale: si parla allora di
conversione esplicita. Tali conversioni vengono definite in modo
gergale cast oppure casting, e usando a volte espressioni come
“castare una variabile”.
Vi propongo allora una situazione tipica:
#include <stdio.h>
#include <stdlib.h>
int main(int argc, char *argv[])
{
int x=7, y=2;
float d;
d = x/y;
printf("Il valore di d e': %.2f\n", d );
system("PAUSE");
return 0;
}

poiché d è stata dichiarata come float ci si aspetterebbe che essa
assumesse come risultato della divisione tra x e y il valore 3,5.
Sbagliato! L’operazione di divisione tra due interi viene appunto
intesa come un fatto “privato” tra interi che dà come risultato un
valore intero (nel nostro caso il valore 3) che solo successivamente
viene assegnato alla variabile con la virgola d. Tale problema è
comunissimo e si verifica, ad esempio, nel caso in cui si deve

calcolare la media di un dato numero di elementi interi per i quali,
nonostante si prevede una variabile di tipo float, si otterrà comunque
un numero intero.
Per risolvere la situazione si usa allora il casting di cui vi dicevo con
la seguente sintassi:
(tipo_dati) espressione

Ad esempio, nel nostro caso sarà sufficiente scrivere:
d = (float)x/y;

dove x vale 7 e y vale 2, per ottenere in stampa il valore desiderato e
atteso di 3,5. In altre parole si antepone all’operazione da svolgersi il
tipo di dati, racchiuso tra parentesi tonde, verso il quale si vuole che
avvenga il casting. Si parla in questo caso di conversione esplicita.

Operatori di incremento e decremento
Spessissimo si verifica la necessità di operare degli incrementi o
decrementi su determinate variabili. Ovviamente, il modo più intuitivo
per incrementare una variabile è scrivere qualcosa del tipo
seguente:
#include <stdio.h>
#include <stdlib.h>
int main(int argc, char *argv[])
{
int x;
x = 3;
x = x + 1;
printf("Il valore di x e': %d\n", x);
system("PAUSE");
return 0;
}

dove abbiamo banalmente incrementato di una unità la variabile x
scrivendo x = x + 1. Il codice ovviamente stamperà 4 come valore per
la x. Infatti, così come ci aspettiamo, viene prima eseguito il lato
destro dell’espressione e successivamente il risultato ottenuto viene
assegnato alla variabile posta sulla sinistra.
Tuttavia il C mette a disposizione per tali necessità degli appositi
operatori:
++ incrementa di uno
–- decrementa di uno

In pratica x++; corrisponde in sostanza a x = x + 1; mentre x--;
corrisponde a x = x - 1; dove, trattandosi di istruzioni singole, ho
posto il punto e virgola in coda a esse.
Tali operatori prendono il nome rispettivamente di operatori di
incremento e operatori di decremento.
La particolarità di questi operatori consiste nel fatto che essi
possono essere utilizzati in due modalità differenti: come suffissi
(dopo la variabile, ad esempio x++) e come prefissi (prima della

variabile, ad esempio ++x).
Entrambe le modalità hanno l’effetto di incrementare (o
decrementare nel caso di --) la variabile. Tuttavia l’uso prefisso
incrementa la variabile prima di utilizzarla in eventuali assegnazioni
mentre l’uso suffisso effettua l’incremento dopo l’utilizzo.
Data la bizzarria del comportamento descritto vi conviene dare
un’occhiata all’esempio che vi propongo di seguito.

Uso suffisso

Uso prefisso

int x, n;
int x, n;
x = 9;
x = 9;
n = 9;
n = 9;
x = n++;
x = ++n;
printf("Il valore di n e': %d\n", n); printf("Il valore di n e': %d\n", n);
printf("Il valore di x e': %d\n", x); printf("Il valore di x e': %d\n", x);
Il risultato sarà che:
Il risultato sarà che:
n vale 10
n vale 10
x vale 9
x vale 10

Vi faccio notare che in ogni caso, prefisso o suffisso, l’incremento o
decremento sarà sempre lo stesso. Ciò che cambia è relativo ai
contesti in cui vi sia un utilizzo, vale a dire un’assegnazione di tali
incrementi a determinate variabili.
Ancora più esemplificativo può risultare il seguente pezzo di codice:
...
int x = 0;
printf("Il valore di x e': %d", x++);
...

Forse con un po’ di stupore si potrà notare che il valore di x in output
sarà zero. Infatti, nell’esecuzione della printf si avrà innanzitutto la
sostituzione, nella posizione del qualificatore %d, del valore di x e solo
successivamente la variabile x subirà l’incremento di una unità a
opera dell’operatore ++.

Operatori relazionali
Un secondo gruppo di operatori è rappresentato dagli operatori
relazionali. Si tratta di operatori in grado di mettere a confronto
determinati elementi.
Dobbiamo stabilire se un numero è più grande di un altro? Se due
quantità sono uguali tra loro oppure differenti? Se il mio conto in
banca è andato in rosso oppure posso permettermi una vacanza in
un’isola tropicale?
Ebbene, in tutte queste situazioni avrò bisogno dei seguenti
operatori:
>
>=
<
<=
==
!=

maggiore
maggiore o uguale
minore
minore o uguale
uguaglianza
diverso da

Vi ho già presentato, anche se abbastanza sommariamente, il
possibile campo di utilizzo di questi operatori in relazione all’uso del
rombo nei diagrammi di flusso per gestire una condizione all’interno
del nostro algoritmo.
Nel caso del diagramma di flusso possiamo essere non formali, e
anche semplicemente indicativi, scrivendo ad esempio qualcosa del
tipo “A ≠ B” oppure addirittura “A diverso da B” per testare la
condizione, per verificare se A e B sono effettivamente diversi. Al
contrario, durante la stesura di un programma C dobbiamo essere
molto precisi e formali usando nel giusto modo gli operatori
presentati nel precedente elenco.
Nello specifico, per indicare la condizione “diverso da” dobbiamo
usare la particolare simbologia che prevede l’uso del punto
esclamativo seguito dal simbolo di uguale. Inoltre, se non ci sono
dubbi sugli operatori “<” e “>” (rispettivamente minore e maggiore)
bisogna porre attenzione al fatto che gli operatori per “minore o
uguale” e “maggiore o uguale” sono scritti utilizzando due differenti
specifici simboli: il simbolo “<” oppure “>” seguito dal simbolo di

uguale “=”.
Un cenno lo merita la particolarità della simbologia per testare
l’uguaglianza di due elementi. Infatti, è da notare come vengano
utilizzati due simboli di uguale uno dopo l’altro. Ciò viene realizzato
per differenziare il test di uguaglianza dalla semplice associazione di
un elemento a un altro realizzato con l’utilizzo di un solo simbolo di
uguaglianza.
A scanso di equivoci, per meglio chiarire tale situazione, vado a
precisare che un’istruzione del tipo x = y serve per dare alla variabile
x il valore contenuto in y mentre scrivere x==y serve per verificare se x
e y sono uguali.
Ok, so che scalpitate per un po’ di esempi pratici e reali ma dovete
pazientare fino al successivo Capitolo 6 dove, presentando i costrutti
messi a disposizione dal C per gestire la selezione, potremo
verificare i dettagli di funzionamento degli operatori relazionali.

Operatori logici
Nei ragionamenti fatti a proposito degli operatori relazionali c’è una
considerazione implicita che forse vale la pena di esaminare in
maggior dettaglio: quando usiamo un operatore di tale tipo ci
chiediamo se una certa condizione sia vera oppure sia falsa. Ci
chiediamo, ad esempio, se x > y e tale situazione può essere solo
vera oppure falsa.
Questo tipo di considerazioni prendono le mosse dagli studi del
matematico inglese George Boole, che sviluppò un nuovo tipo di
logica associando dei simboli a determinate parti del discorso inteso
come vero e proprio ragionamento.

Figura 4.10 – George Boole (1815-1864).
Tali parti di un ragionamento sono delle proposizioni che devono
risultare, come detto, delle affermazioni. Queste affermazioni
prendono il nome di enunciati.
Ho già sottolineato come un enunciato sia un’affermazione che può
risultare vera oppure falsa ma non può essere contemporaneamente
sia vera che falsa. Ad esempio, una proposizione del tipo: “imparate
l’informatica!” non è un enunciato (ma piuttosto un saggio invito) . La
richiesta che un enunciato possa essere o vero o falso rientra in
quello che è definito come principio del terzo escluso (ovvero
esistono due sole possibilità).
“piove”, “quella matita è di colore rosso ”, “la macchina è in moto”,

“10 è un numero pari”, “Benevento è una città” ecc. sono tutti esempi
di enunciati.
Boole introdusse inoltre degli operatori per mettere in relazione due
affermazioni che si combinano insieme. Egli costruì quindi una vera
e propria algebra, denominata in suo onore algebra booleana (o
algebra di Boole).
In questa algebra si definiscono tre operatori booleani (detti anche
operatori logici) fondamentali:
NOT
AND
OR

Negazione Logica
Prodotto Logico
Somma Logica (detto anche "or inclusivo")

Il NOT, noto anche complemento, corrisponde alla negazione di un
enunciato.
Il prodotto logico AND corrisponde nel linguaggio “umano” alla
congiunzione “e”. Consideriamo a titolo di esempio la situazione per
la quale associamo agli enunciati A e B i seguenti significati:
A = "il tempo è bello"
B = "ho tempo libero"

Ebbene, applicando l’AND possiamo immaginare una situazione per
cui uniamo con la congiunzione “e” i due enunciati in qualcosa del
tipo:
A AND B = "il tempo è bello" e "ho tempo libero".

L’AND crea una nuova proposizione, detta proposizione composta,
realizzata unendo le due proposizioni semplici. Per rendere
sensata questa operazione dovremmo associare un significato alla
proposizione risultante. Ad esempio potremmo dire che la
congiunzione corrisponde all’azione di uscire di casa. In questo
contesto l’AND farà sì che usciremo di casa (risultato vero) se e solo
se entrambe le proposizioni risulteranno vere (il tempo è bello e ho
anche tempo libero). Per cui, cercando di formalizzare l’espressione,
essa sarebbe qualcosa del tipo:
se (tempo_bello AND tempo_libero) allora esco_di_casa

Un altro esempio tra i più classici e intuitivi può essere il seguente:
se (piove AND ho_paura_di_bagnarmi) allora uso_ombrello

Già che ci sono, a proposito di formalismo, vi illustro un modo per
rendere più chiaro il meccanismo dell’AND logico. Il comportamento
di tale operatore viene definito attraverso l’uso della seguente
tabella, nota come tavola di verità:

A B AND
0

0

0

0

1

0

1

0

0

1

1

1

Nella tabella, così come vuole la consuetudine, utilizzo lo zero per
indicare la condizione di falso e il valore 1 per la condizione di verità.
In altri contesti potreste trovare la lettera ‘F’ e la lettera ‘V’ ad
indicare, rispettivamente, lo stesso significato. Da una veloce analisi
della tabella potete osservare come solo l’ultima riga, che prevede
due numeri uno per A e B, genera un 1 per l’AND; ovvero se e solo
se entrambe le condizioni, A e B, sono vere il risultato sarà vero.
L’OR logico prevede invece il verificarsi di almeno una delle
situazioni coinvolte per dare come risultato il valore vero. La sua
tavola di verità è dunque la seguente:

A B OR
0

0

0

0

1

1

1

0

1

1

1

1

Rifacendoci all’esempio della possibilità di uscire di casa,
applichiamo in questo caso l’operatore logico OR. Nel linguaggio
standard questa situazione può essere espressa come:
A OR B = "il tempo è bello" oppure "ho tempo libero"

In questo contesto posso uscire di casa (valore vero della
proposizione composta) nel momento in cui una qualsiasi delle
condizioni risulta vera. Per la serie: anche se non ho tempo libero
(B=0) ma il tempo è bello (A=1) esco comunque di casa.

Un ulteriore, semplice e intuitivo esempio di una situazione in cui si
può applicare l’OR logico è il seguente:
se (semaforo_verde OR semaforo_giallo) allora
attraversa_incrocio

con l’ovvio suggerimento, non espresso, di fare comunque
attenzione.
In questa breve carrellata vi ho mostrato il funzionamento generale
dei principali operatori logici; di seguito vi presento come tali
operatori vengono definiti nello specifico contesto del linguaggio C:
!
&&
||

NOT logico
AND logico
OR logico

Per un loro utilizzo pratico ci diamo appuntamento al Capitolo 6 dove
introduco i costrutti di programmazione del C per realizzare la
selezione dell’esecuzione di un blocco di istruzioni piuttosto che un
altro.

5
Il debugging di un’applicazione
Attenti

ai

bachi

nel

codice

precedente; ho solo provato che è

corretto, non l’ho collaudato.
Donald Knuth
Nei precedenti capitoli vi ho mostrato come gestire i dati del nostro
problema utilizzando le variabili. Si è visto come i valori associati alle
variabili stesse varino durante l’esecuzione del programma. Fin
quando il risultato ottenuto è quello che ci aspettavamo, è chiaro che
non ci sono problemi o discussioni di sorta. C’è tuttavia una cattiva
notizia: è abbastanza comune che l’output di un certo pezzo di
codice, almeno nei primi momenti di sviluppo, sia differente rispetto
alle nostre aspettative. In buona sostanza il codice presenta uno o
più bug.
Di norma un bug, anche noto come errore di programmazione, è
dato da una o più istruzioni che producono un risultato diverso da
quello atteso.
L’uso del termine bug per identificare problemi nel comportamento di
dispositivi meccanici o elettronici è molto antico e sembra risalire
addirittura a Thomas Edison. Probabilmente, tuttavia, la situazione

più nota rispetto al termine bug è quella che si riferisce a un
malfunzionamento di un enorme computer della seconda metà degli
Anni 40 (il Mark II), messo KO da un insetto (una falena) rimasto
bloccato nella circuiteria del calcolatore. Non a caso bug, in inglese,
significa insetto.

Figura 5.1 – Una tipica rappresentazione grafica per un bug.
Non sempre è semplice individuare un bug, ovvero fare debugging
o debug, in un’applicazione e a volte può risultare un’operazione
abbastanza frustrante.
Il modo più “brutale” per fare il debug di un programma può essere
quello di aggiungere, a mano, delle istruzioni di stampa del valore di
determinate variabili in modo da individuare la causa di un certo
comportamento non corretto.
Ovviamente un tale approccio non è il massimo della vita in quanto
può dare una visione parziale delle attività svolte dal programma e,
quindi, risultare non del tutto efficace. Tuttavia, in talune circostanze
può essere un metodo accettabile. Di norma, comunque, gli ambienti
di sviluppo mettono a nostra disposizione dei veri e propri
debugger: moduli aggiuntivi che ci consentono di eseguire, in
ambiente controllato, istruzione dopo istruzione l’intero programma
mostrando il valore assunto dalle specifiche variabili man mano che
le istruzioni vengono eseguite.
Di seguito vi mostro come utilizzare il debugger di Dev-C++.

Fare debug con Dev-C++
Supponiamo di voler “debuggare” un programma che faccia una
banale somma tra i valori di due variabili. Di seguito vi riporto il
codice che utilizzeremo in questa sessione di prova:
#include <stdio.h>
#include <stdlib.h>
int main(int argc, char *argv[])
{
int x;
int y;
int s;
x = 3;
y = 4;
s = x + y;
printf ("La somma e': %d\n", s);
system("PAUSE");
return 0;
}

Il codice prevede l’uso di tre differenti variabili. Le prime due, x e y,
vengono inizializzate con due interi qualsiasi (nell’esempio,
rispettivamente, i valori 3 e 4) e rappresentano gli addendi della
somma. La terza variabile, che chiamiamo s, conterrà il valore di tale
somma.
Per eseguire il debug dobbiamo come prima cosa inserire un
cosiddetto breakpoint, ovvero un punto di interruzione nel
programma. Il motivo è dato dal fatto che dobbiamo bloccare il
programma su di una specifica istruzione per poi eseguire
lentamente, passo dopo passo, le singole istruzioni per verificare
come vari il valore delle variabili coinvolte. Per farlo possiamo
posizionare il cursore sull’istruzione dalla quale partire con la nostra
analisi e agire sul menu Esegui, scegliendo la voce Attiva/Disattiva
Breakpoint come mostrato in Figura 5.2.

Figura 5.2 – La voce di menu per impostare un breakpoint.
La riga in questione verrà immediatamente colorata in rosso per
segnalarne la specificità. In alternativa, per velocizzare
l’impostazione di un breakpoint, è possibile cliccare immediatamente
a sinistra della riga di nostro interesse, nello spazio immediatamente
esterno all’editor.

Figura 5.3 – Un breakpoint evidenziato nell’editor.
A questo punto è possibile lanciare il debug cliccando nel menu
Esegui sulla voce Debug.

Figura 5.4 – La voce di menu per avviare il debug.
L’ambiente ci informerà del fatto che l’eseguibile in questione non
contiene le informazioni di debug. Tali informazioni sono dei dati
addizionali inseriti all’interno dell’eseguibile che consentono
all’ambiente di effettuare le operazioni richieste dal debugger.

Figura 5.5 – La finestra di dialogo con la richiesta di generazione
delle versione dell’eseguibile per il debug.
Confermiamo quindi l’operazione richiesta.

ATTENZIONE Su alcune vecchie versioni Bloodshed potrebbe
succedere che, nonostante la nostra conferma, il
sistema ci segnali semplicemente che la
compilazione è stata completata ma alla fine
dell’operazione non venga iniziata la fase di

debug. Provando a rilanciare il debug ci verrebbe
nuovamente mostrata la finestra di dialogo della
Figura 5.5 e saremmo di nuovo al punto di
partenza.
Per risolvere il problema possiamo agire cliccando
sulla voce Opzioni di compilazione del menu
strumenti, che visualizzerà la finestra di dialogo
mostrata in Figura 5.6.

Figura 5.6 – La finestra di dialogo per la gestione delle opzioni di
compilazione.

In tale finestra, nella scheda Compilatore
bisognerà aggiungere l’opzione -g in entrambe le
aree di testo in relazione all’aggiunta dei comandi
per il compilatore e per il linker.
A questo punto, dovrebbe inizializzarsi l’ambiente come mostrato in
Figura 5.7.

Figura 5.7 – L’editor pronto per il debug dell’applicazione.
Una volta avviato il debug è possibile seguire il flusso di esecuzione
delle singole istruzioni. Il controllo delle operazioni di debug è
gestibile sia dal già visto menu Esegui sia dal pannello di Debug
presente nella parte bassa dell’ambiente e che vi riporto per
maggiore chiarezza di esposizione nella Figura 5.8.

Figura 5.8 – Il pannello di Debug.
Una delle voci maggiormente utilizzate è Step Succ.. Tale comando,
richiamabile anche con la scorciatoia da tastiera “F7”, consente di
passare di volta in volta alla successiva istruzione. L’istruzione in un
dato momento “sotto analisi” viene evidenziata in blu. Seguire il
flusso di esecuzione delle istruzioni è fondamentale per capire cosa
succede al programma una volta lanciato e per cercare di
correggere eventuali comportamenti indesiderati.
Tuttavia, uno degli aspetti fondamentali da tenere sotto controllo
durante il debug è, in genere, il valore assunto dalle variabili
coinvolte nel programma.

Per seguire tali cambiamenti è necessario indicare all’ambiente di
sviluppo quali variabili vogliamo osservare. Appunto di osservazioni
si parla per indicare le variabili che vogliamo seguire durante
l’esecuzione del programma. Per creare una “nuova osservazione”
di una variabile è sufficiente, una volta avviato il debug, cliccare sul
bottone Nuova Osservazione, visibile nel pannello di Figura 5.8, e
indicare il nome della variabile che vogliamo osservare. Tale
variabile, con il relativo valore assunto in quello specifico momento,
verrà visualizzata nella scheda Debug. Nella Figura 5.9, sul lato
sinistro, potete notare le variabili x, y e s sotto osservazione nella
scheda Debug.

Figura 5.9 – La scheda Debug con alcune variabili sotto
osservazione.
Vi faccio notare, incidentalmente, che è possibile porre sotto
osservazione una variabile anche agendo con il tasto destro del
mouse nella scheda appena presentata, e che vi mostro in Figura
5.10, così come agendo nel menu Debug, nel pannello di Debug in
basso, o ancora usando il tasto “F4”.

Figura 5.10 – Il menu contestuale nella scheda Debug per creare
una nuova osservazione.
Dallo stesso menu è possibile rimuovere un’osservazione alla quale
non siamo più interessati.

NOTA

In inglese il termine osservazione è watch. Potrebbe capitare che in alcuni
ambienti di sviluppo tale termine non sia tradotto essendo ormai diventato
un elemento comune del contesto dello sviluppo software.

Facciamo ora qualche considerazione più tecnica. Osservando la
Figura 5.9 potete notare che, a inizio debug, le variabili x, y e s già
presentano dei valori anche se l’esecuzione del programma è
ancora bloccata sull’istruzione
x = 3;

non ancora eseguita. Tutto ciò conferma il fatto che la semplice
dichiarazione di una variabile non assegna a essa alcun valore
specifico ma dei valori del tutto casuali. Procediamo allora a
eseguire proprio l’istruzione in cui assegneremo alla variabile x il
valore 3. Per farlo sarà sufficiente cliccare sulla voce Step Succ.. Il
risultato è mostrato nella Figura 5.11.

Figura 5.11 – I valori delle variabili dopo l’esecuzione dell’istruzione
x=3.

Ormai il procedimento dovrebbe essere chiaro. Continuando a
richiamare il comando Step Succ. è possibile eseguire e controllare
ogni singola operazione fino ad arrivare alla fine del programma.
Tale situazione finale è mostrata nella Figura 5.12, in cui è possibile
osservare come le variabili x e y abbiano assunto i valori assegnati
durante il programma e come la somma, con la variabile s, sia
assegnata nella maniera che ci aspettavamo.
Ovviamente, il programma durante il debug viene eseguito nella
finestra console, nella quale è possibile vedere l’evolversi degli
output e inserire eventuali input che vengono richiesti dal
programma. Nella Figura 5.13 vi mostro tale finestra alla fine delle
operazioni di stampa del risultato finale.

Figura 5.12 – Le variabili sotto osservazione al termine dell’ultima istruzione del
programma.

Figura 5.13 – La console con l’output del programma sotto debug.

Il debug con Code::Blocks
In questo paragrafo vi presento le operazioni principali da svolgersi
nel caso di debug di codice sorgente all’interno dell’ambiente
Code::Blocks. Credo sia comunque il caso di ribadire la scelta di
presentare due possibili ambienti di sviluppo come Dev-C++ e
Code::Blocks. Il primo è consigliabile per gli approcci iniziali alla
programmazione data la sua estrema semplicità d’uso. Il secondo è
già sufficientemente complesso da rendersi utile in contesti
maggiormente articolati e professionali. Quest’ultimo, infatti, è
l’ambiente che sicuramente vi consiglio di utilizzare più avanti in
questo viaggio, quando affronteremo problematiche inerenti il
linguaggio C++.
In ogni caso mi sento di ribadire l’indipendenza del linguaggio C così
come del C++ rispetto all’ambiente di sviluppo. Il linguaggio resta
sostanzialmente lo stesso indipendentemente dall’ambiente che
sceglierete di utilizzare. Tanto più che con lo stesso ambiente avete
comunque la possibilità di utilizzare compilatori differenti. Solo un
uso e un relativo intensivo studio pratico dei vari ambienti vi darà la
giusta visione d’insieme relativa alle problematiche di sviluppo e di
manutenzione del vostro codice.
Tornando alla questione debug, supponiamo per semplicità di riferirci
allo stesso esempio di codice utilizzato per il debug con Dev-C++.
Se avete necessità di verificare le impostazioni del contesto di debug
di Code::Blocks potete riferirvi alla voce di menu Settings Debugger.
Come prima operazione è ovviamente sempre necessario impostare
un breakpoint. Per farlo all’interno di Code::Blocks potete procedere
in vari modi. Il primo e più immediato è quello di posizionarvi con il
cursore sulla riga di codice di vostro interesse e usare il tasto F5. In
alternativa potete usare il menu contestuale visualizzato agendo con
il tasto destro del mouse e selezionare la voce Toggle breakpoint.
Ovviamente il click deve avvenire sulla riga che vogliamo diventi
breakpoint. Ancora, è possibile selezionare tale voce Toggle
breakpoint dal menu Debug. Infine è possibile cliccare con il tasto

sinistro del mouse sulla colonna sinistra dell’editor subito alla destra
dei numeri di riga. Comparirà, in ogni caso, indipendentemente dal
metodo utilizzato, un piccolo cerchietto rosso a indicare
l’impostazione del breakpoint sulla riga specifica. Per rimuoverlo è
sufficiente ripetere, su tale riga, la medesima operazione utilizzata
per impostare il breakpoint stesso con uno qualsiasi dei metodi
proposti. In Figura 5.14 vi mostro un’istantanea con il breakpoint
visualizzato nell’editor.

Figura 5.14 – Il breakpoint visualizzato nella finestra di editing di
Code::Blocks.
È ora necessario visualizzare la finestra per osservare il valore delle
variabili. Per farlo selezionate la voce di menu Debug - Debugging
windows - Watches come mostrato nella Figura 5.15.
Potete lasciare la finestra flottante, ovvero libera sullo schermo,
oppure bloccarla all’interno dell’ambiente (si parla di docking della
finestra) come mostrato nella Figura 5.16. In tale figura potete
vedere presenti tra i watches le tre principali variabili del nostro
piccolo programma di esempio: x, y e s.

Figura 5.15 – Il menu per la visualizzazione della finestra dei watches di
Code::Blocks.

Figura 5.16 – La finestra dei Watches bloccata all’interno
dell’ambiente Code::Blocks.

Per inserire una variabile in tale elenco è sufficiente posizionarsi con
il mouse su di essa e, agendo con il tasto destro, selezionare la voce
Watch ‘x’ dove x è il nome della variabile di interesse in un dato
momento.
Per rendere operativa tale possibilità è tuttavia necessario avviare le
operazioni di debug. Per farlo è possibile agire sulla voce di menu
Debug - Start / Continue oppure premere il tasto F8.
Nella stessa Figura 5.16 potete notare come il valore delle tre
variabili sia del tutto casuale. Ciò è dovuto al fatto che l’esecuzione
del debug non è ancora arrivata alle istruzioni di valorizzazione.
Infatti, dalla figura si evince, osservando il triangolino presente sulla
riga indicata con il numero 10, che l’istruzione x = 3; ancora non
viene eseguita. Il triangolino rappresenta infatti la posizione della
riga di codice che sta per essere eseguita. Per procedere con
l’esecuzione è sufficiente selezionare la voce di menu Debug - Next
line o più semplicemente digitare il tasto F7.
Man mano che si procede con l’esecuzione, sarà possibile
visualizzare il valore delle variabili sotto osservazione.

6
Istruzioni condizionali:
operiamo delle scelte
Eppure le decisioni vanno prese e
anche non prendere decisioni, in
fondo, è una decisione.
Johann Wolfgang Göethe
Nel precedente quarto capitolo ho introdotto, in maniera
fondamentalmente teorica, i principali tipi di operatori; è giunto allora
il momento di utilizzare questi operatori nel contesto reale del
linguaggio C. Sia nel caso degli operatori relazionali che nel caso di
quelli logici, ciò che in generale vogliamo definire è come
comportarci se si verifica una data situazione piuttosto che un’altra.
Per far ciò ci serviamo di apposite istruzioni, dette istruzioni
condizionali.

Il costrutto if-else
Il primo e più semplice costrutto per consentire alla macchina di
effettuare una scelta tra l’esecuzione di una sezione di codice
sorgente piuttosto che un’altra è if-else. Tale costrutto è traducibile
in italiano con l’espressione “se-altrimenti”. Esso viene utilizzato per
prendere decisioni diverse in base al verificarsi di una data
condizione. La sua struttura generale è la seguente:
if (condizione) {
istruzioni_X;
}
else {
istruzioni_Y;
}

Se l’elemento condizione, posto tra parentesi tonde dopo la parola
chiave if, risulta vero allora il sistema esegue le istruzioni poste
immediatamente dopo l’if (quelle che ho etichettato come
istruzioni_X) altrimenti, se la condizione NON è verificata, verranno
eseguite le istruzioni successive all’else (istruzioni_Y). L’apertura e la
chiusura delle parentesi graffe servono per indicare il blocco di
istruzioni da eseguire.
Faccio subito qualche considerazione di merito. Nel caso in cui
l’istruzione da eseguire fosse una sola sarebbe possibile omettere
l’uso delle parentesi graffe. Queste, infatti, hanno lo scopo di
raggruppare le istruzioni da eseguire nei due casi possibili. A rigore,
se l’istruzione è una sola non si rende necessario usare le parentesi
come fossero un contenitore. Tuttavia il mio consiglio è di usarle
sempre, anche in caso di una singola istruzione. Ciò rende più
leggibile il codice ed evita inutili possibili errori.
La seconda questione che mi piace qui sottolineare è la posizione
delle parentesi graffe all’interno del costrutto. Fondamentalmente
esistono due modi standard per posizionare tali parentesi.
Il primo modo prevede, come appena visto, la presenza delle
parentesi graffe aperte subito dopo la condizione e subito dopo
l’else. In buona sostanza sulla stessa riga di codice.

Una seconda possibilità consiste nel porre tali aperture di parentesi
graffe su di una riga separata, come vi mostro di seguito:
if (condizione)
{
istruzioni_X;
}
else
{
istruzioni_Y;
}

Ovviamente l’una o l’altra scelta non modificano nella maniera più
assoluta la funzionalità del costrutto ma sono solo due possibili e
differenti stili. Io personalmente, tra i due, preferisco e uso
sistematicamente il secondo. A voi lascio libero arbitrio. Una cosa
però la raccomando fortemente: l’uso dell’indentazione; le istruzioni
all’interno dei blocchi vanno assolutamente indentate di una
tabulazione in modo da rendere pulito e leggibile il codice.
Una terza e ultima osservazione è relativa al fatto che il blocco else è
facoltativo e quindi, nel caso in cui non fosse necessario eseguire
alcuna operazione al non verificarsi della condizione, potremmo
scrivere tranquillamente qualcosa del tipo:
if (condizione)
{
istruzioni_X;
}

A questo punto un esempio è d’obbligo. Supponiamo di voler
individuare quale tra due numeri dati in input dall’utente sia il
maggiore. Il codice potrebbe essere il seguente:
/* Determina il maggiore tra due interi, input utente */
#include <stdio.h>
#include <stdlib.h>
int main(int argc, char *argv[])
{
int a, b;
printf("Inserisci il primo numero: ");
scanf("%d", &a);
printf("Inserisci il secondo numero: ");

scanf("%d", &b);
if (a > b)
{
printf("Il primo numero e' maggiore del secondo");
}
else
{
printf("Il secondo numero e' maggiore del primo");
}
system("PAUSE");
return 0;
}

Il codice mi sembra abbastanza chiaro da risultare autoesplicativo.
Ovviamente si suppone che i due numeri in input siano differenti tra
loro, assumendo, quindi, che non ci sia possibilità che siano uguali.
Infatti, la condizione a > b all’interno dell’if è un’espressione logica
che può assumere valore vero oppure falso e dunque la presenza in
input di due numeri uguali porterebbe a un malfunzionamento del
programma.
Infatti, supponiamo che l’utente inserisca in input uno stesso numero
due volte, ad esempio il numero 3. Sia la variabile 'a' che la variabile
'b' conterebbero dunque il numero intero 3. Il test a > b ovviamente
darebbe risultato falso in quanto a non è maggiore di b (a e b sono
invece uguali). Tale situazione comporterebbe l’esecuzione del
codice dopo la clausola else con la relativa stampa a video ad
affermare il fatto che “Il secondo numero è maggiore del primo”.
Cosa ovviamente non vera nel caso che stiamo immaginando.
Per trovare una soluzione dovete per forza di cose leggere il
paragrafo seguente.

Il costrutto else if
Come al circo, procediamo man mano ad aumentare la difficoltà dei
nostri “esercizi”. Quando una condizione può dare un numero di
risultati di nostro interesse superiori a due, dobbiamo utilizzare una
variante del costrutto che prevede un’ulteriore clausola “else if”
come vi mostro di seguito:
if (espressione_1)
{
istruzioni_X;
}
else if (espressione_2)
{
istruzioni_Y;
}
else if (espressione_3)
{
istruzione_Z;
}
else
{
altre_istruzioni;
}

Come detto, il costrutto precedente serve quindi nei casi in cui le
condizioni da testare (vale a dire per le quali effettuare un test) sono
più di due. A seconda di quale espressione dia il valore vero verrà
eseguito il relativo blocco di istruzioni. Nel caso nessuna delle
espressioni dovesse risultare vera verrebbe eseguito il blocco
successivo all’else in coda al costrutto.
Un buon modo per verificare sul campo l’uso di questa variante del
costrutto è quella di risolvere il problema della individuazione del
maggiore tra due numeri, visto nel precedente paragrafo, gestendo
ora la possibilità che i due numeri possano essere uguali. Vi
propongo di seguito una possibile stesura del codice:
#include <stdio.h>
#include <stdlib.h>

int main(int argc, char *argv[])
{
int a, b;
printf("Inserisci il primo numero: ");
scanf("%d", &a);
printf("Inserisci il secondo numero: ");
scanf("%d", &b);
if (a > b)
{
printf("Il primo numero e' maggiore del secondo");
}
else if (a < b)
{
printf("Il secondo numero e' maggiore del primo");
}
else
{
printf("I due numeri sono uguali");
}
system("PAUSE");
return 0;
}

Strutture nidificate
Il costrutto if - else, come visto, serve per eseguire un blocco di
istruzioni in base al verificarsi o meno di una data condizione. La
cosa interessante, e a volte di grande utilità pratica, è che il blocco di
istruzioni da eseguirsi dopo un if oppure dopo un else può a sua
volta essere un ulteriore costrutto if - else. Si parla in questo caso di
strutture nidificate.
Vi propongo un esempio relativo a un ipotetico programma che
determina un giudizio sintetico rispetto a un voto scolastico.
#include <stdio.h>
#include <stdlib.h>
int main(int argc, char *argv[])
{
int voto;
printf ("Inserisci il tuo voto: ");
scanf("%d", &voto);
if (voto < 1 || voto > 10)
{
printf("Devi inserire un voto compreso tra 1 e 10");
}
else
{
if (voto < 6)
{
printf("Insufficiente");
}
if (voto == 6)
{
printf("Sufficiente");
}
if (voto == 7)
{
printf("Discreto");
}
if (voto == 8)
{
printf("Buono");
}

if (voto == 9)
{
printf("Ottimo");
}
if (voto == 10)
{
printf("Eccellente");
}
}
printf("\n");
system("PAUSE");
return 0;
}

Osservando con po’ di attenzione il codice potete scorgere il primo
ramo dell’if nel quale verifichiamo la validità del voto. Supponiamo
che esso debba essere compreso tra 1 e 10. Per testarne la validità
usiamo l’operatore relazionale OR logico che vi ho presentato nel
Capitolo 4. Il senso è: “SE il voto è minore di 1 OPPURE il voto è
maggiore di 10 ALLORA il voto non è valido”. L’OR logico viene
espresso con un doppio simbolo ‘|’ noto come pipe.
Osservando il ramo relativo all’else potrete notare come esso sia
“nidificato” utilizzando ulteriori costrutti di tipo if. È intuitivo che
avremmo potuto esprimere le varie condizioni di selezione
utilizzando il costrutto con l’aggiunta della clausola else if. Di seguito
vi mostro come:
...
if (voto < 1 || voto > 10)
{
printf("Devi inserire un voto compreso tra 1 e 10");
}
else
{
if (voto < 6)
{
printf("Insufficiente");
}
else if (voto == 7)
{
printf("Discreto");
}
else if (voto == 8)
{

printf("Buono");
}
else if (voto == 9)
{
printf("Ottimo");
}
else if (voto == 10)
{
printf("Eccellente");
}
}
...

Con questa seconda versione si evidenzia in maniera più forte come
la variabile voto determini in maniera diretta e univoca il relativo
giudizio. In realtà, ovviamente, le due versioni sortiscono
esattamente lo stesso risultato. Questo semplice esempio dovrebbe
farvi nuovamente riflettere su come sia importante lo stile proprio di
ciascun singolo programmatore.

Il costrutto switch
Il costrutto if - else mostra i propri limiti nel momento in cui il numero
di condizioni da verificare si avvicina o addirittura supera quello delle
dita della mia mano (ma anche della vostra, a meno che non siate
extraterrestri e stiate leggendo questo testo solo per impadronirvi
della tecnologia informatica della razza umana). Ne potete avere
prova anche semplicemente osservando l’esempio appena proposto
relativo alla valutazione. Il C mette tuttavia a nostra disposizione uno
specifico costrutto che rende tali situazioni più agevoli da gestire: lo
switch.
Il costrutto switch esamina un certo numero di possibilità ed
esegue le istruzioni corrispondenti. La sua forma generale è la
seguente:
switch (espressione)
{
case espressione-costante:
istruzioni;
case espressione-costante:
istruzioni;
default:
istruzioni;
}

Per forzare l’uscita dal costrutto switch è necessario utilizzare
un’appropriata istruzione denominata break.
Vi propongo subito come esempio la situazione appena vista relativa
alla valutazione in una nuova formulazione.
#include <stdio.h>
#include <stdlib.h>
int main(int argc, char *argv[])
{
int voto;
printf ("Inserisci il tuo voto: ");
scanf("%d", &voto);
switch(voto)
{

case 1:
case 2:
case 3:
case 4:
case 5:
printf("Insufficiente");
break;
case 6:
printf("Sufficiente");
break;
case 7:
printf("Discreto");
break;
case 8:
printf("Buono");
break;
case 9:
printf("Ottimo");
break;
case 10:
printf("Eccellente");
break;
default:
printf("Devi inserire un voto compreso tra 1 e 10");
break;
}
system("PAUSE");
return 0;
}

Il nostro switch esaminerà ovviamente il voto inserito. I primi case
sono relativi ai valori 1, 2, 3, 4, e 5. Solo dopo tale ultimo valore
troviamo la prima istruzione printf che stamperà, per uno qualsiasi di
tali valori, la dicitura “Insufficiente”.
Infatti, una volta che la macchina “entra” all’interno dello switch
rispetto a un valore specifico inizia a eseguire tutte le istruzioni che
seguono all’interno dei vari ulteriori case. All’interno di questi primi
case non sono presenti istruzioni in quanto vogliamo stampare un
solo giudizio per un qualsiasi voto inferiore a 6. Subito dopo la
stampa relativa all’insufficienza dobbiamo però inserire una clausola
break. Ciò serve, come detto, per forzare l’uscita dal nostro costrutto.
In caso contrario, provare per credere, verrebbero eseguite tutte le

altre istruzioni di stampa compromettendo l’efficacia del nostro
codice. Infine, le istruzioni relative alla clausola default, che è
facoltativa, verranno eseguite nel caso in cui nessun caso venga
soddisfatto.
A proposito della clausola default vi faccio osservare che la
successiva istruzione break non sarebbe di norma necessaria, in
quanto essa è presente alla fine dello switch che comunque non
comporterebbe l’esecuzione di altre istruzioni. Kernighan e Ritchie,
nel loro testo, consigliano comunque di porre tale istruzione break
nella sezione default, sia per un fatto puramente stilistico sia per
evitare problemi nel caso si dovessero aggiungere ulteriori sezioni
case in coda al costrutto.

7
Cicli, ovvero noi la mente e la
macchina il braccio
I

computer sono incredibilmente

veloci, accurati e stupidi. Gli uomini
sono

incredibilmente

lenti,

inaccurati e intelligenti. L’insieme
dei

due

costituisce

una

forza

incalcolabile.
Albert Einstein
Se proviamo per un attimo a guardare a quanto vi ho proposto
finora, possiamo individuare un ben preciso disegno: stiamo
istruendo la macchina a eseguire al nostro posto tutta una serie di
attività.
Siamo partiti con una serie di semplici istruzioni poste in sequenza

una dopo l’altra.
Abbiamo successivamente dotato la macchina della facoltà di
decidere se prendere una certa strada o piuttosto seguirne un’altra
in dipendenza di una data condizione (alternativa).
Rimane ancora una delle situazioni forse più frustranti per un essere
umano: ripetere, ripetere e ancora ripetere una serie di azioni tutte
uguali tra di esse (ripetizione anche detta iterazione).
Le ultime tre parole che ho scritto in grassetto: sequenza, alternativa
e ripetizione rappresentano tre elementi classici, e per certi aspetti
imprescindibili, della programmazione. Prendono il nome di
strutture di controllo e con il loro uso è possibile realizzare
pressoché qualsiasi algoritmo.
In realtà, in maniera estremamente più precisa rispetto a quanto ho
appena accennato io, questa affermazione fu realizzata da Corrado
Böhm e Giuseppe Jacopini i quali formalizzarono il seguente
importante risultato teorico a proposito di tali costrutti, proponendo il
seguente teorema:

Un qualunque algoritmo può essere descritto
unicamente attraverso le tre strutture: Sequenza,
Selezione, Iterazione.
Tale teorema, noto come teorema di Böhm-Jacopini, dai nomi dei
due informatici italiani che lo formularono, ha in effetti un’importanza
più che altro teorica. Esso fu formulato nel 1966, forse non a caso il
mio anno di nascita.
I costrutti di sequenza, selezione e iterazione, a causa della loro
importanza, vengono spesso anche definiti come i tre costrutti
fondamentali della programmazione.

Spaghetti e programmazione
strutturata
I primi linguaggi di programmazione più o meno evoluti (stiamo
parlando degli anni 60 dello scorso secolo) avevano un approccio
diverso rispetto a quelli che conosciamo oggi. L’esecuzione del
programma partiva dall’inizio del codice e proseguiva in modo
sequenziale fino alla fine, a meno che non si incontravano delle
istruzioni di salto, note come GOTO (ovvero “vai a”). Tale approccio
portava alla realizzazione di programmi difficili da gestire e talmente
ingarbugliati da meritarsi l’appellativo di “spaghetti code” e la
relativa modalità di realizzazione nota come spaghetti
programming (programmazione a spaghetti). Mi sembra superfluo
far notare come tale nome sia usato in un contesto dispregiativo e
che il paragone con gli spaghetti è motivato dal fatto che tale tipo di
pasta si dispone nel piatto in maniera assolutamente confusa,
intrecciata e ingarbugliata.
Furono i contributi di Böhm, Jacopini e anche di Edsger Dijkstra a
consentire il superamento di tale approccio e dei limiti a esso
connessi. Nasceva così la programmazione di tipo strutturato o
programmazione strutturata, in cui l’utilizzo di una specifica
struttura di controllo per la ripetizione delle istruzioni superava il
vecchio GOTO.
Veniamo allora finalmente ai dettagli della struttura di controllo
ripetizione. Essa può assumere varie forme, ognuna più o meno
adatta a specifiche circostanze. Tutte con il medesimo scopo:
ripetere una stessa sequenza di istruzioni per un certo numero di
volte.

Il ciclo for: ripetiamo contando
Nel contesto informatico, il costrutto iterazione prende il nome
generico di ciclo e il realizzare cicli viene spesso definito, in slang,
ciclare.

NOTA

Lo slang è un modo di parlare proprio di un certo contesto
culturale o sociale. Un sinonimo di slang è gergo.

Il costrutto for serve quindi per ripetere una o più istruzioni per un
numero di volte specificato. Tale numero di volte viene controllato
attraverso una variabile che prende il nome di contatore.
“Formalmente” il for ha la seguente struttura:
for (da_dove_partiamo; quando_ci_fermiamo; teniamo_il_conto)
{
istruzione_1;
istruzione_2;
...
istruzione_n;
}

Le istruzioni presenti tra parentesi graffe verranno eseguite il numero
di volte specificato dalle espressioni contenute dopo il for tra
parentesi tonde e separate dai simboli di “;” (punto e virgola).
Nel caso in cui l’istruzione da eseguire sia soltanto una, è possibile
omettere le parentesi graffe (ma è comunque buona norma
utilizzarle in ogni caso).
Facciamo subito un esempio per evitare di fare troppe premesse e
supponiamo di voler stampare a video cento volte il mio nome e
cognome (e ancora una volta dimostro il mio istinto di egocentrismo).
#include <stdio.h>
#include <stdlib.h>
int main(int argc, char *argv[])
{
int i;
for (i=1; i<=100; i++)

{
printf("Carlo Mazzone\n");
}
system("PAUSE");
return 0;
}

Il for farà in modo di eseguire per cento volte l’istruzione printf.
L’assegnazione i=1, nella prima posizione all’interno delle parentesi
tonde del for, indica il valore iniziale della variabile i che usiamo
come contatore. Nella seconda posizione, con i <= 100 andiamo a
indicare fino a quando proseguiremo con l’esecuzione del nostro
ciclo. Nella terza posizione, con i++ andiamo a incrementare a ogni
esecuzione il valore del contatore.
Tutto ciò è possibile in quanto l’esecuzione del ciclo rispetta delle
regole molto precise. Innanzitutto viene valutata la prima
espressione all’interno del for, nel nostro caso i=1. Tale valutazione
avviene una sola volta all’inizio della prima iterazione del ciclo e
non verrà più presa in considerazione durante tutta l’esecuzione del
ciclo stesso.
Successivamente, all’inizio di ogni nuova iterazione, viene
valutata la seconda espressione, nel nostro caso i<=100. Se essa
risulta essere vera (soddisfatta) vengono eseguite le istruzioni
all’interno del blocco di parentesi graffe. In caso contrario, se essa
risulta essere falsa, l’esecuzione del ciclo si interrompe passando
all’esecuzione delle istruzioni successive al blocco for.
Alla fine di ogni iterazione viene eseguita la terza espressione
presente tra parentesi tonde, nel nostro caso i++, ovvero l’incremento
di un’unità della nostra variabile contatore.
In definitiva, l’esecuzione del ciclo del nostro esempio proseguirà fin
quando la variabile i non assumerà il valore 101 (centouno)
rendendo falso il risultato dell’espressione i <= 100.

Pari o dispari?
Una cosa che credo sia importante farvi notare è che spesso il
contatore, ovvero la variabile che usiamo per contare il numero di
iterazioni, viene utilizzato anche per scopi diversi dal semplice
conteggio.

Un esempio è d’obbligo: supponiamo di voler stampare i primi
numeri pari fino a 50. Per farlo sfruttiamo l’operatore modulo ‘%’
applicato al numero 2. Vi ricordo che l’operatore modulo restituisce il
resto intero di una divisione. Nel momento in cui effettuiamo una
divisione per 2 il resto intero di tale divisione sarà ovviamente 0
oppure 1. Nel caso in cui tale divisione dà resto 0 significa
banalmente che il numero che abbiamo diviso è pari altrimenti, nel
caso di resto 1, il numero dovrà essere per forza di cose dispari. Di
seguito vi mostro una possibile implementazione del codice:
/* Stampa numeri pari fino a 50 */
#include <stdio.h>
#include <stdlib.h>
int main(int argc, char *argv[])
{
int i;
for (i=1; i<=50; i++)
{
if (i%2 == 0)
{
printf("%2d\n", i);
}
}
system("PAUSE");
return 0;
}

Il programma, seppur abbastanza semplice, fornisce spunti
interessanti di riflessione. Per prima cosa osserviamo la nidificazione
tra le due strutture di controllo for e if. Il contatore scandisce i
numeri da 1 a 50 ed “esce” quando la variabile i vale 51 grazie all’uso
dell’operatore relazionale <= (minore uguale). A ogni iterazione
testiamo la variabile i per verificare se la divisione per 2 dà resto
zero. Solo in questo caso stampiamo la variabile stessa. Da notare
come ho utilizzato il qualificatore %2d per stampare i numeri su due
colonne in modo da rendere l’output più ordinato.

Figura 7.1 – I primi numeri pari minori o uguali a 50.
Una delle cose che ritengo più affascinanti della programmazione è
la possibilità di implementare la risoluzione di uno stesso problema
con differenti modalità e approcci. Ciò consente al singolo
sviluppatore di trasferire nel proprio codice sorgente la sua peculiare
fantasia ed essenza creativa. Un cedere al codice che si scrive un
po’ del proprio DNA. Sarà questo uno dei motivi per cui noi
sviluppatori siamo così attaccati ai nostri programmi: sono nostre
creature, nostri figli. La motivazione di questa mia riflessione
dovrebbe essere un po’ più chiara osservando che il problema
appena visto, relativo alla stampa dei numeri pari minori di 50, può
essere risolto in maniera completamente diversa. Di seguito, il
codice, senza ulteriori filosofismi:
/* Stampa numeri pari fino a 50 - versione senza if */
#include <stdio.h>
#include <stdlib.h>
int main(int argc, char *argv[])
{
int i;
for (i=2; i<=50; i=i+2)
{
printf("%2d\n", i);
}
system("PAUSE");
return 0;

}

In questo caso il codice risulta più compatto. Nel for partiamo con i
uguale a 2 e arriviamo a ciclare, ancora come prima, fino al valore
50. Tuttavia, questa volta, nella terza parte del for usiamo
un’istruzione che incrementa la variabile contatore i di due unità per
volta. Questo per fare in modo che a ogni iterazione, partendo da 2,
andiamo a costruire direttamente tutti i numeri pari fino al limite che
ci siamo imposti.
Per certi aspetti si tratta di due approcci completamente diversi; nel
primo caso generiamo tutti i numeri ma scegliamo solo quelli pari,
nel secondo, invece, generiamo direttamente ed esclusivamente i
soli numeri pari.

Chi è il maggiore?
Di seguito vi riporto un nuovo esempio d’uso del ciclo for con un
minimo di utilità pratica: l’individuazione del numero maggiore tra
una serie di numeri forniti in input dall’utente:
#include <stdio.h>
#include <stdlib.h>
#define TOT_NUM 10
int main(int argc, char *argv[])
{
int max, i, x;
for (i=1; i<= TOT_NUM; i++)
{
printf("Dammi il numero: ");
scanf("%d", &x);
if (i==1) max = x; /* impostiamo il primo numero letto
come max temporaneo */
if (x>max)
{
max=x;
}
}
printf("Il massimo e': %d\n", max);
system("PAUSE");
return 0;

}

La prima cosa da notare è l’uso della direttiva:
#define TOT_NUM 5

In tal modo impostiamo la costante TOT_NUM, nello specifico al valore
10, considerandola come la quantità di numeri che vogliamo
esaminare. Si tratta di un modo semplice ed efficace per poter
modificare, durante la fase di scrittura del codice, la dimensione del
nostro problema, andando a impostare tale costante a un valore
molto più basso, tipo 3 oppure 5, per poter con più sveltezza provare
la validità del nostro codice.
Mi spiego meglio: se il nostro problema prevede la gestione di 10 o
addirittura 100 numeri, non ha senso buttar via minuti preziosi della
nostra esistenza per inserire in input tali valori per poi scoprire che il
codice ha un bug che impedisce la corretta determinazione
dell’output. Molto meglio provare prima con una piccola quantità di
numeri, in modo da arrivare velocemente al nucleo dell’esecuzione
per testarne la validità.
La prima parte del codice dell’esempio è banale: prendiamo in input,
all’interno del ciclo for i vari valori richiesti all’utente e li poniamo, di
volta in volta, nella variabile x.
Di interesse è l’uso del costrutto if all’interno del for:
if (i==1) max = x;

con tale istruzione ci preoccupiamo di inizializzare un massimo
temporaneo iniziale. Per farlo verifichiamo che il numero letto sia il
primo. In questo caso impostiamo la variabile max uguale, appunto, a
tale numero. Contravvenendo alle mie consuetudini, ho posto l’intero
costrutto su di una sola riga e non ho usato le parentesi graffe per
includere il corpo di esecuzione dell’if stesso. Vi ricordo che ciò è
possibile in quanto l’istruzione relativa all’if è soltanto una. Questo
tipo di impostazione compatta del codice può risultare accettabile
quando si tratta di situazioni particolari, come ad esempio questa in
cui tale if sarà soddisfatto per un solo valore dell’input: nel nostro
caso, come detto, per il primo valore.
Il secondo if è a dir poco banale; se il numero letto in input, x, è

maggiore del massimo temporaneo, lo imposto come nuovo
elemento maggiore. All’uscita del ciclo for stamperò l’ultimo massimo
temporaneo acquisito.

Il ciclo while
Un altro metodo classico per ripetere per un dato numero di volte
una certa sequenza di istruzioni è quello di usare il ciclo while, la cui
forma generale è la seguente:
while (espressione)
{
istruzioni;
}

Viene innanzitutto valutata l’espressione tra parentesi: fin quando
questa risulta vera viene eseguito il blocco di istruzioni.
Per mettere alla prova questo nuovo costrutto realizziamo un
semplice programma che stampa dieci righe numerate, appunto, da
1 a 10:
#include <stdio.h>
#include <stdlib.h>
int main(int argc, char *argv[])
{
int i;
i=1;
while (i<=10)
{
printf("Io sono la riga numero %d\n", i);
i++;
}
system("PAUSE");
return 0;
}

Da una veloce disamina del codice proposto, vi renderete conto
della forte analogia con il costrutto for. La differenza sostanziale la
possiamo vedere nel fatto che il while non prevede la gestione diretta
della variabile contatore né per quanto riguarda la sua
inizializzazione né in relazione al suo incremento. Infatti, nel codice
ho dovuto porre l’inizializzazione della variabile contatore a i=1
immediatamente prima del ciclo e l’incremento con i++, al suo

interno, prima dell’uscita dal ciclo stesso.

È la somma che fa il totale
Sfruttando una celebre frase del grande Totò nel titolo di questo
piccolo paragrafo, vi presento un ulteriore esempio d’uso del while.
Scriviamo un programma che calcola e stampa la somma di cinque
numeri dati in input dall’utente:
#include <stdio.h>
#include <stdlib.h>
int main(int argc, char *argv[])
{
int i, x, s;
i=1;
s=0;
while(i <= 5)
{
printf("Inserisci un numero: ");
scanf("%d", &x);
s = s + x;
i++;
}
printf("La somma e': %d\n", s);
system("PAUSE");
return 0;
}

Usiamo la variabile s per contenere le somma. È da considerare
l’assoluta importanza di inizializzare a zero il suo valore. Infatti,
tale variabile conterrà a ogni iterazione la somma parziale di volta in
volta calcolata con l’espressione:
s = s + x;

Se tale variabile s non venisse posta inizialmente a zero il suo valore
iniziale sarebbe, come abbiamo già verificato in altre situazioni, del
tutto casuale. Ciò comporterebbe inevitabilmente un valore non
corretto quando a s andiamo a sommare la variabile x valorizzata
con l’input utente. Per verificare come il valore di s si modifichi a ogni
iterazione vi consiglio di andare in debug come vi ho mostrato nel

Capitolo 4.
Per il resto, il codice dell’esempio non dovrebbe presentare problemi
di comprensione; usiamo la i come contatore che, inizializzato a
uno, incrementiamo con i++ a ogni iterazione.

For e while a confronto
Potete facilmente riflettere sull’estrema intercambiabilità dei due
costrutti for e while osservando come il problema di calcolare la
somma appena visto può essere implementato in maniera molto
simile con il costrutto for:
#include <stdio.h>
#include <stdlib.h>
int main(int argc, char *argv[])
{
int i, x, s;
s=0;
for (i=1; i <= 5; i++)
{
printf("Inserisci un numero: ");
scanf("%d", &x);
s = s + x;
}
printf("La somma e': %d\n", s);
system("PAUSE");
return 0;
}

La scelta tra l’uno o l’altro dei due costrutti può spesso essere
guidata da una questione di preferenze e gusto personali. Tuttavia
un’indicazione di massima esiste comunque; il for di norma è
maggiormente indicato quando il numero di iterazioni da realizzarsi è
ben definito a priori. Nei casi appena visti la dimensione del
problema era nota: 5, 10 oppure 100 iterazioni ben definite a monte
dell’esecuzione.
In altri casi, invece, il numero di volte per cui dobbiamo effettuare
una data serie di operazioni non è definito nel problema ma è esso
stesso variabile. Supponiamo, ad esempio, che il numero di elementi
da sommare non sia predeterminato ma sia l’utente stesso a

decidere, durante la fase di input, quando terminare l’inserimento dei
dati stessi. Una tale intenzione potrebbe, per esempio, essere
espressa utilizzando un valore speciale, diciamo zero supponendo
che l’input debba essere per forza di cose di tipo positivo. È in questi
casi che l’uso del while risulta sicuramente più naturale.
Un esempio mi sembra indispensabile.
#include <stdio.h>
#include <stdlib.h>
int main(int argc, char *argv[])
{
int x, s;
s = 0;
printf("Inserisci un numero positivo oppure 0 per terminare:
");
scanf("%d", &x);
while (x != 0)
{
s = s + x;
printf("Inserisci un numero positivo oppure 0 per
terminare: ");
scanf("%d", &x);
}
printf("La somma e': %d\n", s);
system("PAUSE");
return 0;
}

Le variabili in gioco sono sostanzialmente le stesse della situazione
precedente, senza tuttavia la necessità di utilizzare la variabile
contatore i. Prima di entrare nel ciclo while chiediamo all’utente di
inserire un valore da sommare oppure di digitare zero per terminare
l’inserimento dei dati. Nel caso in cui l’utente dovesse digitare già
alla prima richiesta il valore zero, il while non sarebbe soddisfatto
rispetto alla condizione x diverso da zero e quindi l’esecuzione
salterebbe all’esterno del ciclo, andando a stampare zero come
valore per la somma. Infatti, la variabile s inizializzata a zero non
verrebbe minimamente intaccata da ulteriori modifiche.
Al contrario, nel caso di inserimento di un valore diverso da zero
l’esecuzione si sposterebbe all’interno del corpo del ciclo while dove

il valore di x verrebbe sommato a quello di s. Subito dopo siamo
costretti a ripetere l’invito di inserimento dei valori al nostro utente. Il
resto dovrebbe essere ormai chiaro.

Il ciclo do-while
Ok, stiamo facendo grandi progressi. Cerchiamo ora di fare un
ulteriore passo in avanti rispetto alla possibilità di scrivere un codice
elegante e funzionale. Se osservate, anche distrattamente, l’ultimo
programmino che abbiamo scritto, vi renderete immediatamente
conto di qualcosa che non va, una sorta di nota stonata. Mi riferisco
al fatto che ci troviamo a ripetere, in maniera assolutamente identica,
le istruzioni relative all’input dei dati:
printf("Inserisci un numero positivo oppure 0 per terminare:
");
scanf("%d", &x);

Ciò è forzato dalla necessità di controllare un valore nella condizione
del while. Senza tale valore, nel nostro caso x, non siamo in grado di
decidere cosa fare. Tuttavia tale richiesta deve essere ripetuta e
quindi siamo costretti a riportare nuovamente nel codice le stesse
due righe con le istruzioni printf e scanf. Ma abbiamo un’alternativa
da giocarci: il ciclo do-while.
Mentre il ciclo while controlla l’espressione prima di procedere
all’esecuzione delle istruzioni, il ciclo do-while esegue prima il blocco
di istruzioni e successivamente verifica l’espressione. Fin quando
quest’ultima rimarrà vera, verranno eseguite le istruzioni del blocco
tra parentesi graffe.
La struttura generale del costrutto è la seguente:
do
{
istruzioni;
}
while (espressione);

È proprio quello che ci serve! Nel nostro caso, almeno una volta,
dobbiamo per forza di cose prendere in input un valore, fosse anche
solo per far segnalare all’utente che non vuole inserire valori.
Vediamo allora come possiamo procedere:

#include <stdio.h>
#include <stdlib.h>
int main(int argc, char *argv[])
{
int x, s;
s = 0;
do
{
printf("Inserisci un numero positivo oppure 0 per
terminare: ");
scanf("%d", &x);
s = s + x;
}while (x != 0);
printf("La somma e': %d\n", s);
system("PAUSE");
return 0;
}

Dunque, dopo aver inizializzato a zero la variabile s, entriamo,
indipendentemente da qualsiasi cosa, all’interno del ciclo ed
eseguiamo le istruzioni relative all’accettazione dell’input. Subito
dopo effettuiamo la somma parziale.
Nel caso in cui già al primo input l’utente dovesse inserire il valore
zero, la somma rimarrebbe comunque a zero e la successiva verifica
dell’operatore relazionale del ciclo fallirebbe, forzando l’uscita dal
ciclo stesso. In caso contrario l’esecuzione riprenderebbe dall’interno
del costrutto con una nuova richiesta per un nuovo valore di input.
Come ulteriore esempio vi propongo una semplice applicazione che
legge in sequenza una serie di numeri e termina quando incontra il
numero 0 (zero), restituendo la lunghezza della sequenza stessa:
#include <stdio.h>
#include <stdlib.h>
int main(int argc, char *argv[])
{
int count=0;
int x;
printf("Digita un numero per volta confermandolo con Invio
- 0 per terminare\n");
do
{

scanf("%d", &x);
count++;
}while (x!=0); /* continuo il ciclo finché non trovo il
carattere zero */
/* decremento di 1 il valore di count per escludere lo zero
dal conteggio */
printf("Lunghezza sequenza: %d\n ", count-1);
system("PAUSE");
return 0;
}

Facciamo un break
In talune circostanze si potrebbe avere la necessità di uscire
prematuramente da un ciclo. Un classico esempio lo si può vedere
quando all’interno di un certo ciclo siamo alla ricerca di un dato
valore. Una volta individuato tale valore potremmo voler forzare
l’uscita dal ciclo stesso. In queste circostanze è possibile usare
un’apposita istruzione chiamata break, che costringe appunto il
codice all’uscita dal ciclo in questione. Si tratta della stessa
istruzione usata nel costrutto switch e che sfruttiamo in quel contesto
per indicare il termine di una sezione case.
Per rendere palese il funzionamento dell’istruzione break, vi
propongo il codice seguente:
#include <stdio.h>
#include <stdlib.h>
int main(int argc, char *argv[])
{
int i, x;
printf("Da 1 a 100 dimmi quando ti vuoi fermare: ");
scanf("%d", &x);
i = 1;
while (i<=100)
{
if (i == x)
{
break;
}
printf("%d\n", i);
i++;
}
system("PAUSE");
return 0;
}

Il codice si basa su di un ciclo while che stampa i numeri da 1 a 100.
Chiediamo all’utente fino a che punto vuole stampare tali interi e con
un costrutto if verifichiamo se il numero indicato dall’utente
corrisponde al punto in cui la variabile contatore si trova nel suo

“percorso” all’interno dell’iterazione. L’eventuale esecuzione del break
causerà l’uscita forzata dal ciclo, lasciando a video gli interi stampati
fino al passo precedente. Parlo di eventualità in quanto, banalmente,
se l’utente dovesse indicare un numero minore di 1 oppure maggiore
di 100, la condizione dell’if non verrebbe mai soddisfatta.

8
Cominciamo a fare sul serio: gli
array
Io non temo i computer. Temo la loro

mancanza.
Isaac Asimov
Gli strumenti che vi ho fornito fino a questo punto sono di sicuro
interesse: abbiamo “giocato” con i concetti di variabile e di costante
e abbiamo visto come manipolarli al fine di ottenere delle semplici
elaborazioni di dati.
Ho sottolineato il fatto che le elaborazioni che abbiamo fin qui
realizzato sono semplici. In generale, infatti, in un contesto reale le
cose sono normalmente più complesse e coinvolgono entità e
insiemi di dati difficilmente trattabili con le tipologie di variabili viste
finora.

Premesse sulla complessità dei dati
Vi faccio un esempio di una situazione comune e banale per farvi
meglio capire il contesto del quale stiamo discutendo.
Immaginiamo di dover gestire le estrazioni del lotto. Si tratta di
diverse serie di numeri interi; una serie di cinque numeri per ogni
ruota (dieci per la precisione: Bari, Cagliari, Firenze, Genova,
Milano, Napoli, Palermo, Roma, Torino e Venezia). Dovendo
memorizzare ciascun numero uscito a una data estrazione
dovremmo gestire una notevole quantità di variabili.
Ad esempio, per gestire le singole uscite per la sola ruota di Bari
dovremmo dichiarare qualcosa del tipo:
int ba1, ba2, ba3, ba4, ba5;

Ovvero ba1 per memorizzare il primo estratto, ba2 per il secondo e
così via. Ovviamente la scelta del nome è arbitraria. Avrei potuto
scegliere bari1 oppure bari_1 per il primo estratto. In ogni caso il
nome deve aiutare a comprendere il senso della variabile e, nei limiti
del possibile, essere sintetico. Tuttavia non è mai una buona pratica
essere eccessivamente minimalisti con scelte del tipo b1, b2, b3, b4
e b5 per, ad esempio, la ruota in questione di Bari, in quanto si
potrebbe perdere di efficacia comunicativa rispetto al ruolo svolto
dalla variabile stessa. Prima di proseguire ci tengo solo a
sottolineare, se mai ce ne fosse bisogno, come la scelta di un nome
di un lunghezza piuttosto che un’altra non pregiudichi minimamente
l’efficienza del compilato che ne scaturirà.
Tornando alle nostre ruote, per le uscite di Cagliari potrei dichiarare
le seguenti variabili:
int ca1, ca2, ca3, ca4, ca5;

e così via.
Il comandante Kirk della nave stellare Enterprise, di fronte al
dilemma di dover far morire degli umani o in alternativa sacrificare gli
uomini del suo equipaggio per riuscire a salvare i primi, disse al

signor Spock, il suo primo ufficiale: “Spock, voglio un’altra
soluzione!”.
Quando una certa situazione vi sembra troppo complicata da gestire
ricordatevi le parole del comandante Kirk: deve esserci un’altra
soluzione possibile.
Nel nostro caso la soluzione possibile prende il nome di strutture
dati composte.

Le strutture dati composte
I tipi di variabili che abbiamo visto finora sono detti semplici. Essi,
infatti, possono esclusivamente gestire un singolo valore del tipo
dichiarato. Che si tratti di un intero (int), un carattere (char) o un
numero con la virgola (float), stiamo sempre parlando di singoli
valori. Fortunatamente, per gestire situazioni più complicate (come
quella delle estrazioni del lotto) possiamo contare su tipi di dati
composti o strutturati.
In relazione alle estrazioni del lotto, ci tengo comunque a chiarire
che da parte mia non vi è alcuna intenzione di spingervi a praticare
tale gioco. Al contrario, ritengo estremamente più probabile che vi
arricchiate scrivendo codici e programmi utilizzando gli spunti di
questo mio libro piuttosto che vincendo al lotto o a una qualsiasi altra
forma di lotteria (gratta e vinci compresi).
Tali “giochi” devono essere semplicemente considerati come stimolo
per tutta una serie di considerazioni sulla casualità e probabilità di
una serie di eventi.
Torniamo quindi alla questione delle strutture dati: la prima struttura
dati composta che analizziamo, di importanza addirittura capitale, è
l’array, noto anche con il nome di vettore.

Gli array
Un array è un oggetto che serve a contenere un certo numero di
variabili elementari tutte dello stesso tipo. Per spiegarvi il concetto
di variabili ho fatto precedentemente uso dell’esempio di una scatola
con un’etichetta che serve a contenere un certo tipo di dato. Per
immaginare un array potete pensare a una sequenza di scatole, tutte
dello stesso tipo, incollate una vicino l’altra in sequenza.
L’intero “trenino” di scatole ha un nome unico e ogni singola scatola
è individuabile attraverso il numero della sua posizione nella
sequenza. Come al solito noi informatici iniziamo a contare da zero,
per cui la prima posizione ha indice 0, la seconda 1 e così via.
Indice è in gergo la posizione dell’elemento all’interno della
sequenza.
La Figura 8.1 mostra come può essere schematizzato un array di
cinque elementi che abbiamo pensato di chiamare pippo.

Figura 8.1 – Un array di cinque elementi.
Prima di poter utilizzare il vettore, così come facciamo per le variabili
semplici, dobbiamo dichiararlo: specifichiamo il tipo di oggetti che
dovrà contenere, il suo nome e quindi, tra parentesi quadre, quanti
oggetti (vagoni del nostro ipotetico treno) dovrà contenere.
int pippo[5];

Abbiamo così dichiarato un array di cinque elementi di tipo intero.
Per riferirci ai singoli elementi contenuti nell’array indichiamo il nome
dell’array e, sempre tra parentesi quadre, la posizione dell’elemento
nell’array stesso. Supponiamo, ad esempio, di voler inserire nelle
cinque celle dell’array i primi cinque numeri pari:

pippo[0]=2;
pippo[1]=4;
pippo[2]=6;
pippo[3]=8;
pippo[4]=10;

Il risultato lo possiamo schematizzare come segue:

2 4 6 8 10
0123 4
dove all’interno delle celle abbiamo posto il contenuto vero e proprio
e sotto ogni singola cella il suo indice.
Per mettere le cose insieme vi presento un esempio che oltre a
dichiarare e valorizzare l’array ne stampa anche il contenuto:
#include <stdio.h>
#include <stdlib.h>
int main(int argc, char *argv[])
{
/* Dichiarazione array */
int pippo[5];
/* Valorizzazione degli elementi */
pippo[0]=2;
pippo[1]=4;
pippo[2]=6;
pippo[3]=8;
pippo[4]=10;
/* Stampa array */
printf("I contenuto dell'array e':");
printf("\n%d", pippo[0]);
printf("\n%d", pippo[1]);
printf("\n%d", pippo[2]);
printf("\n%d", pippo[3]);
printf("\n%d", pippo[4]);
printf("\n");
system("PAUSE");
return 0;
}

Ovviamente, così come possiamo assegnare a un elemento
dell’array un dato valore, possiamo, al contrario, leggere un valore

da una data cella riferendoci sempre a essa attraverso il suo indice.
Ad esempio, l’istruzione:
x = pippo[3];

assegnerà alla variabile x il valore contenuto nella quarta posizione
(quella con indice 3) e quindi nel nostro caso x varrà 8.
La cosa notevole da osservare a questo punto della nostra analisi è
che l’indice dell’array non deve essere necessariamente una
costante; al contrario, esso può essere una variabile con la quale
possiamo riferirci ai vari elementi dell’array in base al suo valore:
i = 2;
x = pippo[i];

farà in modo che, nel nostro esempio, x contenga il valore 6.
È facile, a questo punto, immaginare gli scenari di libertà e potenza
che ci si spalancano dinanzi. Volendo stampare tutti gli elementi
dell’array è sufficiente la briciola di codice che vi riporto di seguito:
for (i=0; i<5; i++)
printf("%d", pippo[i]);

Banalmente, il contatore varierà da 0 a 4 permettendo alla funzione
printf di stampare, uno di seguito all’altro, tutti gli elementi dell’array.

Valorizzazione e stampa di un array: un esempio
completo
Di seguito vi presento un esempio relativo a un semplice
programmino che legge una serie di numeri come input utente, li
pone in un array e successivamente li stampa.
#include <stdio.h>
#include <stdlib.h>
#define TOT_NUM 5
int main(int argc, char *argv[])
{
int i;
int a[TOT_NUM];
/* Leggo i numeri in input */
printf("Inserisci i singoli numeri confermandoli con il

tasto Invio\n");
for (i = 0; i < TOT_NUM; i++)
{
scanf("%d", &a[i]);
}
/* Stampo i numeri inseriti */
printf("I numeri inseriti sono:\n");
for (i = 0; i < TOT_NUM; i++)
{
printf("%d%c", a[i], ' ');
}
printf("\n");
system("PAUSE");
return 0;
}

L’analisi del codice dovrebbe risultare abbastanza semplice. Il primo
ciclo consente l’input dell’utente e fa variare la variabile contatore da
zero fino a quando essa risulta inferiore della costante TOT_NUM che nel
nostro esempio ho posto a 5. Dunque la variabile i assumerà valori
da 0 a 4, ovvero proprio gli indici del nostro array. Con il ciclo
successivo, utilizzando la stessa variabile contatore, effettuiamo un
nuova scansione dell’array, questa volta per stamparne il contenuto.
In tale stampa vi propongo un modo diverso per forzare l’inserimento
di un carattere spazio utilizzando il qualificatore %c utilizzato appunto
per la stampa dei caratteri:
printf("%d%c", a[i], ' ');

dove il carattere spazio è indicato con i singoli apici che contengono
appunto al loro interno uno spazio.

Inizializziamo un array
Così come avviene per le variabili semplici, per le quali possiamo
assegnare un valore direttamente durante la fase di dichiarazione,
ad esempio:
int x = 9;

allo stesso modo possiamo assegnare i valori che il nostro array
dovrà contenere nel momento stesso in cui lo dichiariamo,
utilizzando una coppia di parentesi graffe con all’interno, separati da
una virgola, i singoli valori numerici:
int x[6]={5, 8, 6};

Tale operazione è nota come inizializzazione.
Il risultato è lo stesso che avremmo ottenuto se avessimo assegnato
manualmente i singoli valori numerici alle specifiche posizioni
dell’array, come mostrato di seguito:
x[0]=5;
x[1]=8;
x[2]=6;
x[3]=0;
x[4]=0;
x[5]=0;

da notare, infatti, che scrivendo:
int x[6]={5, 8, 6};

si assegna un valore solo ai primi 3 elementi; gli elementi non
assegnati assumono in maniera predefinita (per default) il valore
zero. È questo il motivo per cui, nell’assegnazione manuale ho
posto:
x[3]=0; x[4]=0; x[5]=0;

per riprodurre, cioè, la stessa situazione che si ottiene con
l’assegnazione dei valori in fase di dichiarazione.
Volendo inizializzare a zero l’intero array potremmo allora scrivere:

int x[6]={};

cioè indicando la sola coppia di parentesi graffe aperte e chiuse.
Tale operazione può risultare in alcuni casi necessaria in quanto la
semplice dichiarazione dell’array non prevede, così come si
potrebbe immaginare, l’azzeramento automatico dei valori nelle varie
posizioni. Al contrario, così come avviene per le variabili di tipo
semplice, la sola dichiarazione prevede la predisposizione di uno
spazio di memoria che conterrà un valore del tutto casuale.
Per verificare tale affermazione in prima persona provate il seguente
pezzo di codice:
#include <stdio.h>
#include <stdlib.h>
int main(int argc, char *argv[])
{
int a[5];
int i;
printf("I valori sono:\n");
for (i = 0; i < 5; i++)
{
printf("%d\n", a[i]);
}
printf("\n");
system("PAUSE");
return 0;
}

Se in questo momento vi sentite particolarmente pigri e non vi va di
compilare il programmino proposto, potete anche fidarvi della Figura
8.2 nella quale vi mostro la console con il codice in questione, che
riporta dei valori assolutamente random (casuali) rispetto alle singole
celle dell’array.

Figura 8.2 – Il contenuto random delle celle di un array di interi nel
caso in cui queste non vengano valorizzate.

È anche possibile inizializzare un array senza indicarne la
dimensione a patto, tuttavia, di inizializzare il valore degli elementi
che esso andrà a contenere. Ad esempio, la seguente istruzione
dichiara e inizializza un array contenente tre elementi senza
specificarne a priori la dimensione all’interno delle parentesi quadre.
int a[]={5, 8, 2};

Ciò è possibile in quanto il compilatore conta gli elementi presenti tra
parentesi graffe e imposta di conseguenza la dimensione dell’array
in questione.

Array di caratteri, usiamo le stringhe
Nello sviluppo software, uno degli elementi più comuni e al
contempo più ostici da trattare è rappresentato dalle stringhe. Una
stringa è la concatenazione di caratteri alfanumerici (cioè lettere e
numeri).
Generalmente, per indicare una stringa si utilizzano i doppi apici.
"Carlo", "Dal C al C++", "ciccio pasticcio", "Analisi
matematica 1"

sono esempi di stringhe.
Ora che conosciamo gli array possiamo provare a trattare con questi
“infidi” oggetti. Il C non ha un tipo predefinito di variabile per gestire
le stringhe; esse vengono “simulate” attraverso degli array di
caratteri:
char nome[7] = "ciccio";

dichiara e inizializza un array di caratteri contenente la stringa
“ciccio”.
Dopo tale dichiarazione ciò che otteniamo è la seguente situazione:

c i c c i o \0
01234 5 6
Come potete notare, nell’ultima posizione viene posto
automaticamente, dal compilatore, il carattere speciale ‘\0’ (cioè
backslash e poi zero) noto come carattere di fine stringa. Tale
carattere “nullo” serve appunto a segnalare dove termina la stringa.
La stessa situazione la si sarebbe ottenuta procedendo come segue:
char nome[7];
nome[0]='c';
nome[1]='i';
nome[2]='c';
nome[3]='c';
nome[4]='i';

nome[5]='o';
nome[6]='\0';

In questo caso, ho dichiarato il vettore di caratteri nome e
successivamente ho assegnato alle singole posizioni i singoli
caratteri. Vi faccio notare come sia stato necessario indicare una
dimensione per l’array più lunga di una unità per far posto al
carattere di fine stringa. Da ribadire inoltre l’uso dei singoli apici per
identificare un carattere.
In realtà, è possibile, se il contesto lo permette, evitare di indicare la
dimensione dell’array come già sperimentato nel caso di array di tipo
numerico, procedendo qui come segue:
char nome[] = "ciccio";

In questo caso, infatti, non indicando tra le parentesi quadre la
dimensione dell’array, è il compilatore stesso che se ne fa carico
osservando la lunghezza della stringa associata (in questo caso
“ciccio”) e impostando di conseguenza la giusta dimensione.
È ovvio, tuttavia, che una dichiarazione come la seguente:
char nome[]; /* ERRATO */

non è consentita. Infatti, il compilatore non saprebbe come ricavare
le indicazioni di spazio necessario per il nostro vettore.
Così come avveniva per i classici array di interi, possiamo dichiarare
e inizializzare un array di caratteri usando le parentesi graffe come vi
mostro di seguito:
char nome[] = {'c','i','c','c','i','o','\0'};

In questo caso abbiamo inizializzato il vettore indicando i singoli
caratteri per le singole celle dell’array. Da notare il simbolo '\0' usato
per indicare la fine della stringa e, ancora una volta, come tali singoli
caratteri siano racchiusi tra i singoli apici per segnalare la loro natura
di carattere (non sono dei numeri!).

Caratteri “numerici”
Per una maggiore comprensione di quanto stiamo gestendo può
essere utile fare una riflessione sulla rappresentazione dei dati nella
memoria di un calcolatore. La conversione tra le sequenze di bit
usate dalla macchina e i simboli, numeri e lettere e quant’altro
utilizzato da noi umani per rappresentare i nostri dati, si basa su
delle tabelle che associano a tali simboli una codifica numerica. Si
tratta, ovviamente, di numeri binari. Tuttavia, per semplicità noi
facciamo riferimento al loro corrispondente valore decimale. Le più
utilizzate tabelle di conversione sono rappresentate, come già visto
nel Capitolo 1, dai codici ASCII e Unicode.
Il seguente esempio può essere illuminante:
#include <stdio.h>
#include <stdlib.h>
int main(int argc, char *argv[])
{
char c;
c = 'A';
printf ("Il valore numerico del carattere %c e': %d \n", c,
c);
system("PAUSE");
return 0;
}

Ho dichiarato la variabile di tipo carattere c assegnandole la lettera
‘A’. Di seguito, con la printf stampo tale variabile due volte: la prima
con il qualificatore %c e la seconda con %d.
L’output sarà:
Il valore numerico della lettera A e': 65

Infatti, il qualificatore %c stamperà la variabile c come carattere,
mentre il qualificatore %d ne stamperà la sua rappresentazione
numerica, ovvero il numero decimale 65.
Per meglio chiarire il contesto vi propongo un ulteriore pezzo di

codice che stampa, tramite un ciclo for, l’intero insieme dei 256
simboli (da 0 a 255) del codice ASCII:
#include <stdio.h>
#include <stdlib.h>
int main(int argc, char *argv[])
{
int i;
for(i=0; i<=255; i++)
{
printf ("Il valore numerico del simbolo %c e': %d \n", i,
i);
}
system("PAUSE");
return 0;
}

Come già detto in altra occasione i codici decimali da 0 a 31 e il 127
sono caratteri non stampabili detti codici di controllo. Il decimale 32
corrisponde al carattere “spazio”. Dal 32 al 126 sono caratteri
stampabili, così come lo sono i caratteri dal 128 al 255.

Input di caratteri, la funzione getchar
Dal momento che stiamo affrontando l’argomento caratteri può
essere utile che vi presenti una specifica funzione di input che serve
a prelevare un singolo carattere dalla tastiera. Tale funzione,
chiamata getchar(), è una alternativa a una scanf con il qualificatore
%c:
#include <stdio.h>
#include <stdlib.h>
int main(int argc, char *argv[])
{
char c;
printf ("Premi un tasto: ");
c = getchar();
printf ("Il valore numerico del simbolo %c e': %d \n", c,
c);
system("PAUSE");
return 0;
}

Nell’esempio precedente la funzione getchar() associa il simbolo letto
da tastiera alla variabile c per la quale la printf successiva stamperà
il corrispondente valore numerico.

Una pausa alternativa
La conoscenza della funzione getchar ci suggerisce un sistema
alternativo all’uso dell’istruzione system("pause"). Stiamo usando
sistematicamente tale funzione per evitare che alla fine
dell’esecuzione dell’applicazione questa si chiuda immediatamente
senza darci la possibilità di analizzare i risultati del nostro lavoro. Il
nuovo metodo potrebbe essere il seguente:
#include <stdio.h>
#include <stdlib.h>
int main(int argc, char *argv[])
{
/*
qui c'è il codice sorgente del programma
*/
printf ("Premi INVIO per continuare.\n");
getchar (); /* in attesa di input */
return 0;
}

Alla fine dell’esecuzione, prima della chiusura con l’istruzione return,
invochiamo la chiamata a getchar. Questa rimane in attesa di un input
qualsiasi e ovviamente non ci interessa associare tale input ad
alcuna variabile.
La cosa positiva di questo metodo è data dal fatto che possiamo
personalizzare a piacimento il messaggio da presentare all’utente
prima della chiusura del programma. Nel nostro caso lo facciamo
con la dicitura: “Premi INVIO per continuare.”.

Do ut des, ovvero getchar e putchar
Niente paura, questo testo non si sta trasformando in un corso di
latino. La frase “do ut des”, letteralmente “io do affinché tu dia”, mi
serviva solo per introdurre la funzione opposta a getchar, ovvero
putchar. Se infatti getchar prende in input un carattere, putchar
restituisce un carattere in output.
Di seguito un classico e semplice esempio del tutto autoesplicativo:
#include <stdio.h>
#include <stdlib.h>
int main(int argc, char *argv[])
{
char c;
printf("Inserisci un carattere: ");
c = getchar ();
printf("Il carattere inserito e': ");
putchar(c);
system("pause");
return 0;
}

Abbiamo semplicemente dichiarato una variabile c che valorizziamo,
attraverso la funzione getchar, con un carattere inserito da tastiera dal
nostro utente. Successivamente, invece di inserire all’interno della
printf il qualificatore %c per stampare il carattere, facciamo seguire
alla printf stessa la funzione putchar.

Il pappagallo rimbambito
Lasciando per un attimo in sospeso la questione dei singoli caratteri,
voglio ora tornare a discutere di stringhe (cioè insiemi di caratteri)
proponendovi un esempio del tipo “Il pappagallo alla riscossa”. Il
nostro pennuto, già visto in azione nel terzo capitolo nel quale
ripeteva il numero inserito dall’utente, sarà ora impegnato a ripetere
un’intera stringa.
#include <stdio.h>
#include <stdlib.h>
int main(int argc, char *argv[])
{
char nome[20];
printf("Come ti chiami: ");
scanf("%s", &nome);
printf("Il tuo nome e' %s \n", nome);
system("pause");
return 0;
}

Se provate a compilare ed eseguire il precedente programmino
potrete osservare uno “strano” comportamento. Il pappagallo, ehm...
il programma, vi chiederà il vostro nome. Supponete di chiamarvi
“Ciccio” e digitate dunque tale nome. Il programma vi risponderà “Il
tuo nome e’ Ciccio” grazie al fatto che esso è stato acquisito tramite
scanf e stampato tramite printf con il qualificatore %s utilizzato per le
stringhe. Fin qui tutto normale. Il nostro pappagallo è in piena forma.
Proviamo ora a rilanciare il programma; questa volta rispondiamo al
pappagallo che ci chiede il nome dicendogli (scrivendo) il nostro
nome seguito però dal cognome (ovviamente, “Ciccio Pasticcio”;).
Ebbene, il nostro pappagallo darà segni di demenza in quanto la sua
risposta sarà ancora: “Il tuo nome e’ Ciccio”.
Il problema è dovuto al fatto che la scanf, incontrando lo spazio di
separazione tra il nome e il cognome, troncherà la stringa proprio in
corrispondenza dello spazio medesimo.

Input e output di stringhe: gets e puts
La soluzione più semplice per risolvere il problema dell’input di
stringhe contenenti spazi vuoti è data dall’utilizzo della funzione gets.
Vediamone subito un’applicazione pratica:
#include <stdio.h>
#include <stdlib.h>
int main(int argc, char *argv[])
{
char nome[20];
printf("Come ti chiami? ");
gets(nome);
printf("Il tuo nome e': %s \n", nome);
system("pause");
return 0;
}

In questo modo il nostro pappagallo si comporterà finalmente in
maniera corretta. Infatti, la funzione gets legge un’intera linea di input
fino al carattere di terminazione di linea (cioè \n). Tale input viene
assegnato alla stringa e il carattere di terminazione di linea, \n, viene
convertito nel carattere di fine stringa, cioè in '\0'.
Esiste una funzione gemella di gets per quanto riguarda l’output di
stringhe: la funzione puts. Anche in questo caso mi sembra doveroso
presentare un adeguato esempio:
#include <stdio.h>
#include <stdlib.h>
int main(int argc, char *argv[])
{
char nome[]="Carlo Mazzone";
puts(nome);
system("pause");
return 0;
}

In definitiva la funzione puts corrisponde a un’istruzione del tipo:

printf("%s\n", nome);

dove nome è la stringa da stampare e il '\n' finale è giustificato dal
fatto che puts comporta un ritorno a capo automatico.

Il pappagallo 2, la vendetta
Il nostro pappagallo, da noi verbalmente maltrattato (gli abbiamo
dato del rimbambito), vuole vendicarsi dimostrandoci un nuovo e
alternativo modo per svolgere il suo lavoro di ripetizione.
Tale metodo prevede l’uso di un ciclo while in cui catturiamo i singoli
caratteri con la funzione getchar, inserendoli di volta in volta all’interno
delle singole celle di un array di caratteri. Il carattere letto in input
viene confrontato con il carattere '\n' per verificare se la digitazione
è terminata. Infatti, quando usiamo il tasto “invio” per confermare il
nostro nome, viene generato in automatico il carattere di newline
(appunto '\n').
#include <stdio.h>
#include <stdlib.h>
int main(int argc, char *argv[])
{
int i=0;
char nome[20];
char c;
printf("Come ti chiami? ");
while ((c = getchar()) != '\n')
{
nome[i] = c;
i++;
}
nome[i] = '\0';
printf("Il tuo nome e': %s\n" , nome);
system("pause");
return 0;
}

È importante fare attenzione all’uso delle parentesi intorno alla
chiamata (c = getchar()) per evitare problemi con l’ordine di
esecuzione delle istruzioni. Da notare, infine, come all’uscita del
while dobbiamo inserire il carattere '\0' di fine stringa.
Ovviamente, spero non vi sarà sfuggito, abbiamo un problema con le
dimensioni massime che impostiamo per l’array di caratteri.
Riscontreremmo, infatti, dei problemi nel caso in cui dovessimo

inserire una stringa di dimensioni superiori a quanto impostato nella
dichiarazione dell’array, nel caso dell’esempio il numero 20. Avremo
comunque modo di discutere ampiamente tali problematiche nel
prosieguo del nostro viaggio.

Alcune funzioni tipiche per le stringhe
Per facilitare il compito del programmatore nella gestione delle
stringhe è disponibile la libreria string.h utilizzabile con la seguente
ovvia direttiva:
#include <string.h>

Tra le varie funzioni messe a disposizione dalla libreria ve ne
presento alcune delle più importanti e sicuramente utili.

strlen(s) - restituisce la lunghezza di s
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
int main(int argc, char *argv[])
{
int len = 0;
char nome[] = "Ciccio Pasticcio";
len = strlen(nome);
printf("Il tuo nome e' lungo %d caratteri\n", len);
system("pause");
return 0;
}

Banalmente la funzione strlen restituisce la lunghezza della stringa
indicata come argomento all’interno delle parentesi tonde.
Ovviamente nel conteggio viene escluso il carattere di fine stringa \0
riportando il numero dei soli caratteri presenti nella stringa, spazi
compresi.

strcpy(s1, s2) – copia s2 in s1
La funzione strcpy copia il suo secondo argomento sul primo.
Vediamo un esempio:
#include <stdio.h>
#include <stdlib.h>

#include <string.h>
main()
{
char nome1[] = "Ciccio Pasticcio";
char nome2[] = "Pluto De Plutis";
strcpy(nome1, nome2);
printf("Il tuo nome e' %s ", nome1);
system("pause");
return 0;
}

Il risultato a video sarà: Il tuo nome e' Pluto De Plutis. Infatti, la
funzione strcpy farà in modo che il contenuto dell’array nome2 venga
copiato in nome1.
Ovviamente è possibile, e a volte comodo, utilizzare come secondo
argomento una stringa costante. Ad esempio come nel caso
seguente:
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
main()
{
char nome[20];
strcpy(nome, "Carlo A.");
printf("Il tuo nome e' %s ", nome);
system("pause");
return 0;
}

dove otterremo banalmente l’effetto di copiare la stringa "Carlo A."
nell’array nome.

strcat(s1, s2) – concatena s2 a s1
La funzione strcat effettua un’operazione del tipo s1 = s1+s2,
concatenando, ovvero mettendo uno dopo l’altro, i due suoi
argomenti.
#include <stdio.h>
#include <stdlib.h>

#include <string.h>
int main(int argc, char *argv[])
{
char nome1[] = "Ciccio";
char nome2[] = " Pasticcio";
strcat(nome1, nome2);
printf("Il tuo nome e' %s ", nome1);
system("pause");
return 0;
}

L’esempio precedente produrrà dunque come output:
Il tuo nome e' Ciccio Pasticcio

Da notare come abbia inserito uno spazio iniziale nel secondo array
per evitare che nome e cognome risultassero attaccati l’uno all’altro.

strcmp(s1, s2) – confronta due stringhe
La funzione strcmp effettua un confronto tra due stringhe. Se queste
risultano essere uguali, la funzione restituisce zero; se la prima
stringa è inferiore alla seconda restituisce -1; se, al contrario, la
prima stringa è maggiore della seconda, strcmp restituisce +1.
Come esempio d’uso vi propongo un semplice e ipotetico sistema di
controllo password.
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
int main(int argc, char *argv[])
{
int risultato = -1;
char password[] = "mago merlino";
char tentativo[20];
printf("Digita la password: ");
gets(tentativo);
risultato = strcmp(password, tentativo);
if (risultato == 0)
{
printf("Accesso consentito");
}
else

{
printf("ACCESSO NEGATO");
}
system("pause");
return 0;
}

Nel codice utilizziamo due array di caratteri. Nel primo array, che
chiamiamo password, inseriamo in maniera hard coded, cioè in
maniera costante e direttamente nel codice sorgente, la nostra
password. Il secondo array, che chiamiamo tentativo, servirà per
contenere la password di accesso digitata dall’utente.
Da notare come la funzione strcmp agisca in maniera case sensitive,
cioè facendo differenza tra minuscole e maiuscole. Ovviamente,
quindi, tentando di “accedere” con una password del tipo “MAGO
MERLINO” l’accesso ci sarà negato. Solo nel caso in cui le due
stringhe, ovvero le password, saranno uguali, la funzione strcmp
assegnerà alla variabile risultato il valore 0 e quindi la condizione di
verità del successivo costrutto if verrà soddisfatta.
Un’altra cosa importante da sottolineare è l’uso dell’istruzione:
gets(tentativo);

In alternativa avremmo potuto scrivere:
scanf("%s", &tentativo);

Tuttavia, solo usando la funzione gets potremo usare password che
utilizzano spazi al loro interno, a causa delle limitazioni già viste
prima in merito alla funzione scanf che tronca la stringa al primo
spazio che incontra.

9
Array bidimensionali
Se prendessimo un binocolo e lo
puntassimo nello spazio, vedremmo
una linea curva chiusa all’infinito.
Albert Einstein
Se tutto quanto visto finora, e nello specifico nel precedente capitolo
in relazione agli array, vi sembra complicato, sarà il caso che vi
teniate forte: fate un bel respiro perché aumentiamo una dimensione
agli array che diventano ora bidimensionali. Tuttavia, non c’è tanto di
cui preoccuparsi; come al solito le cose, anche quelle
apparentemente più complesse, affrontate nel modo giusto risultano,
dopo un po’, familiari e gestibili.

Array a due dimensioni
Il modo giusto per parlare di array a due dimensioni, più noti come
array bidimensionali, è pensare a una tabella: una semplice e
banale serie di righe e di colonne.

1 2 3
4 5 6
7 8 9
10 11 12
In buona sostanza si tratta di una serie di array unidimensionali
“impilati” uno sull’altro in una struttura nota anche con il termine di
matrice. Nell’esempio qui sopra ho disegnato una tabella con 4
righe e 3 colonne, nella quale ho inserito una serie di numeri
naturali.
La dichiarazione, in C, di un tale array è la seguente:
int tabella[4][3];

Il primo numero presente tra parentesi quadre indica il numero di
righe mentre il secondo rappresenta il numero di colonne dell’array.
Volendo è possibile dichiarare e inizializzare l’array in un’unica
istruzione come vi mostro di seguito:
int tabella[4][3]={{1,2,3},{4,5,6},{7,8,9},{10,11,12}};

dove ogni gruppo di elementi tra parentesi graffe rappresenta i valori
da inserire in una data riga. Tali gruppi, che sono a loro volta
racchiusi tra una coppia di parentesi graffe, sono separati tra loro da
una virgola.
Le cose sono abbastanza intuitive anche per quanto riguarda il
modo da utilizzare per riferirsi a un elemento dell’array; si utilizzano
due indici, uno per indicare la riga e un altro per indicare la colonna
dell’elemento di interesse. Anche in questo caso gli indici partono da

zero.
A titolo di esempio, il primo elemento, quello nella prima riga e prima
colonna (per intenderci quello in cui abbiamo posto il valore 1) ha
indice di riga 0 e indice di colonna 0 e si indica come segue:
x = tabella[0][0];

Tale istruzione avrà l’effetto di associare a una variabile di nome x il
valore 1 contenuto appunto nella cella dell’array in posizione “0,0”.
Di seguito vi ripropongo l’array in questione con l’indicazione degli
indici:

0 1

2

0 1 2 3
1 4 5 6
2 7 8 9
3 10 11 12
Dovrebbe ora esservi chiaro come possiamo riferirci a uno specifico
elemento. Volendo, ad esempio, stampare il contenuto dell’ultimo
elemento dell’array possiamo scrivere:
printf("%d", tabella[3][2]);

Nella stampa abbiamo indicato la riga con indice 3 e la colonna con
indice 2. Il risultato sarà a video il numero 12 contenuto nella
corrispondente cella dell’array.

La scansione di un array 2D
Tuttavia spesso si rende necessario stampare, o comunque
esaminare, intere porzioni, righe e/o colonne dell’array. È intuitivo
come tale operazione, che potremmo definire di scansione, debba
essere realizzata con costrutti di tipo iterativo. A proposito di
definizione di nuovi termini noterete come ho utilizzato
l’abbreviazione “2D” per riferirmi alle “2 Dimensioni” dell’array stesso
in sostituzione del termine bidimensionale.
Di norma, trattandosi di strutture dati con dimensioni prefissate, il
costrutto for è quello che più si presta a una tale operazione. Per
semplicità, immaginiamo inizialmente di voler stampare una riga
specifica dell’array in questione, ad esempio la prima riga. Gli
elementi di tale riga hanno tutti indice di riga zero mentre i
corrispondenti indici di colonna variano da 0 a 2. Per stampare allora
tali elementi potremmo scrivere:
printf("%d ", tabella[0][0]);
printf("%d ", tabella[0][1]);
printf("%d ", tabella[0][2]);

Ormai dovreste essere sufficientemente smaliziati da riconoscere,
all’interno della sequenza di istruzioni printf, la possibilità di sfruttare
tale comportamento regolare degli indici per compattare le varie
istruzioni di stampa in un’unica generica printf, appunto gestita da
un for con un contatore che farà variare l’indice di colonna appunto
da 0 a 2.
Possiamo quindi scrivere qualcosa del tipo:
#include <stdio.h>
#include <stdlib.h>
int main(int argc, char *argv[])
{
int tabella[4][3]={{1,2,3},{4,5,6},{7,8,9},{10,11,12}};
int i;
for (i=0; i<=2; i++)
{
printf("%d ", tabella[0][i]);
}

system("PAUSE");
return 0;
}

Tutto abbastanza lineare. L’unica osservazione che mi sento di fare
è a proposito della “chiusura” del ciclo for per la quale ho indicato
l’espressione i<=2 per far risaltare il fatto che l’indice sulle colonne
arriva fino a 2. Analogamente, ottenendo lo stesso risultato avrei
potuto scrivere:
for (i=0; i<3; i++)
{
printf("%d ", tabella[0][i]);
}

Indicando che il contatore i deve arrivare a essere inferiore a 3.
Proviamo ora a immaginare le operazioni da svolgere per stampare
tutte e quattro le righe della nostra matrice. Il primo e più intuitivo
approccio che può venirci in mente è quello di utilizzare un ciclo for
per ogni singola riga; scrivere dunque un qualcosa del genere:
#include <stdio.h>
#include <stdlib.h>
int main(int argc, char *argv[])
{
int tabella[4][3]={{1,2,3},{4,5,6},{7,8,9},{10,11,12}};
int i;
/* stampa prima riga */
for (i=0; i<=2; i++)
{
printf("%d ", tabella[0][i]);
}
printf("\n");
/* stampa seconda riga */
for (i=0; i<=2; i++)
{
printf("%d ", tabella[1][i]);
}
printf("\n");
/* stampa terza riga */
for (i=0; i<=2; i++)
{
printf("%d ", tabella[2][i]);
}
printf("\n");

/* stampa quarta riga */
for (i=0; i<=2; i++)
{
printf("%d ", tabella[3][i]);
}
printf("\n");
system("PAUSE");
return 0;
}

Analizziamo, allora, un po’ più in dettaglio, quello che abbiamo
codificato. Nella Figura 9.1 è mostrato l’output a video che ci
consente di verificare che il risultato corrisponde alle nostre
aspettative.

Figura 9.1 – L’output del contenuto dell’array bidimensionale.
Balza subito all’occhio che, anche in questo caso, si ha una grossa
ripetizione delle stesse istruzioni: quattro for pressoché identici che
differiscono solo nel richiamo, nell’istruzione di stampa, alla variabile
tabella che riporta nell’indice di riga di volta in volta i valori da 0 a 3.
Per evidenziare con maggior chiarezza tutto ciò, vi riporto di seguito
solo le printf utilizzate:
printf("%d ", tabella[0][i]);
printf("%d ", tabella[1][i]);
printf("%d ", tabella[2][i]);
printf("%d ", tabella[3][i]);

E dunque, ci siamo. Come si può facilmente vedere, tutto ciò di cui
abbiamo bisogno è far variare l’indice della riga da 0 a 3 in quanto il
secondo indice, quello della colonna, viene già fatto variare dal for
già utilizzato.
#include <stdio.h>
#include <stdlib.h>

int main(int argc, char *argv[])
{
int tabella[4][3]={{1,2,3},{4,5,6},{7,8,9},{10,11,12}};
int i,j;
for (i=0; i<4; i++)
{
for (j=0; j<3; j++)
{
printf("%3d", tabella[i][j]);
}
printf("\n");
}
system("PAUSE");
return 0;
}

Il codice utilizza quindi due cicli for annidati (cioè uno dentro l’altro).
Si utilizzano due indici: l’indice i per scorrere le righe e l’indice j per
scorrere le colonne. Questa è una sorta di standard. Quando si
hanno due indici, il primo è di norma chiamato, appunto, i e il
secondo j. Nel caso ci fosse un altro indice per un for ulteriormente
annidato lo chiameremmo k.
Da notare come nella funzione printf utilizziamo il qualificatore "%3d"
per realizzare un allineamento più elegante e leggibile dei dati nella
tabella stampata a video.

La generazione di numeri casuali
Può capitare, abbastanza spesso, di necessitare all’interno di un
nostro programma di una serie di numeri casuali (cioè, appunto,
generati a caso). La generazione di numeri casuali consente di
realizzare dei programmi di sicuro interesse in quanto si riesce a
dare al programma una sorta di vita propria.
Pensate ad esempio alla possibilità di creare dei videogame del tipo
battaglia navale, tris, dama o similari. In queste situazioni è
indispensabile che alcuni elementi, la posizione delle navi della
battaglia navale piuttosto che i pezzi del gioco della dama, possano
avere una collocazione diversa a ogni partita. Per farlo è sufficiente
che la loro posizione sia calcolata in maniera del tutto casuale
attraverso appunto uno o più numeri casuali. Nel contesto
anglosassone e, più in generale, informatico si parla di numeri
random essendo il termine random traducibile, appunto, come
casuale.
Vediamo, dunque, come produrre un generico valore casuale. Per
farlo dobbiamo usare un’opportuna funzione di nome rand come
mostrato di seguito:
x = rand();

La funzione rand() assegnerà a x un generico numero casuale.
Tuttavia, affinché ciò sia possibile è necessario richiamare
un’apposita funzione che inizializzi il generatore di numeri casuali;
tale funzione è srand.
Di seguito vi propongo un esempio completo:
#include <time.h> /* necessario per la funzione time */
#include <stdio.h>
#include <stdlib.h>
int main(int argc, char *argv[])
{
int x;
srand(time(NULL));
x = rand();
printf("Numero casuale: %d", x);

system("PAUSE");
return 0;
}

Come potete osservare dal codice, subito dopo la dichiarazione della
variabile intera x che conterrà il valore random, richiamiamo la
funzione srand. Questa funzione necessita come argomento di un
cosiddetto “seme”, che deve essere sempre diverso affinché
generazioni successive di numeri siano sempre casuali. Per far
questo possiamo dare in input a srand() la funzione time che
restituisce il numero di secondi trascorsi dal 1 gennaio 1970 fino al
momento in cui viene effettivamente richiamata.
Il numero random generato è un intero che può risultare anche molto
grande. Più spesso abbiamo bisogno di numeri casuali compresi
all’interno di un certo intervallo abbastanza limitato. Per ottenere tale
risultato possiamo fare ricorso all’operatore modulo (resto intero
della divisione tra due interi). Supponendo, ad esempio, di voler
generare numeri compresi tra 1 e 10 possiamo procedere come
segue:
x = rand()%10+1;

Infatti, il numero casuale viene così diviso per 10 prendendo il resto
intero di tale divisione (un numero tra 0 e 9) . A tale resto sommiamo
1 al fine di ottenere un intervallo tra 1 e 10.

Il gioco delle tre carte
Può essere sorprendente come, anche con queste semplici funzioni,
possiamo già realizzare qualche semplice giochino del tipo “Il gioco
delle tre carte”. Supponiamo di voler fare indovinare al nostro
giocatore la posizione di una carta vincente nascosta tra tre possibili
posizioni. Generiamo un numero casuale compreso tra 1 e 3 e
chiediamo al giocatore di indicare la posizione della carta vincente.
Banalmente comunichiamo, senza barare, la posizione vincente e se
il nostro giocatore ha vinto o meno.
Di seguito una prima bozza del codice.
#include <time.h> /* necessario per la funzione time */
#include <stdio.h>

#include <stdlib.h>
int main(int argc, char *argv[])
{
int pos; /* Posizione casuale vincente */
int x; /* Puntata del giocatore */
srand(time(NULL));
pos = rand()%3+1;
printf("IL GIOCO DELLE TRE CARTE\n\n");
printf("In quale posizione si trova la carta vincente?\n");
printf("Indica un numero da 1 a 3 e buona fortuna!\n");
scanf("%d", &x);
if (x == pos)
{
printf("Complimenti hai vinto!!!\n");
}
else
{
printf("Peccato, hai perso! La posizione vincente era la
numero %d\n", pos);
}
system("PAUSE");
return 0;
}

Il codice è estremamente semplice e quindi non dovrebbe essere
complesso seguirne il flusso. Come prima operazione generiamo un
numero casuale, che riduciamo a essere compreso tra 1 e 3,
assegnandolo alla variabile pos. Immediatamente dopo chiediamo
all’utente il numero sul quale puntare e lo confrontiamo con quello
random appena generato. In conseguenza dell’uguaglianza o meno
dei due valori stampiamo un messaggio che indica la vincita o meno
della giocata.
È ovvio, tuttavia, che questo è solo l’inizio. Una prima possibile
modifica per rendere il gioco più interessante potrebbe essere, ad
esempio, quella di non far terminare il programma dopo la prima
puntata ma far decidere al giocatore stesso quando interrompere il
gioco. Per farlo possiamo utilizzare un ciclo while. Supponiamo di
gestire la volontà di uscire dal gioco del nostro giocatore attraverso
la digitazione e il relativo controllo del valore zero.
Una possibile stesura del codice potrebbe essere la seguente:
#include <time.h> /* necessario per la funzione time */

#include <stdio.h>
#include <stdlib.h>
int main(int argc, char *argv[])
{
int pos; /* Posizione casuale vincente */
int x; /* Puntata del giocatore */
srand(time(NULL));
while(x!=0)
{
pos = rand()%3+1;
printf("IL GIOCO DELLE TRE CARTE\n\n");
printf("In quale posizione si trova la carta vincente?
\n");
printf("Indica un numero da 1 a 3 e buona fortuna! Digita
0 per uscire dal gioco.\n");
scanf("%d", &x);
if (x==0)
{
break;
}
else if (x==pos)
{
printf("Complimenti hai vinto!!!\n");
}
else
{
printf("Peccato, hai perso! La posizione vincente era
la numero %d\n", pos);
}
}
printf("Ciao e alla prossima partita!!!\n");
system("PAUSE");
return 0;
}

Il codice non presenta novità di rilievo e l’unica cosa che vale forse
la pena sottolineare è la condizione di uscita dal ciclo while attraverso
l’uso dell’istruzione break.

10
Ordiniamo le cose: gli algoritmi
notevoli
La

scienza

dei

computer

non

riguarda i computer più di quanto
l’astronomia riguardi i telescopi.
Edsger Wybe Dijkstra
Scrivere codice è sicuramente un’operazione “artistica”: con tale
termine voglio esprimere il fatto che ogni programma è una vera e
propria creazione personale, nella quale ciascuno infonde il proprio
estro e la propria esperienza.
Ciò detto, esistono dei metodi di risoluzione di determinati problemi
che sono ormai ben conosciuti e standardizzati: tali algoritmi
risolutivi prendono il nome di algoritmi notevoli.
Tra gli algoritmi notevoli più classici rientrano sicuramente quelli
relativi all’ordinamento (in inglese sort) di elementi spesso contenuti
in degli array. In buona sostanza si cerca di ottenere, nel modo più
efficiente possibile, che gli elementi presenti in un dato array siano
ordinati rispetto a un dato criterio; nel caso di numeri, che questi
siano ordinati dal più piccolo al più grande (o viceversa) e, sempre a

titolo di esempio, nel caso di caratteri, che questi siano ordinati
alfabeticamente.
Negli esempi seguenti, per semplicità, assumeremo di voler ordinare
un array di interi in senso crescente; cioè dal più piccolo al più
grande.

Selection Sort
Il selection sort (ordinamento per selezione) è uno degli algoritmi
di questo genere tra i più classici.
Esso prevede la seguente operatività.
Si cerca all’interno del vettore l’elemento più piccolo e lo si pone in
prima posizione.
Successivamente, a partire dalla seconda posizione si cerca il più
piccolo e lo si pone in seconda posizione.
Si procede in questo modo, fin quando l’intero vettore non risulta
ordinato. In buona sostanza si selezionano (da cui il nome
dell’algoritmo) di volta in volta gli elementi che devono essere
collocati nella loro posizione definitiva.
Di seguito vi propongo una possibile implementazione del codice:
#include <stdio.h>
#include <stdlib.h>
#define N 5
int main(int argc, char *argv[])
{
int a[N] = {9, 5, 1, 3, 2};
int i, j, temp;
for (i=0; i <= N - 2; i++)
{
for (j=i+1; j <= N - 1; j++ )
{
if (a[j] < a[i])
{
temp = a[i];
a[i] = a[j];
a[j] = temp;
} /* fine if */
} /* fine for j */
} /* fine for i */
/* Stampo array finale */
for (i=0; i < N; i++)
{
printf ("%3d", a[i]);
}
printf ("\n");

system("PAUSE");
return 0;
}

Il tutto si articola attraverso due cicli nidificati; quello più esterno
sposta l’attenzione sulla posizione in cui verrà inserito l’elemento più
piccolo ricercato e individuato in un dato momento. Ovviamente si
tratta dell’indice i.
Tale indice lo facciamo variare da 0 fino al penultimo elemento
dell’array che abbiamo indicato con N - 2. Infatti, N è la dimensione
dell’array e quindi, poiché l’indice parte da zero, N - 1 è l’ultimo
elemento e di conseguenza N – 2 è il penultimo. Il motivo per cui ci
fermiamo al penultimo elemento è dato dal fatto che nell’ultima
iterazione confronteremo appunto il penultimo elemento con l’ultimo
gestito dal secondo indice.
Il ciclo più interno (indice j), infatti, esamina tutte le posizioni a
partire da quella successiva all’elemento corrente (tale elemento
corrente ha indice i) fino alla fine dell’array, cercando l’elemento
restante più piccolo. Una volta individuato tale elemento,
quest’ultimo va a sostituire tramite uno scambio l’elemento corrente
di indice i. Il cuore del controllo e del relativo scambio di posizioni è
il seguente:
if (a[j] < a[i])
{
temp = a[i];
a[i] = a[j];
a[j] = temp;
}

Tornando all’ultima iterazione, si vede come l’indice i, gestito dal for
esterno, varrà N - 2 mentre l’indice j, gestito dal for interno, varrà N –
1 confrontando in tale ultimo passo, come ci aspettiamo che sia, il
penultimo e l’ultimo elemento.
Lo scambio dei valori avviene, come di consueto in questi casi,
utilizzando una variabile temporanea che impedisce la sovrascrittura
di uno dei due valori. Tale variabile temporanea prende anche il
nome tecnico di variabile tampone.
Infatti, l’istruzione cardine che viene eseguita nel caso in cui risulti
a[j] < a[i], cioè se l’elemento corrente scandito nel for interno è

minore di quello individuato al passo precedente e dobbiamo quindi
operare uno scambio, è la seguente:
a[i] = a[j];

cioè mettiamo il valore di a[j] in a[i]. Ovviamente per completare lo
scambio dobbiamo prendere il valore che era in a[i] e porlo in a[j].
Questo è il motivo per cui preventivamente avevo scritto:
temp = a[i];

salvando tale valore (altrimenti sovrascritto da quello di a[j]) per poi
poterlo infine inserire in a[j] scrivendo, come ultima istruzione per lo
scambio di variabili:
a[j] = temp;

Tale operazione di scambio prende il nome inglese di swap o anche
swapping.
Man mano che si procede si nota come il vettore si divida in due
sezioni: la prima contenente gli elementi già ordinati e una seconda
sezione in cui vi sono gli elementi che devono essere ancora
ordinati.
Il selection sort è un ordinamento a cicli fissi in quanto,
indipendentemente dal contenuto (più o meno già parzialmente
ordinato), se il vettore è lungo N verranno eseguiti N-1 cicli di
controllo.
Tuttavia, tale algoritmo trova un’ideale applicazione nel caso in cui
l’operazione di spostamento sia molto gravosa. Mi spiego meglio:
supponendo che gli elementi da spostare non siano dei semplici
numeri ma bensì dei blocchi di dati molto grossi, l’operazione più
dispendiosa risulterebbe essere lo spostamento dei dati piuttosto
che la verifica dell’ordinamento del singolo blocco di dati. Ebbene, è
possibile fare in modo che il selection sort, con una piccola modifica
al codice proposto, effettui lo spostamento di un blocco una e una
sola volta risultando efficiente nel contesto citato.
Per farlo, nel for più interno, invece che eseguire lo spostamento
ogni volta che troviamo un elemento minore, memorizziamo in
un’apposita variabile la posizione j di tale elemento man mano

individuato. Solo quando, per una data posizione i abbiamo scandito
tutti gli elementi a essa successivi, effettuiamo realmente lo scambio
di elementi. Il codice sarà dunque il seguente:
#include <stdio.h>
#include <stdlib.h>
#define N 5
int main(int argc, char *argv[])
{
int a[N] = {9, 5, 1, 3, 2};
int i, j, temp, min;
for (i=0; i <= N - 2; i++)
{
/*
memorizzo in min l'indice della posizione i che
all'inizio dell'iterazione contiene il valore minore
*/
min = i;
for (j=i+1; j <= N - 1; j++ )
{
if (a[j] < a[min])
{
/*
poiché la posizione j ha un valore inferiore a
quello della posizione i
memorizzo tale posizione j nella variabile min*/
min = j;
} /* fine if */
} /* fine for j */
/*alla fine del controllo interno su j inverto la
posizione i con quella relativa a min*/
temp = a[i];
a[i] = a[min];
a[min] = temp;
} /* fine for i */
/* Stampo array finale */
for (i=0; i < N; i++)
{
printf ("%3d", a[i]);
}
printf ("\n");
system("PAUSE");
return 0;
}

Bubble sort
Il bubble sort (ordinamento a bolle) è un altro tipico metodo per
l’ordinamento di un array. Questo approccio è sostanzialmente
opposto al selection sort: si procede individuando man mano
l’elemento più grande e lo si pone di volta in volta nella posizione
immediatamente successiva fino a spostarlo in fondo all’array.
Infatti, si confrontano gli elementi a coppie, ogni elemento con il suo
successivo e nel caso in cui l’elemento verificato sia maggiore di
quello successivo si effettua uno scambio di posizione. Questi
scambi si verificano finché l’elemento maggiore non si sposta
nell’ultima posizione a destra nel vettore; ciò avviene già alla fine
della prima iterazione.
Il nome, ordinamento a bolle, è dato proprio da questa situazione.
Gli elementi più grandi si spostano verso l’alto come avviene per
delle bollicine d’aria in un bicchiere colmo di acqua (o, se preferite, di
spumante).
Di seguito il codice:
#include <stdio.h>
#include <stdlib.h>
#define N 5
int main(int argc, char *argv[])
{
int a[N]={3, 4, 1, 5, 2};
int i, j, temp;
for(i=1; i<N; i++)
{
for(j=0; j<N-i; j++)
{
if(a[j]>a[j+1])
{
temp = a[j];
a[j] = a[j+1];
a[j+1] = temp;
} /* fine if */
} /* fine for j */
} /* fine for i */
for(i=0; i<N; i++)

{
printf("%d ",a[i]);
}
printf("\n");
system("PAUSE");
return 0;
}

Anche in questo caso abbiamo ovviamente due cicli nidificati. Il
primo, gestito tramite il classico indice i che varia da i=1 fino ad i<N .
Fissato l’elemento di indice i, la procedura, grazie al ciclo interno
con j, confronta sempre, a coppie, tutti gli elementi a partire dal
primo (indice j=0) fino ad arrivare a un passo dall’ultimo già in
posizione definitiva.
Più in dettaglio, supponendo per semplicità di avere solo cinque
elementi nell’array, alla prima iterazione si confronta il primo con il
secondo, il secondo con il terzo, il terzo con il quarto e il quarto con il
quinto. Infatti, il for interno varia da j = 0 a j = N – i, cioè alla prima
iterazione j = 5 – 1 = 4 (ovvero l’ultima posizione dell’array).
Alla seconda iterazione si confronteranno il primo elemento con il
secondo, il secondo con il terzo e il terzo con il quarto. E ci fermiamo
qui, non effettuando confronti con l’ultimo elemento in quanto in tale
posizione già sarà presente il valore maggiore individuato e
posizionato durante l’iterazione precedente. La procedura continua
così fino all’ordinamento totale dell’array.

11
Soluzioni semplici a problemi
complessi: le funzioni
L’istruzione

alla

scienza

del

computer non può rendere chiunque
un programmatore esperto più di
quanto lo studio dei pennelli e dei
colori possa rendere qualcuno un

pittore esperto.
Eric Steven Raymond
Un problema algoritmico, a meno che non consista nel “salutare il
mondo” o amenità simili, è in generale qualcosa di abbastanza
complesso.
Credo sia il caso di ammettere che non esiste un metodo universale
che indichi la strada per risolvere un determinato problema; molto è
demandato all’esperienza e alla “sensibilità” del programmatore.
Tuttavia è pur sempre possibile individuare una serie di strategie che

semplificano l’approccio al problema e permettono a volte di salvare
la stabilità mentale del programmatore stesso.

Approccio Top-Down alla
programmazione
Un approccio che si mostra valido in diverse situazioni consiste
nell’individuare nella globalità del problema una serie di elementi o
porzioni che lo compongono.
Tale metodologia prende spesso il nome di approccio Top-Down
(dall’alto al basso o, se meglio credete, dal generale al particolare)
e consiste nell’approcciare il problema individuando nella sua
generalità una serie di elementi più semplici da risolvere; tali
elementi sono spesso chiamati sottoproblemi.
Nella letteratura informatica questo tipo di approccio allo sviluppo
software prende anche il nome di divide et impera. Questa
espressione, di derivazione latina, letteralmente significa “dividi e
comanda” e originariamente era una strategia utilizzata dagli antichi
romani per mantenere sotto il proprio dominio grandi ambiti
territoriali riuscendo a frammentarli e quindi a meglio controllarli.
Lungi da noi voler fare guerra ad alcuno, sfruttiamo tale metodologia
per separare i singoli problemi per meglio controllarli. Con tale modo
di procedere, infatti, si riescono a isolare i dettagli implementativi in
una sorta di “scatola nera” (una per ogni sottoproblema) della quale,
alla fine, ci si deve preoccupare solo di come utilizzarla e non della
sua più intima natura interna (e così facendo rispettiamo anche la
privacy del sottoproblema).
In generale, nel gergo informatico le implementazioni di tali
sottoproblemi prendono il nome di procedure e funzioni.

Procedure e funzioni
Si definiscono procedure quelle scatole nere che hanno il compito
di svolgere determinate istruzioni ma che non devono restituire a chi
le ha chiamate nessun valore; vengono definite funzioni quelle
scatole nere che, oltre a svolgere il loro bravo compitino, si
preoccupano di restituire a chi le ha chiamate un valore di ritorno.
Tale valore può tanto contenere il risultato stesso dell’elaborazione
quanto il fatto di essere riuscito nel compito assegnato, oppure una
sorta di dichiarazione di fallimento.
Ehm, mi sto chiedendo se sono stato abbastanza chiaro. Allora,
giusto per non sapere né leggere né scrivere, vediamo di fare un
esempio possibilmente chiarificatore.
Immaginiamo di dovere scrivere un programma che gestisca
un’agenda telefonica. Dobbiamo essere quindi in grado di trattare
un certo insieme di nominativi con i relativi numeri telefonici.
Scomponendo il problema in sottoproblemi ci rendiamo conto di
dovere gestire una serie di operazioni più elementari che consistono
nell’inserimento, nella modifica e nella cancellazione di un
nominativo. Tali sottoproblemi saranno gli stessi indipendentemente
dallo specifico nominativo; potremmo quindi creare una procedura:
inserisci(nominativo, numero_telefono)

che prende in input il nominativo e il relativo numero telefonico e li
salva su disco;
un’altra procedura:
cancella(nominativo)

che ovviamente si preoccuperà di eliminare il nominativo dal
sistema; e infine una funzione di modifica:
modifica(nominativo, numero_telefono) -> 0/1

che restituisce 0 (zero) in caso di successo e 1 (uno) nel caso in cui
l’operazione fallisca (ad esempio perché il nominativo indicato non

esiste).
Ok, cominciamo a fare sul serio e a essere quindi ancora più
specifici. Tanto per cominciare, nel caso del linguaggio C non si fa
distinzione di terminologia tra procedure e funzioni (come avviene
invece per altri linguaggi, come ad esempio per il Visual Basic). Si
parla di funzioni sia che queste restituiscano valori sia che non lo
facciano.

Dichiarazione e definizione di una
funzione
Così come per le variabili, anche per le funzioni è necessario
effettuare una loro dichiarazione prima di poterle utilizzare. In realtà
ciò che può succedere in caso di mancata dichiarazione dipende dal
compilatore e dalle sue opzioni. In ogni caso è fondamentale
effettuare sempre una dichiarazione preventiva della funzione
stessa.
La sintassi generale per la dichiarazione di una funzione è:
tipo_di_dati_restituito nome_funzione
(elenco_dei_tipi_dei_parametri);

Tale dichiarazione deve essere posta prima del main e prende anche
il nome di prototipo della funzione. Un parametro è appunto un
valore che deve essere passato alla funzione nel momento in cui
questa viene chiamata per essere eseguita.
Veniamo ora alla definizione della funzione. Tale sezione può
essere inserita in un qualsiasi punto del codice che sia esterno al
main e spesso è collocata in file differenti per meglio organizzare e
quindi gestire l’intero programma. Tale sezione contiene banalmente
il codice da eseguirsi per risolvere lo specifico problema.
tipo_di_dati_restituito nome_funzione
(dichiarazione_dei_parametri)
{
istruzioni;
return risultato_della_funzione;
}

Come potete notare dal template (ovvero il modello, lo scheletro) di
funzione che vi ho proposto, il corpo della funzione stessa, ovvero
l’insieme di istruzioni che la compongono, è racchiuso tra una coppia
di parentesi graffe e viene utilizzata una specifica istruzione di nome
return per restituire il risultato prodotto dal codice della funzione in
questione. Il nome della funzione viene seguito da una lista dei

parametri, se ve ne sono, racchiusi tra parentesi tonde. Questi
parametri, così come quelli utilizzati nella dichiarazione della
funzione, vengono spesso definiti parametri formali. L’appellativo di
formale viene utilizzato per distinguere questi parametri dai valori
veri e propri passati alla funzione durante l’esecuzione del codice.
Questi ultimi vengono infatti definiti come parametri attuali o più
semplicemente argomenti della funzione.

Nessun input, nessun output
Nel caso in cui non vi siano valori da restituire, quindi nel caso di una
vera e propria procedura, si usa la parola chiave void. Non a caso
void in inglese significa nullo, vuoto. Vediamo allora, finalmente, un
esempio concreto che per semplicità si riferisce all’uso di una
funzione che non restituisce valori. Per rendere il tutto ancora più
semplice, almeno inizialmente, supponiamo che tale funzione non
debba nemmeno gestire valori in input.
Supponiamo di dover richiamare di tanto in tanto all’interno del
nostro codice il titolo del nostro programma. Mi si perdoni la continua
megalomania, il programma si potrebbe chiamare “Carlo 1.0” e un
possibile banner da utilizzarsi per rendere l’aspetto dello stesso più
accattivante potrebbe essere realizzato come segue:
#include <stdio.h>
#include <stdlib.h>
int main(int argc, char *argv[])
{
printf(" #####
###
\n");
printf(" #
#
##
##### #
####
# \n");
printf(" #
# # #
# #
#
#
# \n");
printf(" #
#
# #
# #
#
#
# \n");
printf(" #
###### ##### #
#
#
# \n");
printf(" #
# #
# #
# #
#
#
# \n");
printf(" ##### #
# #
# ###### ####
###
\n");

#
##

#

# #

#

#

#

#

### #

#

###

#

##### ###

system("PAUSE");
return 0;
}

Supponiamo allora che tale banner debba essere richiamato più

volte all’interno del programma. Senza l’uso delle funzioni dovremmo
ricopiare la serie di printf tutte le volte in cui sarà necessario
ristampare a video il banner. L’ovvia conseguenza è un’inutile
ridondanza (ovvero ripetizione) delle stesse istruzioni con la
conseguente difficoltà di gestire eventuali modifiche al banner
stesso.
Per risolvere il problema creiamo una specifica funzione che
contiene le istruzioni di stampa del banner in questione:
#include <stdio.h>
#include <stdlib.h>
void banner (void); /* dichiarazione funzione */
int main(int argc, char *argv[])
{
banner();
/* qui richiamo il banner */
system("PAUSE");
return 0;
}
void banner (void)
{
printf(" #####
###
\n");
printf(" #
#
##
##### #
####
# \n");
printf(" #
# # #
# #
#
#
# \n");
printf(" #
#
# #
# #
#
#
# \n");
printf(" #
###### ##### #
#
#
# \n");
printf(" #
# #
# #
# #
#
#
# \n");
printf(" ##### #
# #
# ###### ####
###
\n");
}

#
##

#

# #

#

#

#

#

### #

#

###

#

##### ###

Vediamo di capire cosa abbiamo realizzato. All’esterno del main ho
dichiarato la funzione banner che non restituisce valori (prima del
nome ho infatti scritto void) e non prende in input valori (all’interno
della parentesi tonde, dopo il nome della funzione, ho scritto
nuovamente void).
All’interno del main, dove prima avevo riportato le singole istruzioni

per la stampa del banner, inserisco ora semplicemente la chiamata
alla funzione, riportandone il nome seguito dalle parentesi tonde e
dal punto e virgola (si tratta pur sempre di un’istruzione).
All’esterno del main, in coda a esso, ho posto l’implementazione
vera e propria della funzione.
Tiriamo dunque le somme. In buona sostanza i due programmi, il
primo che non utilizza la funzione e il secondo appena visto che ne
fa uso, fanno esattamente la stessa cosa. Tuttavia, isolare all’interno
della funzione la stampa del titolo ci consente di richiamare tale
stampa in ogni momento in cui necessitiamo di visualizzare il titolo
stesso con, inoltre, il grande vantaggio per il quale nel momento in
cui vogliamo modificare tale titolo, lo possiamo fare in un unico e
specifico punto del codice.

Input sì, output no
Caliamoci ora in una situazione diversa, supponendo di avere la
necessità di inserire all’interno del nostro programma, di tanto in
tanto, delle righe vuote. Di norma tale inserimento aiuta la leggibilità
dell’output a video e lo si realizza inserendo all’interno di una o più
printf la combinazione ‘\n’.
Ad esempio, ipotizzando di dover inserire tre linee vuote potremmo
scrivere:
printf("\n\n\n");

oppure, ottenendo lo stesso risultato:
printf("\n");
printf("\n");
printf("\n");

Teoricamente, ogni volta che ne abbiamo bisogno, possiamo inserire
le printf specifiche per il numero di linee che ci occorre inserire in
quel dato contesto. Tuttavia possiamo gestire la cosa in maniera
molto più elegante ed efficiente creando una specifica funzione che
prende in input il numero di linee che si vogliono inserire e che
stampa, in accordo a tale numero, la corrispondente sequenza di
caratteri '\n'.
Vediamo come:
#include <stdio.h>
#include <stdlib.h>
void n_linee (int);
int main(int argc, char *argv[])
{
/* inserisco 5 linee */
n_linee(5);
/* inserisco 2 linee */
n_linee(2);
/* inserisco 5 linee */
n_linee(5);
system("PAUSE");

return 0;
}
void n_linee (int n)
{
int i;
for (i=1; i <= n; i++)
{
printf("\n");
}
}

Cominciamo con l’analizzare la dichiarazione della funzione:
void n_linee (int);

Come potete facilmente osservare, la funzione, che ho chiamato
n_linee, non restituisce valori: abbiamo infatti indicato void prima del
suo nome. Essa prende invece in input un intero; ho infatti inserito la
parola chiave int all’interno delle parentesi tonde, dopo il nome della
funzione stessa.
Osserviamo ora l’implementazione della funzione la cui prima riga è:
void n_linee (int n)

Tale riga è molto simile alla dichiarazione con almeno due differenze
basilari. Innanzitutto non termina con un punto e virgola al contrario
della dichiarazione della funzione. Ciò fa capire al compilatore che si
tratta di un blocco di codice da eseguirsi in un unico contesto. Infatti,
la riga in questione è seguita da una coppia di parentesi graffe che
contiene il codice della funzione stessa.
L’altra cosa da notare è il fatto che all’interno delle parentesi tonde,
dopo il nome della funzione, abbiamo ora aggiunto, oltre al
qualificatore int, anche una specifica variabile, nel caso in esame n.
Tale variabile assumerà di volta in volta il valore passato attraverso
le chiamate alla funzione poste all’interno del main; la prima volta il
valore 5, la seconda il valore 2 e la terza ancora il valore 5. Fate
attenzione al fatto che tale variabile n risulta dichiarata nella
definizione della funzione e che NON deve essere dichiarata
nuovamente nel corpo della funzione stessa. Nel corpo della
funzione, al contrario, dichiariamo una variabile contatore che ci
serve nel ciclo for che banalmente stamperà il numero di qualificatori

'\n' passati alla funzione dalla variabile n.

Input e output nella stessa funzione
Di seguito vi mostro un classico esempio di utilizzo di una funzione: il
calcolo della potenza di un numero. La nostra funzione, che con
somma originalità chiamiamo potenza, prende in input due interi, il
primo per la base e il secondo per l’esponente e restituisce
ovviamente un intero.
#include <stdio.h>
#include <stdlib.h>
/* Dichiarazione della funzione potenza
che prende in input due interi e restiuisce un intero */
int potenza(int, int);
int main(int argc, char *argv[])
{
int b, e;
printf("Inserisci la base: ");
scanf("%d", &b);
printf("Inserisci l'esponente: ");
scanf("%d", &e);
printf("La potenza con base %d ed esponente %d vale %d \n",
b, e, potenza(b, e));
system("PAUSE");
return 0;
}
/* implementazione funzione potenza */
int potenza(int x, int n)
{
int i;
int p = 1;
for (i=1; i<=n; i++)
{
p = p*x;
}
return p;
}

Come si può facilmente notare il main include un paio di scanf con la
richiesta dei parametri da passare alla funzione il cui risultato sarà
stampato direttamente nel punto di chiamata della funzione.

Vi propongo ora una modifica dell’esempio in esame.
Supponiamo di voler stampare in successione le potenze con base 2
aventi come esponenti i primi N numeri naturali. Ad esempio:
1

2

3

4

N

2 , 2 , 2 , 2 , …, 2

Lo scopo che mi propongo è quello di rendere palese l’importanza di
racchiudere in un unico pezzo di codice la risoluzione di un problema
più volte ricorrente all’interno di un programma.
/* CALCOLA LA SERIE DI POTENZE CON BASE 2 AVENTI COME ESPONENTE
I PRIMI N NUMERI NATURALI */
#include <stdio.h>
#include <stdlib.h>
/* dichiarazione della funzione potenza
che prende in input due interi e restiuisce un intero */
int potenza(int, int);
int main(int argc, char *argv[])
{
int n, i;
printf("\nInserisci il numero N: ");
scanf("%d", &n);
if (n < 0)
{
printf("\nIl numero non può essere negativo!");
return;
}
for (i=1; i<=n;i++)
{
printf("Potenza base %d esponente %d = %d \n", 2, i,
potenza(2, i));
}
system("PAUSE");
return 0;
}
/* implementazione funzione potenza */
int potenza(int x, int n)
{
int i;
int p = 1;
for (i=1; i<=n; i++)
{
p = p*x;
}
return p;

}

Spero vi stiate abituando a leggere e interpretare autonomamente il
codice. Nel caso specifico osservate come chiediamo all’utente il
numero n relativo alla lunghezza della sequenza di potenze. Rispetto
a tale numero effettuiamo un banale controllo per accertarci del fatto
che esso non sia negativo.
Successivamente usiamo tale n come limite superiore nel for, il quale
provvederà a generare la serie di potenze con base 2. Il ciclo in
questione si basa su di un indice di nome i che usiamo all’interno
della printf come valore variabile per l’esponente delle potenze in
oggetto, come segue:
potenza(2, i)

dove il valore 2 è ovviamente costante.

La visibilità delle variabili
Fin quando non si utilizzano le funzioni il problema relativo alla
“visibilità delle variabili” non si pone. Mi spiego meglio: una
variabile, per poter essere utilizzata, deve appartenere (essere
dichiarata) all’interno del main del nostro programma. Si dice in gergo
tecnico che la variabile è visibile all’interno del main o, usando la
terminologia inglese, si parla di scope della variabile.
Ma cosa succede nel momento in cui andiamo a utilizzare altre
funzioni e dichiariamo al loro interno specifiche variabili,
eventualmente con nomi uguali? Ebbene, ogni variabile (anche se
con lo stesso nome) è un oggetto distinto e unico. Tali variabili
prendono il nome di variabili locali o anche variabili automatiche.
L’appellativo di locali lo si spiega con il fatto che esse hanno visibilità
solo relativamente alla funzione nella quale sono state dichiarate e
perdono il loro valore quando l’esecuzione esce dalla funzione
stessa. Per intenderci, il valore di una variabile tra due chiamate
successive a una data funzione non verrà conservato ma verrà
semplicemente distrutto. Per certi aspetti è come se la variabile
morisse all’uscita di una data funzione ed è per questo che si parla
di tempo di vita o anche ciclo di vita di una variabile.

Le variabili esterne
Spesso è necessario avere dei valori che siano condivisi da differenti
funzioni. In questi casi si può ricorrere alla possibilità di dichiarare
tali variabili all’esterno di qualsiasi funzione. Questa posizione le
rende appunto variabili esterne visibili da tutte le altre funzioni che
possono così accedere ai loro valori ed eventualmente modificarle.
Per poter esplicitare alle funzioni che fanno utilizzo di variabili
esterne che queste sono effettivamente di tale specie, è necessario
dichiarare nuovamente la variabile, all’interno della funzione,
anteponendo la parola riservata extern.
Osservate a tal proposito il seguente pezzo di codice:
#include <stdio.h>

#include <stdlib.h>
int var = 0;
void incrementa(void);
int main(int argc, char *argv[])
{
printf("Prima della chiamata: %d\n", var);
incrementa();
printf("Dopo la chiamata: %d\n", var);
system("PAUSE");
return 0;
}
void incrementa(void)
{
extern int var;
var = var + 1;
return;
}

La variabile var viene dichiarata all’esterno del main e quindi risulta
appunto essere esterna. La funzione incrementa(), che aumenta di
una unità il valore della variabile, dichiara nuovamente al suo interno
la stessa variabile con la dicitura extern.
extern int var;

segnalando in buona sostanza che non si tratta di una variabile
locale alla funzione ma di un’altra variabile già dichiarata, appunto
esternamente, alla funzione stessa.
Sebbene in alcuni casi tale dichiarazione sia facoltativa è buona
norma utilizzarla sempre. Nel caso in cui il codice del programma sia
suddiviso su più file, l’utilizzo della parola chiave extern è addirittura
obbligatorio.
Si ribadisce come l’uso delle variabili esterne possa risultare
un’alternativa all’uso degli argomenti delle funzioni. Infatti, nel nostro
esempio, la funzione incrementa viene utilizzata con la parola chiave
void sia per il parametro di input che per quello di output,
trasformando di fatto la funzione in una procedura. Il senso è che di
norma, invece, per condividere i dati tra più parti del programma tali
dati devono essere passati alle funzioni come argomenti delle
funzioni stesse.
Vi devo comunque avvertire del fatto che eccedere con l’uso delle

variabili esterne può comportare la creazione di programmi difficili da
manutenere e più esposti al possibile inserimento di bug.

La classe di memorizzazione statica
È banale la considerazione relativa al fatto che lo stato che
acquisiscono le variabili, e quindi il valore che esse assumono
durante la loro vita, è indispensabile per un corretto funzionamento
dei “mondi” che andiamo a creare. Lo scambio di valori e il relativo
controllo è un aspetto critico della programmazione sia se si
utilizzano variabili esterne sia se i valori vengono condivisi come
argomenti tramite chiamate di funzioni.
A volte, ad esempio, si desidera che una funzione riesca a
conservare lo stato di una certa variabile gestita al suo interno senza
che questa muoia alla fine dell’esecuzione della funzione stessa.
Ovviamente, come appena visto, è possibile utilizzare una variabile
esterna che ne preservi il valore. Esiste, tuttavia, un’altra possibilità,
che è quella di utilizzare una specifica classe di memorizzazione
delle variabili, nota come statica, che preserva il valore di tali
variabili indipendentemente dalla vita delle funzioni che le utilizzano
senza essere a esse esterne.
Per comprendere meglio i termini del problema, supponiamo di voler
gestire una funzione che funga da contatore. Tale funzione dovrà
incrementare il suo stato, realizzato tramite un banale numero intero,
di un’unità ogni volta che viene invocata la funzione in questione.
Vediamo cosa succede con una prima bozza del codice:
#include <stdio.h>
#include <stdlib.h>
int tictac(void);
int main(int argc, char *argv[])
{
int i;
printf("Il mio contatore\n\n");
for (i=1; i<=10; i++)
{
printf("%d\n", tictac());
}
printf("\n");

system("PAUSE");
return 0;
}
int tictac(void)
{
int x = 0;
x = x + 1;
return x;
}

Come si può facilmente notare, la funzione, che abbiamo chiamato
tictac, gestisce una sua variabile interna x che serve a memorizzare
lo stato del contatore stesso. A ogni chiamata incrementiamo il
valore di tale variabile di un’unità. Anche se buttate un occhio
distratto all’implementazione della funzione in questione, vi
renderete conto che essa non può lavorare correttamente. Infatti, a
ogni chiamata il valore di inizializzazione della variabile contatore x,
che poniamo a zero, andrà a resettare la variabile stessa
immediatamente prima che questa venga incrementata. Il risultato
del fiasco del nostro codice lo potete osservare nella Figura 11.1
dove è ovvia la presenza di una sequenza di numeri uno.

Figura 11.1 – L’output della prima versione, non funzionante, del
programma contatore.
Chiarito il contesto nel quale ci muoviamo, vi presento una possibile
soluzione che è alternativa all’uso di variabili esterne oppure al
passaggio di valori tramite argomenti di funzione: la parola chiave
static.

Con tale parola chiave, anteposta alla classica dichiarazione della
nostra variabile, definiamo appunto tale variabile come statica: ciò
farà incredibilmente in modo che il valore di questa variabile venga
preservato (ovvero conservato) tra chiamate successive.
L’implementazione della funzione cambia dunque come segue:
int tictac(void)
{
static int x = 0;
x = x + 1;
return x;
}

dove l’unica modifica riguarda in effetti l’aggiunta della parola chiave
static prima di int x = 0;
Il risultato è visibile nella Figura 11.2.

Figura 11.2 – L’output della seconda versione del programma
contatore.
Una considerazione finale riguarda la possibilità di utilizzare la
parola chiave static rispetto a una variabile esterna. In questo caso
si rende possibile preservare il valore di tale variabile da possibili
modifiche non previste in altri moduli del programma.

12
La ricorsione e le funzioni
ricorsive
L’iterazione è umana, la ricorsione
divina.
L. Peter Deutsch
Non si fa in tempo a imparare un concetto che se ne presenta
immediatamente uno nuovo con il quale confrontarsi. Abbiamo
appena capito come gestire e utilizzare le funzioni; esiste, tuttavia,
un modo molto particolare di utilizzo delle funzioni stesse: fare in
modo che una funzione richiami ripetutamente se stessa per
produrre un risultato complesso. Tale situazione prende il nome di
ricorsione.
Per comprendere tale comportamento inizio con il presentarvi il più
classico degli esempi: il fattoriale di un numero.

I numeri fattoriali
Vediamo innanzitutto con una definizione informale cosa si intende
per fattoriale:

Se il numero è minore di zero, rifiutalo. Se non è un
numero intero, rifiutalo.
Se il numero è zero, il relativo fattoriale è 1. Se il
numero è maggiore di zero, moltiplicalo per il
fattoriale del suo predecessore.
Per indicare che abbiamo a che fare con il fattoriale di un dato
numero n scriviamo n!, ovvero scriviamo il numero seguito dal
simbolo di punto esclamativo.
Per cui per il numero 3 fattoriale scriviamo:
3! = 3 x 2! = 3 x 2 x 1! = 6

Ma noi siamo informatici: una definizione informale non ci basta, per
cui diciamo che: in matematica, se n è un intero positivo, si definisce
n fattoriale e si indica con n! il prodotto dei primi n numeri interi
positivi. In formule:
n! = n·(n-1)·(n-2)· … ·2·1

Per definizione si pone poi 0!=1. Questa impostazione si accorda con
la richiesta che il prodotto di zero fattori, il cosiddetto prodotto vuoto,
come la potenza nulla di un intero positivo, sia uguale a 1.
Per calcolare il fattoriale di un numero maggiore di zero è quindi
necessario calcolare il fattoriale di almeno un altro numero. Per poter
eseguire la funzione sul numero corrente, è prima necessario che la
funzione esegua una chiamata a se stessa per ottenere il successivo
numero più piccolo. Questo è un esempio di ricorsione.
A proposito di esempi, vi propongo l’implementazione in C del
calcolo del fattoriale.

#include <stdio.h>
#include <stdlib.h>
long fattoriale(long);
int main(int argc, char *argv[])
{
int n;
printf("Calcolo del fattoriale - Digita un numero naturale:
");
scanf("%d", &n);
printf("Il fattoriale del numero %d e': %ld\n", n,
fattoriale(n));
system("PAUSE");
return 0;
}
long fattoriale(long x)
{
if (x==0)
return 1;
else
return x*fattoriale(x-1);
}

La ricorsione e l’iterazione, o ciclo, sono strettamente correlate.
Infatti una funzione può restituire gli stessi risultati sia con la
ricorsione che con l’iterazione.

In realtà sarebbe possibile creare programmi senza usare
un costrutto esplicito per i cicli. Il linguaggio Lisp, ad
NOTA
esempio, non dispone di un costrutto esplicito di iterazione
come for, while ecc. Esso utilizza, infatti, la sola ricorsione.
Vediamo, allora, come è possibile ottenere il fattoriale di un numero
con una tecnica più classica, ovvero quella iterativa.
#include <stdio.h>
#include <stdlib.h>
int main()
{
int n, i;
long int fatt = 1;
printf("Inserisci un numero : ");

scanf("%d",&n);
for (i = 1; i <= n; i++)
{
fatt = fatt * i;
}
printf("Il fattoriale di %d e' %ld\n", n, fatt);
system("PAUSE");
return 0;
}

In genere, un determinato calcolo si presta in maniera più o meno
naturale a una tecnica o all’altra. Individuare l’approccio più
congeniale è una questione di esperienza e “sensibilità”.
L’utilità della ricorsione è indubbia. Tuttavia essa si presta a
potenziali subdoli problemi.
Può accadere, ad esempio, che la funzione ricorsiva creata non
restituisca un risultato definito in quanto, ad esempio, non è in grado
di raggiungere un punto finale. Tale ricorsione può causare
l’esecuzione di un ciclo infinito da parte del computer.
Supponiamo, ad esempio, di omettere la prima regola, ovvero quella
sui numeri negativi, dalla descrizione verbale del calcolo del
fattoriale e di provare a calcolare il fattoriale di un qualsiasi numero
negativo. Questa operazione non riuscirà in quanto per calcolare, ad
esempio, il fattoriale di -1, è necessario calcolare il fattoriale di -2;
per calcolare il fattoriale di -2, è necessario calcolare il fattoriale di -3
e così via. Questo processo, ovviamente, non raggiungerà mai un
punto finale.
Un altro potenziale problema connesso all’utilizzo della ricorsione è
quello della possibile saturazione di tutte le risorse assegnate al
programma (memoria di sistema, spazio dello stack ecc.). Ogni volta
che una funzione ricorsiva chiama se stessa, o un’altra funzione
dalla quale poi è a sua volta chiamata, utilizza determinate risorse.
In realtà le risorse vengono liberate al termine della funzione
ricorsiva, tuttavia, una funzione con troppi livelli di ricorsione
potrebbe utilizzare tutte le risorse disponibili causando il blocco
dell’applicazione.
Il succo della questione è che la progettazione di funzioni ricorsive
richiede estrema cura e attenzione. Nel caso esista anche la minima

possibilità di ricorsione infinita, oppure eccessiva, è necessario
progettare la funzione in modo che conti il numero di chiamate a se
stessa e impostare di conseguenza un limite per tale numero di
chiamate.
Ad esempio, si può fare in modo che, qualora la funzione chiami se
stessa un numero di volte maggiore di quello definito come limite, la
funzione stessa termini automaticamente, indicando possibilmente
tale avvenimento. Il numero massimo ottimale di iterazioni dipende
dalla funzione ricorsiva ed è ancora una volta demandato
all’esperienza del programmatore.

Ancora ricorsione, Fibonacci
Un altro esempio fondamentale all’interno del contesto delle funzioni
ricorsive è dato dai cosiddetti numeri di Fibonacci. I numeri di
Fibonacci sono una successione di numeri interi (successione di
Fibonacci) molto interessante, all’interno della quale ogni singolo
numero della successione ha come valore la somma dei due numeri
che lo precedono nella successione stessa.
Per convenzione i primi due numeri della successione sono entrambi
uguali a 1. Per cui il terzo numero è dato dalla loro somma 1 + 1 e
quindi vale 2. Il successivo sarà dunque dato da 1+2 e quindi 3 e
così via. I primi numeri della sequenza sono dunque:
1, 1, 2, 3, 5, 8, 13, 21, …

Cerchiamo, come di consueto, di essere più formali e di individuare
delle formule di tipo generico. Definiamo allora quanto segue:
F(i) = 0
se i = 0
F(i) = 1
se i = 1
F(i) = F(i-1) + F(i-2)

se i >= 2

dove i rappresenta il generico numero F della successione. Ovvero
se i vale 0 il corrispondente numero della successione è posto pari a
0 mentre se i vale 1 si impone il valore a 1. Per i maggiore o uguale
a 2 il corrispondente numero nella successione di Fibonacci è dato
dalla somma:
F(i-1) + F(i-2)

cioè dalla somma dei due numeri di Fibonacci che precedono quello
in oggetto nella sequenza.
Ad esempio, per i = 3 abbiamo:
F(i) = F(i-1) + F(i-2) = F(3-1) + F(3-2) = F(2) + F(1) = 1 + 1
= 2

dunque
F(3) = 2

Di seguito vi presento il codice classico di tipo ricorsivo per il calcolo
di un numero generico della sequenza di Fibonacci:
#include <stdio.h>
#include <stdlib.h>
long fibonacci(long);
int main(int argc, char *argv[])
{
int n;
printf("Calcolo numero di Fibonacci - Digita un numero
naturale: ");
scanf("%d", &n);
printf("Il numero di Fibonacci nella posizione %d e':
%ld\n", n, fibonacci(n));
system("PAUSE");
return 0;
}
long fibonacci(long i)
{
if (i == 0)
return 0;
else if (i == 1)
return 1;
else
return fibonacci(i-1) + fibonacci(i-2);
}

13
I puntatori
Chi è convinto che i computer siano
in grado di soppiantare i matematici
non capisce niente né di computer né
di matematica. È come credere che i

biologi non servono più perché sono
stati inventati i microscopi.
Ian Stewart
I puntatori sono uno degli argomenti più importanti e forse anche più
complessi dei linguaggi di programmazione, al punto che alcuni
linguaggi li evitano accuratamente. Non a caso vengono considerati
un modo perfetto per rendere un programma illeggibile per il
programmatore.
Perché mai allora utilizzarli? I puntatori, se ben sfruttati,
rappresentano un’arma eccezionale per scrivere programmi potenti

ed efficienti.

I puntatori
Per comprendere il concetto di puntatore è bene riguardare
l’organizzazione della memoria di un calcolatore. Sappiamo, o
comunque dovremmo sapere, che la memoria di un calcolatore è un
dispositivo realizzato per contenere i dati dell’elaborazione dei nostri
programmi; essa è costituita da una serie di celle (o locazioni)
consecutive. Ogni cella può contenere un certo elemento ed è
identificata da un numero, detto indirizzo. Il concetto di puntatore fa
leva proprio su questo elemento: un indirizzo di memoria può essere
considerato a tutti gli effetti una variabile che cambia il suo valore in
dipendenza dalla cella che individua (punta).

NOTA

Anche se simile a una variabile generica di tipo intero, una variabile
puntatore ha delle specifiche differenze. Ad esempio, non ha senso
considerare puntatori negativi o la divisione di due puntatori.

Un puntatore è quindi un gruppo di celle di memoria (una sola
sarebbe insufficiente) contenente un indirizzo di un’altra cella. Il C
permette di accedere a tale indirizzo, vale a dire localizzare dove la
variabile sia stata effettivamente memorizzata.
Fin quando si gestiscono operazioni che si riferiscono a variabili
presenti in pezzi di codice in cui tali variabili sono “visibili” non esiste
necessità di utilizzare i puntatori. Normalmente, infatti, una variabile
utilizzata all’interno di una funzione vive per il tempo di esecuzione
della specifica funzione ed è visibile (utilizzabile) sono in quella
funzione. Se vogliamo utilizzare una certa variabile anche fuori dalla
funzione di appartenenza dobbiamo conoscere l’indirizzo preciso in
cui essa viene memorizzata: ecco spiegata l’essenza dei puntatori e
la loro importanza!
Come abbiamo imparato, la prima cosa da fare per utilizzare una
variabile è la sua dichiarazione; per dichiarare una variabile
puntatore a un intero procediamo come segue:
int x, y, *pippo;

Nella precedente istruzione abbiamo dichiarato tre variabili; le prime
due, x e y, sono delle classiche variabili intere, la terza *pippo è una
variabile che punta a un intero.
Per far sì che pippo punti a una specifica variabile intera scriviamo:
pippo = &x;

In questo modo abbiamo assegnato a pippo l’indirizzo della variabile
x.
Poniamoci ora il problema di accedere al contenuto della cella
puntata da pippo. Per far questo utilizziamo l’operatore unario *
(detto di indirezione o deferimento) come segue:
y = *pippo;

Con *pippo, infatti, ci riferiamo al contenuto puntato da pippo. In buona
sostanza, con la precedente istruzione abbiamo fatto sì che y sia
uguale al contenuto a cui punta pippo.
Volendo quindi operare sul contenuto di pippo possiamo procedere
come segue:
*pippo= *pippo + 1 ;

avendo incrementato di un’unità il suo contenuto.

Puntatori e array
Voglio ora tornare sul senso di puntatore vero e proprio, inteso come
riferimento a un’area di memoria, facendovi vedere cosa succede
con gli array. Abbiamo visto che un array è una struttura dati
costituita da variabili tutte dello stesso tipo in cui ogni elemento è
identificato da un indice che parte da zero.
Vediamo cosa succede con le seguenti istruzioni:
int vettore[10];
int *indice;
indice = &vettore[0];

Se ci pensate un po’ le istruzioni scritte sono abbastanza semplici.
Ho dichiarato un array di interi, un puntatore a interi e infine ho fatto
sì che il puntatore indice punti al primo elemento dell’array.
In questo modo possiamo selezionare i vari elementi dell’array
agendo sul puntatore; così, le seguenti istruzioni risultano
equivalenti:
vettore[1]=100;
*(indice + 1)=100;

Entrambe pongono il valore 100 nel secondo elemento dell’array
(quello con indice 1). La prima istruzione lo fa con il metodo
“classico”, la seconda agendo sul puntatore: incrementando di
un’unità il puntatore indice ci spostiamo sull’elemento successivo e
con l’operatore * ne indichiamo il contenuto.
Di seguito, per semplicità, vi propongo il codice completo
dell’esempio per darvi una visione d’insieme:
#include <stdio.h>
#include <stdlib.h>
main()
{
int vettore[10]={};
int *indice;
indice = &vettore[0];
/*

Le seguenti due righe di codice danno lo stesso risultato.
Per verificarlo potete commentare alternativamente una delle
due righe,
compilare e verificare il risultato ottenuto a video.
*/
vettore[1]=100;
*(indice + 1)=100;
printf("Test puntatore: %d\n", vettore[1]);
system("pause");
return 0;
}

dove vi ricordo che inizializzando un array con una coppia di
parentesi graffe vuote si ottiene il risultato di porre a zero tutte le
posizioni dell’array stesso.
Attenzione però all’uso delle parentesi nella gestione dei puntatori;
se avessimo scritto in un’istruzione:
*indice + 1

avremmo incrementato di 1 il contenuto del primo elemento (quello
attualmente puntato da indice). Infatti, *indice rappresenta il
contenuto dell’elemento indicato dal puntatore. Per provare tale
espressione in un pezzo di codice possiamo fare riferimento al
seguente:
#include <stdio.h>
#include <stdlib.h>
main()
{
int vettore[10]={};
int *indice;
indice = &vettore[0];
printf("Test puntatore: %d\n", *indice + 1 );
system("pause");
return 0;
}

ottenendo in output la stampa, visibile in Figura 13.1, del valore 1
essendo inizialmente a zero il contenuto dell’array.

Figura 13.1 – Il risultato a video dell’incremento del valore
dell’elemento indicato dal puntatore.
Come risulta abbastanza chiaro, operare con i vettori utilizzando i
puntatori è abbastanza più complesso: tuttavia operando
direttamente sugli indirizzi il tutto risulta sicuramente più veloce.
Il seguente esempio mostra come è possibile gestire una stringa
attraverso un array di caratteri nella maniera standard e con l’uso dei
puntatori.
#include <stdio.h>
#include <stdlib.h>
main()
{
int i=0;
char atest[]= "Ciccio Pasticcio";
char *ptest = "ciccio pasticcio";
printf("Stringa con array\n");
while (atest[i] != '\0')
{
printf("%c", atest[i]);
i++;
}
printf("\n\n");
printf("Stringa con puntatore\n");
while (*ptest != '\0')
{
printf("%c", *ptest);
ptest++;
}
printf("\n\n");
system("PAUSE");
return 0;
}

Esaminiamo allora velocemente il codice appena proposto. In merito
alla gestione con array c’è ben poco da dire essendo una tecnica già

vista in precedenza. Dichiariamo e inizializziamo un semplice array
di caratteri e ne stampiamo il contenuto tramite un ciclo while,
usando come condizione di uscita il raggiungimento del carattere
speciale \0 che indica appunto la fine di una stringa.
In merito alla gestione con puntatori notiamo innanzitutto l’istruzione:
char *ptest = "ciccio pasticcio";

Con tale istruzione definiamo una variabile di tipo puntatore a
carattere e inizializziamo il valore puntato con una stringa di nostro
interesse. La nostra variabile punterà inizialmente, in maniera del
tutto automatica, al primo carattere della sequenza.
Anche in questo caso usiamo un while con una condizione di uscita
che testa l’individuazione del carattere di fine stringa. La verifica la
effettuiamo rispetto al contenuto della variabile puntata tramite la
dicitura *ptest, mentre incrementiamo il puntatore attraverso
l’istruzione ptest++.

Puntatori e funzioni
Per comprendere appieno i puntatori, e al contempo un altro aspetto
“filosofico” del linguaggio C, torniamo un attimo sulle funzioni.
I dati che sono “passati” a una funzione vengono chiamati
argomenti o anche parametri attuali della funzione. Nel momento
in cui essi vengono ricevuti dalla funzione, e quindi elaborati,
prendono il nome di parametri formali della funzione. In linea del
tutto generale vengono definiti parametri.
Il C passa gli argomenti alle funzioni per valore, ciò significa che la
funzione riceve una copia delle variabili e non, quindi, le variabili
originarie. Ciò significa che non c’è modo per la funzione chiamata di
modificare una variabile che si trova all’esterno del suo blocco di
esecuzione. Differente è il caso di altri linguaggi (ad esempio Visual
Basic), che passano i valori alle funzioni per indirizzo
consentendone quindi la modifica anche in punti in cui non
sarebbero direttamente “visibili”.
Ma torniamo al C: l’unico modo che ha una funzione per modificare il
valore di una variabile che sia esterna al suo blocco di esecuzione è
quello di operare sull’indirizzo della variabile stessa, che gli deve
quindi essere passata attraverso un puntatore. Le cose, a questo
punto, dovrebbero cominciare a essere più chiare. Casca a fagiolo
un esempio:
#include <stdio.h>
#include <stdlib.h>
int cambia(int);
int main(int argc, char *argv[])
{
int a=0, b=0;
printf("Il valore di a prima della chiamata e': %d\n", a );
printf("Il valore di b prima della chiamata e': %d\n", b );
b = cambia(a);
printf("Il valore di a dopo la chiamata e': %d\n", a );
printf("Il valore di b dopo la chiamata e': %d\n", b );
system("PAUSE");
return 0;
}

int cambia (int a)
{
a = a+1;
return a;
}

Provando questo esempio si può vedere come il valore della
variabile a non cambi dopo l’esecuzione e al contempo che la
funzione effettua la sua elaborazione in quanto la variabile b risulta
incrementata di un’unità.
Infatti, l’output sarà:
Il valore di a prima della chiamata e': 0
Il valore di b prima della chiamata e': 0
Il valore di a dopo la chiamata e': 0
Il valore di b dopo la chiamata e': 1
Premere un tasto per continuare . . .

Questo a testimonianza del fatto che la funzione riceve, per valore,
una copia della variabile e che quindi il suo effetto è solo relativo a
tale copia e non alla variabile originaria.
Per risolvere il problema della modifica della variabile originaria,
ormai dovrebbe essere chiaro, è necessario agire tramite i puntatori
come mostrato di seguito:
#include <stdio.h>
#include <stdlib.h>
void cambia(int *);
int main(int argc, char *argv[])
{
int a, b, *punt;
punt=&a;
a=0;
printf("Il valore di a prima della chiamata e': %d\n", a );
cambia(punt);
printf("Il valore di a dopo la chiamata e': %d\n", a );
system("PAUSE");
return 0;
}
void cambia (int *x)
{
*x= *x+1;
return;

}

L’output del codice sarà il seguente:
Il valore di a prima della chiamata e': 0
Il valore di a dopo la chiamata e': 1
Premere un tasto per continuare . . .

Ciò è possibile in quanto la funzione cambia prende in input la
variabile puntatore punt che punta alla variabile a e osservando
l’implementazione della funzione potete notare come ciò sia
espresso attraverso l’uso dell’operatore unario asterisco:
void cambia (int *x)
{
...
}

Notate quindi come la funzione al suo interno operi l’incremento sul
valore puntato dalla variabile passata come argomento:
*x= *x+1;

L’eccezione che conferma la regola:
array, funzioni
e passaggio per indirizzo
Come appena evidenziato, il passaggio di una variabile avviene di
norma per valore. Ciò tuttavia non è vero se ci si riferisce al
passaggio di un vettore a una funzione; in questo caso, infatti, il
passaggio avviene per indirizzo. Il seguente esempio, relativo al
confronto tra due stringhe (ovvero array di caratteri) mette in
evidenza le modalità in oggetto.
La seguente funzione strTest prende in input i due array e restituisce
il numero di elementi che differiscono.
#include <stdio.h>
#include <stdlib.h>
int strTest(char[], char[]);
int main(int argc, char *argv[])
{
char a[10]="PippO";
char b[10]="pIppo";
int ret=0;
ret = strTest(a, b);
printf("Differenza tra stringhe: %d\n", ret);
system("PAUSE");
return 0;
}
int strTest(char a[], char b[])
{
int i=0, cont=0;
while ((a[i] != '\0') && (b[i] != '\0'))
{
if (a[i]!=b[i])
{
cont++;
}
i++;
}
return cont;

}

Nel caso specifico, la funzione restituirà il valore 3 in relazione al
fatto che le due stringhe differiscono, per maiuscolo e minuscolo,
nella prima, seconda e quinta posizione.
Ribadisco che quello che si vuole sottolineare in questo contesto è
che il passaggio di un array a una funzione ne implica il passaggio
per indirizzo e quindi la possibilità, da parte della funzione, di agire
direttamente sul contenuto reale dell’array. Consideriamo allora il
seguente codice:
#include <stdio.h>
#include <stdlib.h>
void maschera(char[], int);
int main(int argc, char *argv[])
{
char a[10]="Pippo";
int i;
printf("-Modifica stringa-\n");
printf("%s\n", a);
maschera(a, 0);
for(i=0; i<10; i++)
{
printf("%c", a[i]);
}
printf("\n");
system("PAUSE");
return 0;
}
void maschera(char x[], int pos)
{
x[pos]='X';
}

Nel main dichiariamo e inizializziamo un array di caratteri. Su di esso
richiamiamo la funzione maschera che prende in input l’array stesso e
l’indice della cella in cui andare a effettuare una modifica, ponendo
una X in tale posizione. Come si potrà notare dalla stampa a video
dell’array, effettuata all’interno del main dopo la chiamata della
funzione, la modifica avviene effettivamente sull’array originale e non
su di una copia di esso.
A solo titolo di esempio, la richiesta di modifica della funzione
maschera è relativa alla posizione con indice zero. Potrebbe essere

utile, come esercizio, modificare il codice proposto richiedendo
all’utente con una scanf la posizione in cui apportare la modifica.

Comunichiamo con il programma, il
passaggio
di parametri al main
Tutti i programmi che vi ho mostrato finora, per prelevare un input
dall’esterno, hanno fatto uso di funzioni che prelevavano l’input
dell’utente da tastiera, tipo scanf. Questa pratica è più che sufficiente
nella stragrande maggioranza dei casi; tuttavia, in alcune situazioni,
tale approccio può risultare di scarsa soddisfazione.
Immaginiamo, ad esempio, un programma che conti il numero di
caratteri presenti in un dato file; sarebbe molto più comodo usare il
programma passando sulla “riga di comando” il nome del file sul
quale effettuare il conteggio, piuttosto che farci chiedere il nome del
file stesso.
Cerco di essere più chiaro: supponiamo che il nostro file eseguibile
si chiami mycount.exe; ebbene, sarebbe bello poter invocare il
programma come mostrato nella Figura 13.2.

Figura 13.2 – Il lancio del programma con relativo parametro sulla
riga di comando.
In questo esempio, pippo.txt sarebbe l’argomento passato
direttamente al nostro programma e sul quale verrebbe effettuato il
conteggio dei caratteri.
Per poter utilizzare questo tipo di funzionalità è necessario servirsi
dei parametri argc e *argv[] utilizzando la chiamata alla funzione
main come segue:
int main(int argc, char *argv[])

argc è un intero che rappresenta il numero di parametri passati al

programma mentre argv è un puntatore a un vettore di stringhe
contenenti ognuna un argomento passato al programma.
Nel nostro caso la situazione sarebbe la seguente:
argc = 2
argv[0] = "mycount.exe"
argv[1] = "pippo.txt"

Come esempio vi propongo un programma che stampa, in due
possibili modi diversi, gli argomenti passati sulla riga di comando.
#include <stdio.h>
#include <stdlib.h>
int main(int argc, char *argv[])
{
int i;
printf("argc e': %d\n", argc);
for(i=0; i < argc; i++)
{
printf("Argomento: %s\n", argv[i]);
}
/* oppure */
for(i=0; i < argc; i++)
{
printf("Argomento: %s\n", *argv);
argv++;
}
system("PAUSE");
return 0;
}

14
Le strutture: molti dati e
un’unica variabile
Il software è come l’entropia. È
difficile da afferrare, non pesa nulla, e
obbedisce alla seconda legge della
termodinamica: aumenta sempre.
Norman R. Augustine
Nella risoluzione di numerosissimi tipi di problemi ci si trova spesso
di fronte a singoli elementi che possiedono diverse e differenti
proprietà. Avevamo già affrontato problematiche simili nel Capitolo 8,
nel momento in cui abbiamo verificato la necessità di utilizzare
strutture dati complesse come gli array per superare i limiti imposti
dalle variabili di tipo semplice. Seppur potenti, gli array non possono
risolvere da soli i vari problemi di efficienza che si riscontrano in
situazioni complesse tipiche del mondo reale.

Campi, record e strutture
A puro titolo di esempio potete pensare alla necessità di gestire le
informazioni riguardanti i clienti dei vostri programmi. Pensate un
po’, non riuscite più a gestire l’elenco dei vostri innumerevoli clienti e
vi serve un programma specifico. Il generico cliente dovrà avere
ovviamente associate delle specifiche informazioni, ad esempio, dei
dati anagrafici (nome, cognome) così come altri dati, ipoteticamente
relativi alla propria età (Figura 14.1). Nel contesto informatico una
tale organizzazione di dati prende il nome di record. Le singole
informazioni raccolte nel record prendono il nome di campi.

Figura 14.1 – Ipotetici clienti con le relative proprietà.
Ovviamente l’esempio del cliente è solo uno degli innumerevoli casi
in cui un certo contesto può essere modellato con campi e record.
Un’altra situazione assolutamente classica è quella relativa a un
elenco di libri da catalogare. Ogni singolo libro dovrà essere
contenuto in un record con una serie di campi. Tali campi saranno
qualcosa come titolo del libro, autore, anno di pubblicazione, prezzo
ecc.
Anche solo intuitivamente potete comprendere come il gestire
queste differenti informazioni con variabili separate comporterebbe
numerosi problemi; primo tra tutti la confusione nell’organizzazione
del nostro codice e la relativa difficoltà di manutenzione dello stesso.
Per far fronte a questo tipo di situazioni il linguaggio C mette a
disposizione dello sviluppatore un apposito tipo di dati fondamentale

noto come struttura, gestibile tramite la parola chiave struct. Il
concetto è molto simile a quello relativo a un array: un’unica variabile
con la possibilità di memorizzare differenti valori. La differenza
sostanziale è data dal fatto che i valori gestibili tramite una struct,
contrariamente a quanto avviene con gli array, possono anche
essere di tipo diverso tra di loro.

Figura 14.2 – La rappresentazione concettuale di una struttura con i
relativi campi.
In C per definire una struct si fa seguire a tale parola chiave un nome
scelto dal programmatore (che prende il nome di tag) e, all’interno di
un blocco di parentesi graffe, le differenti variabili utilizzate per
definire le varie caratteristiche del soggetto della nostra definizione;
in buona sostanza, i campi del record. Dopo la chiusura della
parentesi graffa è necessario inserire un punto e virgola per chiudere
la definizione stessa.
In concreto, la dichiarazione di una struttura è qualcosa di questo
tipo:
struct nomeStruttura
{
/* qui vanno i campi */
};

Sempre per concretezza, supponiamo allora di voler definire una
struttura per la gestione del nostro ipotetico cliente. Un approccio
può essere il seguente:
struct persona
{

char nome[20];
char cognome[20];
char indirizzo[30];
int eta;
};

Abbiamo dato alla struttura il nome persona e abbiamo definito al suo
interno quattro campi. Un primo campo per contenere il nome, un
secondo per il cognome e un terzo per l’indirizzo. Tali primi tre campi
sono di tipo array di caratteri. E non potrebbe essere diversamente.
Il quarto campo è invece di tipo intero dovendo contenere l’età del
nostro gentile cliente. Come potete notare i tipi di dati sono differenti,
stringhe e interi, ed è proprio tale contesto a mostrare la “potenza” di
questa struttura dati.
Ovviamente non è sufficiente definire la struttura. Abbiamo bisogno
di una ulteriore riga di codice, successiva alla dichiarazione del
blocco della struct, per “istanziare”, cioè predisporre per l’uso, la
variabile avente le caratteristiche indicate dalla struct. L’istruzione:
struct persona cliente;

definisce quindi la variabile cliente avente le caratteristiche di persona.
Per poter valorizzare e utilizzare le singole proprietà della struttura
(che come detto prendono i nomi tecnici di campi ma anche
membri) è necessario indicare il nome della variabile struttura (nel
nostro caso cliente) seguito da un punto e dal nome del membro di
interesse. Ad esempio per valorizzare il campo cognome potremmo
scrivere:
cliente.cognome = "Mazzone";

mentre per stampare il campo in questione possiamo scrivere:
printf("\nIl cognome e': %s", cliente.cognome);

Di seguito vi presento un esempio completo nel quale metto insieme
le cose dette a proposito delle strutture. Supponiamo di voler gestire
i dati di un cliente, preleviamo da tastiera tali dati, li immagazziniamo
in una struttura e successivamente li stampiamo a video prelevandoli
dalla struttura stessa.

#include <stdio.h>
#include <stdlib.h>
int main(int argc, char *argv[])
{
struct persona
{
char nome[20];
char cognome[20];
char indirizzo[30];
int eta;
};
struct persona cliente;
printf("Nome: ");
gets(cliente.nome);
printf("Cogome: ");
gets(cliente.cognome);
printf("Eta': ");
scanf("%d", &cliente.eta);
printf("\nIl nome e': %s", cliente.nome);
printf("\nIl cognome e': %s", cliente.cognome);
printf("\nL'eta' e': %d\n", cliente.eta);
printf("\n");
system("PAUSE");
return 0;
}

Nell’esempio non utilizziamo il campo indirizzo seppure questo sia
dichiarato all’interno della struttura. Il senso è che non è detto che
dobbiamo per forza di cose utilizzare sempre tutti gli elementi
dichiarati. A volte potrebbe capitare di inserire un dato campo
semplicemente perché si ritiene di doverlo utilizzare per scopi futuri.

Una struttura dentro l’altra
Osservando il codice dell’esempio che vi ho proposto vi invito a
notare l’uso del membro età. Innanzitutto esso è stato scritto senza
l’accento: MAI UTILIZZARE CARATTERI SPECIALI!
In secondo luogo si tratta di una scelta comunque non felice. L’età è
una caratteristica che (ahinoi molto velocemente) cambia con il
passare del tempo. Sarebbe sicuramente più opportuno
memorizzare la data di nascita e calcolare l’età come logica
conseguenza a partire dalla data attuale.
In realtà, anche una data può essere vista come una struttura:
struct data
{
int giorno;
int mese;
int anno;
} nascita;

dove vi faccio notare la possibilità di dichiarare e inizializzare una
variabile di tipo struttura in un solo “colpo” indicandone il nome, in
questo caso nascita, dopo la chiusura della parentesi graffa (prima
del punto e virgola finale).
L’esempio dell’elemento data ci fornisce l’occasione per un’altra
riflessione importante. A rigore la data potrebbe essere gestita
tramite un array. Potremmo infatti dichiarare un array di tre elementi:
il primo elemento per il giorno, il secondo per il mese e il terzo per
l’anno. Qualcosa del genere seguente:
int data[3];

Ovviamente con tale soluzione dovremmo tenere a mente questa
specifica organizzazione e sequenza di attribuzione dei differenti
valori (giorno, mese e anno). Giusto per fare un esempio, nel mondo
anglosassone si utilizza di norma prima il mese e poi il giorno.
L’utilizzo di una struttura è quindi preferibile quando si vuole avere
un controllo più diretto sui singoli elementi di un insieme. Possiamo

quindi dichiarare una struttura per gestire una certa data:
struct data
{
int giorno;
int mese;
int anno;
};

A questo punto possiamo notare come è possibile sostituire il campo
eta, per la gestione dell’età della nostra persona, inserendo al suo
posto la struttura data appena definita:
struct persona
{
char nome[20];
char cognome[20];
char indirizzo[30];
struct data nascita;
};

Il gioco è allora fatto: la struttura data viene a essere incorporata e
gestibile all’interno della struttura persona.
Volendo è possibile inizializzare i campi di una certa struttura a
determinati valori direttamente in fase di dichiarazione:
struct persona Topolino = {"Mickey", "Mouse", "Topolinia",
18,11,1928};

Mettiamo allora tutto insieme per un semplice esempio relativo alla
data di nascita del simpatico Topolino.
#include <stdio.h>
#include <stdlib.h>
int main(int argc, char *argv[])
{
struct data
{
int giorno;
int mese;
int anno;
};
struct persona
{

char nome[20];
char cognome[20];
char indirizzo[30];
struct data nascita;
};
struct persona Topolino = {"Mickey", "Mouse", "Topolinia",
18,11,1928};
printf("La data di nascita di %s %s e': %d/%d/%d ",
Topolino.nome, Topolino.cognome, Topolino.nascita.giorno,
Topolino.nascita.mese, Topolino.nascita.anno );
printf("\n");
system("PAUSE");
return 0;
}

La lunghezza della riga di codice relativa alla stampa dell’esempio
propostovi induce in maniera spontanea a una nota di suggerimento.
Per una maggiore leggibilità del codice all’interno dell’editor, nel caso
di linee troppo lunghe, è possibile usare il carattere ‘\’ backslash per
separare la linea in questione su più righe differenti. Ad esempio:
printf("La data di nascita di %s %s e': %d/%d/%d ", \
Topolino.nome, Topolino.cognome, \
Topolino.nascita.giorno, Topolino.nascita.mese,
Topolino.nascita.anno );

Array di strutture
Ovviamente, con una organizzazione come la precedente, possiamo
gestire i dati di un singolo cliente alla volta. Volendo gestire
contemporaneamente più clienti dovremmo teoricamente dichiarare
tante variabili di tipo struttura quanti sono i clienti. Ad esempio:
struct persona cliente1, cliente2, cliente3;

Si intuisce che l’approccio usato è sicuramente poco funzionale.
Fortunatamente il C consente di dichiarare degli array di strutture.
Possiamo quindi scrivere qualcosa del tipo:
struct persona cliente[10];

dichiarando in tal modo un array composto da 10 elementi di tipo
cliente. Spesso ci si riferisce a un array di strutture con il termine
tabella. Per accedere ai membri cognome e nome del primo cliente
possiamo scrivere quindi qualcosa del tipo:
printf("\nCognome: %s", cliente[0].cognome);
printf("\nNome: %s", cliente[0].nome);

considerando banalmente che l’indice del primo elemento dell’array
di struct è ovviamente zero.
Vediamo allora, come di consueto, un esempio che mette insieme i
vari pezzi. Supponiamo di voler “caricare” (ovvero inserire all’interno
di un sistema software) un certo numero di clienti e quindi di voler
stampare il loro elenco.
#include <stdio.h>
#include <stdlib.h>
#define MAX_CLIENTI 10
int main(int argc, char *argv[])
{
struct data
{
int giorno;
int mese;

int anno;
};
struct persona
{
char nome[20];
char cognome[20];
char indirizzo[30];
struct data nascita;
};
struct persona cliente[MAX_CLIENTI];
int i;
//Inserimento dati
printf("Inserisci i dati dei tuoi clienti\n\n");
for (i=0; i<MAX_CLIENTI; i++)
{
printf("Cliente: %d\n", i+1);
printf("Nome: ");
gets(cliente[i].nome);
printf("Cognome: ");
gets(cliente[i].cognome);
}
//Stampa dati
printf("\nL'elenco dei tuoi clienti e'\n\n");
for (i=0; i<MAX_CLIENTI; i++)
{
printf("\nNome: %s", cliente[i].nome);
printf("\nCognome: %s", cliente[i].cognome);
printf("\n");
}
printf("\n");
system("PAUSE");
return 0;
}

Facciamo allora qualche commento a quanto scritto, anche se ormai
dovreste saper leggere il codice abbastanza semplicemente.
La prima cosa che vi faccio notare è che ho utilizzato una costante
MAX_CLIENTI con la direttiva define per indicare il numero di clienti da
inserire. Questo consente di impostare un valore molto basso, ad
esempio anche solo 2, per testare il codice. Non ha senso inserire
10 elementi con dettagli di nome, cognome e quant’altro per scoprire

che abbiamo fatto un banale errore di formattazione di qualche
ritorno a capo o altri errori di vario tipo. Quando avremo completato il
testing del codice potremo impostare il valore della define a quello
definitivo ed eventualmente fare una prova finale del codice. E
dunque, utilizzando la seguente riga di codice:
struct persona cliente[MAX_CLIENTI];

definisco un array con un numero di elementi pari a MAX_CLIENTI. Ogni
elemento è una struttura di tipo persona. Per l’inserimento dei dati
utilizziamo il costrutto for che “cicla” su tutti gli elementi dell’array.
Per valorizzare un i-esimo campo utilizziamo un’istruzione del tipo:
gets(cliente[i].nome);

in questo caso riferendoci al campo nome. Preferiamo usare
l’istruzione gets al posto della scanf con il qualificatore %s per evitare di
avere problemi con eventuali nomi o cognomi che contengano degli
spazi al loro interno.
La sezione del codice relativa alla stampa dovrebbe essere auto
esplicativa.

Le strutture e le funzioni
Le strutture possono essere passate alle funzioni come argomenti di
una chiamata alla funzione stessa. Il passaggio può avvenire sia per
valore che per indirizzo. Il passaggio per indirizzo è anche noto
come passaggio per riferimento.
Nel passaggio per valore, come di consueto con questo tipo di
approccio, viene creata in memoria una copia dell’elemento che
viene passato alla funzione prima che il controllo venga trasferito
effettivamente alla funzione stessa. Ciò comporta la necessità di fare
attenzione a questo tipo di scelta quando si è in presenza di strutture
molto grandi a causa dello spazio di memoria eccessivo che
potrebbe essere utilizzato per la copia stessa.
D’altra parte il passaggio per valore può essere consigliabile nei casi
in cui si vuole evitare che la funzioni modifichi la struttura originale.
Infatti, tutte le manipolazioni effettuate dalla funzione saranno
applicate solo ed esclusivamente alla copia della struttura.
Di seguito vi propongo un esempio relativo a una struttura che
gestisce un punto all’interno di uno spazio tridimensionale. La
struttura, molto semplice, è la seguente:
struct punto
{
int x;
int y;
int z;
};

Di seguito l’intero codice in cui valorizziamo la struttura e la
stampiamo passandola per valore a una specifica funzione di
stampa.
#include <stdio.h>
#include <stdlib.h>
struct punto
{
int x;
int y;

int z;
};
void stampa(struct punto);
int main(int argc, char *argv[])
{
struct punto A;
A.x=1;
A.y=1;
A.z=1;
stampa(A);
system("PAUSE");
return 0;
}
void stampa(struct punto A)
{
printf("Le coordinate del punto sono: %d - %d - %d\n", A.x,
A.y, A.z);
}

Nel passaggio per indirizzo, ciò che viene effettivamente passato è
invece un puntatore alla struttura. In questo caso bisogna fare
attenzione alla sintassi utilizzata. Non è sufficiente indicare come
argomento il semplice nome della struttura così come avviene, ad
esempio, per i vettori. Infatti, nel caso dei vettori, il compilatore
leggendo il nome dell’array presuppone il passaggio di un puntatore
relativo al primo elemento dell’array stesso. Nel caso di una struttura
il passaggio del solo nome verrebbe interpretato come passaggio
per valore.
È dunque necessario dichiarare la funzione con una forma del tipo
che vi mostro di seguito:
//dichiarazione funzione
void mia_funzione (struct struttura *);

Vediamo allora un esempio completo relativo alla struttura punto vista
in precedenza. Si tratta, in buona sostanza, della riproposizione dello
stesso esercizio con l’eccezione relativa al fatto che ora utilizziamo
una specifica funzione valorizza passandole un puntatore alla
struttura punto per impostare i valori della struttura. Modifichiamo
inoltre la funzione stampa passandole ora la struttura per indirizzo:

#include <stdio.h>
#include <stdlib.h>
struct punto
{
int x;
int y;
int z;
};
void valorizza(struct punto *);
void stampa(struct punto *);
int main(int argc, char *argv[])
{
struct punto A;
valorizza(&A);
stampa(&A);
system("PAUSE");
return 0;
}
void valorizza(struct punto *A)
{
(*A).x = 2;
(*A).y = 2;
(*A).z = 2;
}
void stampa(struct punto *A)
{
printf("Le coordinate del punto sono: %d - %d - %d\n",
(*A).x, (*A).y, (*A).z);
}

Cominciamo con il notare il fatto che quando chiamiamo la funzione
di valorizzazione scriviamo:
valorizza(&A);

In effetti, la e commerciale, rappresenta la classica simbologia
utilizzata per indicare l’indirizzo di una qualsiasi variabile semplice.
Non c’è nessun mistero in tutto ciò. Ribadisco che una struttura è del
tutto simile a una variabile semplice e somiglia a un array solo per il
fatto che in essa è possibile inserire più elementi, volendo di tipo
diverso.
L’altra cosa importante da notare è all’interno della funzione che

valorizza i campi della struttura punto:
void valorizza(struct punto *A)
{
(*A).x = 1;
(*A).y = 1;
(*A).z = 1;
}

Come potete osservare, per dare un valore a una coordinata
scriviamo (*A).x = 1; riferendoci prima al puntatore A, con (*A), e poi
accedendo al campo specifico, in questo caso x, con l’operatore
punto.
Attenzione all’assoluta necessità di usare le parentesi tonde, in
quanto altrimenti applicheremmo prima l’operatore di accesso al
campo punto alla x, avendo risultati fuori dalla grazia di Dio. Ciò è
dovuto al fatto che l’operatore . (cioè punto) ha precedenza rispetto
all’operatore * .
Tuttavia non dobbiamo preoccuparci più di tanto: l’uso dei puntatori
alle strutture è così comune che il C mette a disposizione uno
specifico operatore per accedere a un campo di una struttura
passata come puntatore. L’operatore in questione è l’operatore
freccia -> che viene scritto utilizzando il simbolo ‘-’, cioè il trattino
seguito dal simbolo del maggiore '>'.
Quindi le due funzioni dell’esempio precedente possono essere
riscritte come segue:
void valorizza(struct punto *A)
{
A->x = 1;
A->y = 1;
A->z = 1;
}
void stampa(struct punto *A)
{
printf("Le coordinate del punto sono: %d - %d - %d\n", A->x,
A->y, A->z);
}

La sintassi di norma utilizzata prevede proprio l’uso dell’operatore
freccia.

Nuovi tipi con typedef
Le strutture sono un elemento fondante della potenza del C. Esse
sono infatti alla base di quasi ogni programma di una certa
complessità realizzato sfruttando tale linguaggio. Il loro uso, tuttavia,
risulta un po’ ruvido nella sintassi quando si è costretti
sistematicamente a usare la parola chiave struct all’interno del
codice, come in istruzioni del tipo seguente, per quanto riguarda la
dichiarazione di funzioni:
void valorizza(struct punto *);
void stampa(struct punto);

oppure:
struct punto A;

per dichiarare la volontà di utilizzare una struttura di tipo punto. Altri
richiami tipici sono del tipo:
void valorizza(struct punto *A)
{
…
}

nei prototipi delle funzioni. Come si vede, la parola chiave è sempre
presente appesantendo di molto l’intera sintassi. Ma, come dico
spesso, il C è il C, e ha una soluzione elegante anche per tali
situazioni. Tale soluzione si chiama typedef.
Utilizzando tale parola chiave è possibile creare dei veri e propri
nuovi tipi di dati. Nel nostro contesto possiamo ad esempio
dichiarare la struttura punto scrivendo:
typedef struct _punto
{
int x;
int y;
int z;
} punto;

La struttura punto è ora un nuovo tipo di dato “elementare” alla

stregua di un int oppure un char per i quali possiamo avere
dichiarazioni del tipo:
int x;
char c;

Nel nostro caso possiamo quindi dichiarare semplicemente qualcosa
del tipo:
punto A;

così come facciamo per un int oppure un char.
Come potete osservare abbiamo chiamato la struttura _punto, cioè
anteponendo un underscore (trattino basso) allo stesso nome che
vogliamo dare al nuovo tipo di dati. Si tratta di una convenzione.
Avremmo potuto utilizzare un qualsiasi altro nome; ma tale forma è
sicuramente elegante.
Di seguito vi propongo l’utilizzo del typedef nel contesto di un intero
pezzo di codice relativo alla nostra struttura d’esempio punto:
#include <stdio.h>
#include <stdlib.h>
typedef struct _punto
{
int x;
int y;
int z;
} punto;
int main(int argc, char *argv[])
{
punto A;
A.x = 1;
A.y = 1;
A.z = 1;
printf("Le coordinate del punto sono: %d - %d - %d\n", A.x,
A.y, A.z);
system("PAUSE");
return 0;
}

I campi di bit
I Campi di bit, definiti in inglese come Bit fields, sono un modo di
utilizzare le struct imponendo ai singoli campi una specifica e precisa
dimensione in bit. Spesso vengono definiti anche semplicemente
campi.
La definizione generale è la seguente:
struct tag
{
tipo [nome_membro] : numero_di_bit ;
};

dove tipo è di norma unsigned int per accertarsi di avere un numero
senza segno e numero_di_bit è appunto la dimensione in bit
dell’elemento del campo.
Tale caratteristica è un esempio eclatante relativo alla possibilità del
C di lavorare a basso livello e vicino all’hardware della macchina.
Infatti, i campi di bit sono spesso utilizzati in relazione a operazioni di
interfacciamento al sistema operativo oppure in situazioni che
prevedono operazioni di comunicazione di reti in cui è indispensabile
lavorare a livello dei singoli bit trasmessi. Altro contesto tipico di
applicazione dei campi di bit è quello della crittografia e quindi della
protezione dei dati.
Nel nostro ambito vi propongo un esempio molto semplice che ha a
che fare con la possibilità di usare i campi di bit come “gestori di
stato”. In gergo tecnico queste variabili vengono definite flags,
ovvero una sorta appunto di bandierine che definiscono una data
situazione spesso di tipo booleano. Vi ricordo che per booleano si
intende una situazione che ha due stati del tipo sì/no ovvero
vero/falso.
Nell’esempio supponiamo di dover gestire un trenino che per
semplicità può stare nei seguenti stati: fermo, in movimento in avanti
oppure in movimento indietro.
Il codice, assolutamente volutamente parziale e solo indicato, è il
seguente:

#include <stdio.h>
#include <stdlib.h>
void train_status(void);
struct train
{
unsigned int moving : 1;
unsigned int forward : 1;
};
struct train t;
int main(int argc, char *argv[])
{
t.moving = 1;
t.forward = 1;
train_status();
system("PAUSE");
return 0;
}
void train_status(void)
{
if (t.moving == 1)
{
printf("Il treno va...");
if (t.forward == 1)
{
printf("in avanti!");
}
else
{
printf("indietro!");
}
}
else
{
printf("Sono fermo!");
}
}

Il codice è abbastanza elementare e ha il solo scopo di esaltare uno
degli usi dei campi di bit. Come si evince dalla sua analisi, vediamo
come la struttura definisce lo stato del nostro treno con due semplici
campi di un singolo bit, che quindi è perfetto per gestire un valore
booleano.

Nel corpo del main impostiamo in modo hard coded lo stato del treno
e, con un’apposita funzione, visualizziamo tale stato.

Le unioni
Vi presento infine un tipo di struttura dati molto simile, per
formalismo di dichiarazione, alle struct che prende il nome di
unione. Ogni struct si preoccupa di riservare una quantità di spazio
di memoria adatta a contenere tutti i valori dei suoi singoli membri. In
effetti tale considerazione, dimostrata dal seguente pezzo di codice,
è banale e scontata:
#include <stdio.h>
#include <stdlib.h>
struct persona
{
char nome[20];
char cognome[25];
char indirizzo[30];
};
int main(int argc, char *argv[])
{
struct persona cliente;
printf("Lo spazio di memoria in byte occupato dalla
struttura e': %d\n", sizeof(cliente));
system("PAUSE");
return 0;
}

Mandato in esecuzione, il programmino ci dirà che la struttura
occupa 75 byte. Infatti tale valore è dato dalla somma 20 + 25 + 30,
ovvero la somma delle dimensioni dei singoli array di caratteri che
compongono la nostra struttura. Vi starete sicuramente chiedendo il
perché di tale banale richiesta di conferma. Il motivo è dato dal fatto
che la struttura dati unione è molto simile alla struct, con una
differenza sostanziale. Essa consente di gestire in un dato momento
uno solo dei suoi membri: per convertire la struttura in unione è
sufficiente sostituire la parola chiave struct con union, che definisce
appunto una unione.
Vediamo quindi cosa succede con tale modifica al nostro codice

precedente che diventa il seguente:
#include <stdio.h>
#include <stdlib.h>
union persona
{
char nome[20];
char cognome[25];
char indirizzo[30];
};
int main(int argc, char *argv[])
{
union persona cliente;
printf("Lo spazio di memoria in byte occupato dalla unione
e': %d\n", sizeof(cliente));
system("PAUSE");
return 0;
}

Mandato in esecuzione, il codice ci segnalerà un’occupazione di 30
byte. Ciò è dato dal fatto che una union riserva uno spazio di
memoria di dimensioni tali da contenere al massimo il più grande tra
i membri della struttura dati. Tuttavia esso ne contiene in un dato
momento uno e uno solo.
Questa mia affermazione è facilmente verificabile attraverso il
seguente codice, che assegna ai singoli campi della union vari e
differenti valori ma che vedrà in stampa solo ed esclusivamente
l’ultimo valore assegnato.
#include <stdio.h>
#include <stdlib.h>
union persona
{
char nome[20];
char cognome[25];
char indirizzo[30];
};
int main(int argc, char *argv[])
{
union persona cliente;
strcpy(cliente.nome, "Carlo");

strcpy(cliente.cognome, "Mazzone");
strcpy(cliente.indirizzo, "Via Dei Viali");
printf("Nome : %s\n", cliente.nome);
printf("Cognome : %s\n", cliente.cognome);
printf("Indirizzo : %s\n", cliente.indirizzo);
system("PAUSE");
return 0;
}

Infatti, la union condivide per tutti i membri la stessa area di memoria
e quindi memorizza solo l’ultimo dei valori assegnati. Nel caso del
mio esempio, per tutti e tre i campi verrà stampato il valore relativo
all’indirizzo del nostro cliente in quanto questo è l’ultimo valore
assegnato a un membro della union stessa.
In generale, le union vengono dunque utilizzate quando vi sono da
memorizzare differenti tipi di variabili e in un dato momento se ne ha
bisogno solo di una specifica tipologia. Troveremo spesso quindi
situazioni in cui in una union abbiamo una stessa variabile con tipi di
valori, ad esempio, del tipo int, float o double e di questi, di volta in
volta, si valorizzerà e utilizzerà un solo tipo.

15
I file e gli archivi di dati
secondo il C
Quando lo metti in memoria, ricordati

dove lo metti.
Arthur Bloch
I dati sono la base di qualsiasi tipo di elaborazione. È un concetto
intuitivo. Senza i dati non esiste elaborazione; che si tratti di interi, di
numeri con la virgola, di caratteri o di insiemi più complessi come
array e strutture, i dati sono gli elementi su cui si basano le
operazioni che realizziamo nei nostri programmi.

Archivi e file
Finora i dati che abbiamo gestito sono stati prelevati e introdotti nel
cuore del nostro codice utilizzando l’input dell’utente. Tuttavia, non
sempre questa soluzione è praticabile. Il caso più eclatante ed
emblematico si ha quando ci si confronta con programmi che
gestiscono grossi archivi di dati: agende con nominativi e attività da
svolgere, elenchi di clienti e quanto altro vi possa venire in mente. A
proposito di mente, è ovvio che solo un pazzo potrebbe pensare di
poter operare su situazioni del genere gestendo il solo input utente: i
dati devono per forza di cosa essere memorizzabili in maniera
permanente! Non dovete essere maghi dell’informatica per capire
che mi sto riferendo ai file.
Un file è, infatti, un archivio di dati memorizzato su di un dispositivo
di memorizzazione di massa: disco fisso, pennetta USB, CD o DVD.
Di contro, i dati che vengono elaborati all’interno del nostro
programma vengono gestiti nella RAM della macchina e,
contrariamente a quelli gestiti nei file, vengono persi alla chiusura del
programma in questione.
Sarà anche superflua ma un’ulteriore precisazione voglio farla.
Come già detto in precedenza, anche il nostro programma è salvato
su di un file, detto file eseguibile. Tale file contiene al suo interno le
istruzioni binarie del codice macchina. Al contrario, i file gestiti dal
programma sono noti come file di dati. Tali file possono essere di
due tipi: file di testo e file binari. I primi, i file di testo, sono i più
semplici: contengono testo puro, ovvero di norma solo caratteri
stampabili del codice ASCII, tanto da essere noti anche come file
ASCII. I file binari, invece, contengono dati codificati non
direttamente rappresentabili come elementi stampabili. Ne avevamo
comunque già parlato nel Capitolo 1, ma si sa: “repetita iuvant”.

Apertura e chiusura di un file
Vediamo allora come si gestisce un file partendo dai file di testo e
immaginando di volerne creare uno. Tale file di testo si chiamerà
carlo.txt. Se volevate un’ulteriore prova di eccesso di protagonismo
ve l’ho appena servita.
Per poter fare riferimento a un file si utilizza una specifica variabile.
Tale variabile è un puntatore a una struttura predefinita all’interno
della libreria stdio.h che si chiama appunto FILE. Dunque, la prima
cosa che dovremo fare all’interno del nostro codice sarà dichiarare
una variabile di questo tipo:
FILE * fp;

La dichiarazione così realizzata è giustificata dal fatto che FILE è un
tipo di variabile. Per intenderci è come se avessimo dichiarato
qualcosa come:
int * fp;

dove int è un intero e quindi dichiareremmo una variabile di tipo
puntatore che punta a un intero. Nel nostro caso, invece, la variabile
puntatore punta a una struttura di tipo FILE. Tale struttura contiene
informazioni specifiche sul file che andiamo a gestire. Il nome della
variabile, fp, non è casuale essendo questo nome composto dalle
iniziali delle parole file pointer, ovvero puntatore a file. Ovviamente
avremmo potuto comunque scegliere un nome qualsiasi.
Dopo aver dichiarato il puntatore al nostro file dobbiamo
preoccuparci di aprire il file in questione. Per farlo dobbiamo
specificarne il nome e che cosa intendiamo fare sul file stesso. Mi
spiego: un file potrebbe essere aperto per leggerne il contenuto, per
scrivere un nuovo contenuto aggiungendolo in coda a quello
eventualmente già presente, oppure per sostituire il contenuto
presente con nuovi dati. Ancora, si potrebbe voler creare un nuovo
file che non esiste ancora. Tali situazioni vengono di norma definite
come modalità di apertura del file. Per l’apertura di un file si utilizza

l’istruzione fopen. Di seguito una riga di codice d’esempio:
fp = fopen("carlo.txt", "w");

La funzione fopen prende in input due argomenti. Il primo è il nome
del file, nel nostro caso, come già anticipato prima, carlo.txt. Il
secondo argomento indica la modalità di apertura. Entrambi gli
argomenti sono stringhe racchiuse dai doppi apici. Nel nostro caso la
modalità di apertura è “w” che indica la volontà di creare un file per la
scrittura (w è l’iniziale della parola write). Con tale modalità, se il file
esiste già verrà sovrascritto, in caso contrario ne verrà creato uno
nuovo.
A proposito del nome del file, un’osservazione può essere utile.
Come avrete notato ho indicato il solo nome del file. L’assunzione
che si fa in tale circostanza è che il file risieda nella stessa cartella
dell’eseguibile (il nostro programma). Nel caso volessimo riferirci a
una cartella diversa, supponiamo ad esempio la classica radice del
disco C:, avremmo dovuto scrivere quanto segue:
fp = fopen("c:\\carlo.txt", "w");

Fate attenzione al fatto che per indicare il percorso c:\ ho dovuto
utilizzare un doppio backslash.
Una volta terminate le nostre operazioni sul file, questo dovrà essere
chiuso. Allo scopo esiste una specifica funzione:
fclose(fp);

Banalmente tale funzione prende in input come argomento il
puntatore al file e si occupa appunto di chiudere tale file. Vediamo
finalmente il codice tutto insieme:
#include <stdio.h>
#include <stdlib.h>
int main(int argc, char *argv[])
{
FILE * fp;
fp = fopen("carlo.txt", "w");
fclose(fp);
system("PAUSE");
return 0;
}

Il codice proposto non fa altro che creare un file vuoto di nome

carlo.txt.

Se potessimo sostituire al nome del file carlo.txt, che
abbiamo inserito in modo hard coded all’interno della funzione fopen,
una variabile che assuma un nome generico passato da riga di
comando potremmo realizzare un clone del comando touch
disponibile sui sistemi Unix/Linux. Tale comando crea appunto file
vuoti aventi come nome la stringa passata sulla riga di comando. E
poiché possiamo farlo, lo facciamo:
#include <stdio.h>
#include <stdlib.h>
int main(int argc, char *argv[])
{
FILE * fp;
if (argc != 2)
{
printf("Devi indicare il nome del file da creare!\n");
}
else
{
fp = fopen(argv[1], "w");
fclose(fp);
printf("Il file è stato creato!\n");
}
system("PAUSE");
return 0;
}

Vi commento brevemente il codice. Dopo aver dichiarato il puntatore
fp verifichiamo il numero di parametri passati sulla riga di comando
identificato dalla variabile argc. Ci accertiamo che questo valore sia
uguale a 2 e se invece esso è diverso da 2 segnaliamo all’utente che
deve indicare il nome del file da creare. Infatti, il nostro programma
dovrà essere invocato da riga di comando come segue:
touch.exe carlo.txt

dove touch.exe è il nome del nostro eseguibile e carlo.txt è il nome del
file che vogliamo creare. Dunque, un parametro è il nome del file
eseguibile stesso mentre il secondo parametro è il nome del file che
vogliamo creare, il che porta il valore di argc appunto a 2.
Se il valore è diverso da 2, come visto, segnaliamo l’anomalia; in
caso contrario, chiamiamo la funzione fopen passandole come primo

argomento il contenuto di argv[1], ovvero il secondo parametro della
riga di comando nel quale sarà specificato il nome del file da creare.
Un’osservazione incidentale di carattere generale ci sta tutta. Quello
che cerco di proporvi in questo manuale è un insieme di linee guida
che ritengo fondamentali nello sviluppo software; si tratta appunto di
indicazioni generali che dovete cogliere e sfruttare per realizzare
programmi scritti da voi e che abbiano il vostro DNA innestato al loro
interno. Nello specifico è ovvio che il programma di tipo touch che
abbiamo realizzato non è esente da miglioramenti. Tanto per dirne
una, l’uso dell’istruzione system("PAUSE"); non ha senso in questo
contesto. Il motivo è dato banalmente dal fatto che il programma
dovrà essere eseguito dalla console DOS del sistema. Inoltre,
volendo sarebbe possibile, nel caso in cui l’utente dovesse indicare
un numero di parametri errato, stampare a video anche una breve
descrizione d’uso del programma.

Modalità di apertura di un file
Come abbiamo visto in relazione alla funzione fopen, le modalità di
apertura di un file specificano le operazioni consentite sul file stesso:
apertura per scrittura, per lettura o per l’aggiunta di dati in coda al
file. Può essere utile a tal proposito un piccolo prospetto riassuntivo
di tali modalità:
w

Iniziale di write indica scrittura; se il file non esiste lo crea

r

Iniziale di read indica lettura

a

Iniziale di append indica aggiunta in coda al file;
se il file non esiste lo crea; non è possibile leggere il file

Su tali opzioni è possibile richiedere delle modifiche di
comportamento aggiungendo il carattere + dopo la lettera che indica
la modalità:
w+

indica scrittura e lettura

r+

indica lettura e scrittura

a+

indica aggiunta in coda al file e possibilità di lettura;
se il file non esiste viene creato

Vediamo di chiarire alcuni aspetti. Indicando w+ si richiede la
possibilità, oltre che di scrivere un file anche di poterlo leggere. La
stessa cosa dicasi per r+ che imposta la modalità lettura e scrittura.
Sembrerebbe che w+ e r+ indichino la stessa cosa, ovvero scrittura e
lettura. C’è tuttavia una piccola differenza. La modalità r+ può agire
solo su di un file che esiste già; in caso contrario verrà generato un
errore di accesso.
Qualche parola sulla differenza tra le modalità a e a+. Entrambe
consentono di aggiungere dati in coda al file; tuttavia, la modalità a+
consente anche di leggere dal file mentre utilizzando la modalità a è
possibile la sola scrittura in coda al file senza possibilità di lettura.

Scriviamo e leggiamo file di testo:
fprintf e fscanf
Credo che il modo più semplice per imparare nuove cose sia quello
di partire da cose già note. Per quanto riguarda la scrittura di dati
abbiamo come elemento acquisito, ormai assolutamente familiare,
l’uso della funzione printf. Tale funzione stampa sullo schermo.
Possiamo allora con grande semplicità utilizzare la funzione fprintf
che rappresenta una variante della classica printf, che aggiunge la
possibilità di stampare non verso lo schermo bensì direttamente
dentro un file. La sua sintassi generale è la seguente:
fprintf(fp, "Carlo Mazzone");

Dove fp è il puntatore al file e “Carlo Mazzone” è ciò che vogliamo
scriverci dentro. Voi, ovviamente, facendo una prova similare siete
invitati a mettere il vostro nome e cognome o qualsiasi cosa vi passi
per la mente in quel momento. Vediamo allora il codice completo:
#include <stdio.h>
#include <stdlib.h>
int main(int argc, char *argv[])
{
FILE * fp;
fp = fopen("carlo.txt", "w");
fprintf(fp, "Carlo Mazzone");
fclose(fp);
system("PAUSE");
return 0;
}

Come potrete facilmente osservare, la funzione fprintf è del tutto
simile a printf con la sola particolarità di avere, come primo
argomento da passare, il puntatore al file nel quale vogliamo
scrivere. Per rafforzare questa considerazione vi propongo il codice
seguente:

#include <stdio.h>
#include <stdlib.h>
int main(int argc, char *argv[])
{
FILE * fp;
fp = fopen("miofile.txt", "w");
fprintf(fp, "Io sono la prima riga\n");
fprintf(fp, "Io sono la seconda riga\n");
fprintf(fp, "Io sono la terza ed ultima riga");
fclose(fp);
system("PAUSE");
return 0;
}

Il codice crea un file di nome miofile.txt, all’interno del quale
stampiamo una serie di righe così come faremmo con una normale
printf aggiungendo anche il classico qualificatore \n per forzare il
ritorno a capo. Il risultato del codice è facilmente visualizzabile
all’interno di un qualsiasi editor di testi come vi mostro nella Figura
15.1.

Figura 15.1 – Il contenuto del file creato utilizzando le istruzioni
fprintf.
Ovviamente all’interno del file possiamo inserire tutto ciò che
vogliamo utilizzando le tecniche che già conosciamo. Sempre a titolo
di esempio generale supponiamo di voler creare un file che
contenga i primi 20 numeri naturali, uno per ogni riga. Il codice
potrebbe essere il seguente:
#include <stdio.h>
#include <stdlib.h>
int main(int argc, char *argv[])
{
FILE * fp;

int i;
fp = fopen("numeri.txt", "w");
for (i=1; i<=20; i++)
{
fprintf(fp, "%d\n", i);
}
fclose(fp);
system("PAUSE");
return 0;
}

Così come possiamo scrivere, ovviamente, possiamo anche leggere.
Per realizzare tale operazione possiamo usare una funzione analoga
alla scanf, ovvero fscanf. La sua sintassi è intuitiva ed è qualcosa del
tipo:
fscanf(fp, "%d");

Come potete osservare, il primo argomento è il puntatore al file sul
quale dovrà operare mentre come secondo argomento andremo a
specificare come trattare il dato prelevato.
Vi propongo subito un esempio. Supponiamo di voler stampare a
video i 20 valori numerici del file dell’esempio precedente leggendoli
appunto da tale file. Il file si chiama numeri.txt.
#include <stdio.h>
#include <stdlib.h>
int main(int argc, char *argv[])
{
FILE * fp;
int x;
fp = fopen("numeri.txt", "r");
while (!feof(fp))
{
fscanf(fp, "%d", &x);
printf("%d ", x);
}
fclose(fp);
system("PAUSE");
return 0;
}

Analizziamo il codice in quanto vi sono delle cose nuove e
interessanti che meritano un po’ di attenzione. Notiamo innanzitutto
che la modalità di apertura del file è questa volta r. Infatti, ciò che
vogliamo è semplicemente leggere dal file. Guardiamo allora il ciclo
while. Ciò che ci proponiamo è leggere i vari elementi presenti nel
file, uno per volta, per poterli stampare a video con la printf.
Ovviamente dobbiamo essere in grado di sapere quando
raggiungiamo la fine del file per poter interrompere le operazioni di
lettura. Ebbene, tale compito è affidato alla funzione feof. Tale
funzione prende in input il puntatore al file, nel nostro caso fp, e
restituisce 1 se siamo alla fine del file e 0 in caso contrario. Quando
apriamo un file è come se avessimo un cursore che indica la
posizione corrente nella quale leggiamo o scriviamo. Quando un file
viene aperto, il cursore è posizionato all’inizio del file stesso. Ad ogni
operazione di lettura, nel nostro caso tramite fscanf, il cursore viene
spostato automaticamente in avanti proporzionalmente ai dati letti.

Gestire gli errori
Ma cosa avviene in caso di errori? Cosa succede nel caso, ad
esempio, che il file che vogliamo leggere non sia presente sul disco
nella posizione specificata? Supponiamo ad esempio di mandare in
esecuzione il codice precedente che leggeva il file numeri.txt e che
tale file non sia presente.
Per fare una prova, per semplicità potete anche solo rinominarlo, ad
esempio chiamandolo _numeri.txt, anteponendo cioè al nome del
file un trattino basso. Una volta lanciato il programma scoprirete che
esso andrà brutalmente in crash. Il motivo di tale comportamento
risiede nel fatto che proviamo ad aprire in modalità r, quindi di sola
lettura, un file che non esiste.
Fortunatamente, ma d’altronde non potrebbe essere diversamente,
abbiamo la possibilità di verificare che l’operazione di apertura di un
file vada a buon fine o meno. Vediamo come:
#include <stdio.h>
#include <stdlib.h>
int main(int argc, char *argv[])
{
FILE * fp;
int x;
if ( (fp = fopen("numeri.txt", "r")) == NULL )
{
printf("Si e' verificato un errore nell'apertura del
file.");
return 1;
}
while (!feof(fp))
{
fscanf(fp, "%d", &x);
printf("%d ", x);
}
fclose(fp);
system("PAUSE");
return 0;
}

Quello che facciamo è verificare il valore restituito dalla funzione
fopen. Di norma, se non vi sono errori, la funzione restituisce un
puntatore alla struttura FILE. In caso contrario restituisce un puntatore
a NULL. In buona sostanza in quest’ultimo caso avremmo fatto un
buco nell’acqua.
Da notare, nel caso di errore, subito dopo la printf che lo segnala,
che forziamo l’uscita dal programma con l’istruzione return. In questo
caso aggiungiamo in coda al return il valore 1 contrariamente a
quanto fatto finora. Infatti, di norma utilizziamo return 0 a voler
significare che il programma si è chiuso normalmente. Con un valore
diverso da zero segnaliamo invece una terminazione anomala. La
scelta del valore di uscita, in questo caso 1, è di nostra scelta e
responsabilità.
Sempre per quanto riguarda la terminazione anomala del
programma, in alternativa all’uso dell’istruzione return, avremmo
potuto scrivere:
if ( (fp = fopen("numeri.txt", "r")) == NULL )
{
printf("Si e' verificato un errore nell'apertura del
file.");
exit(1);
}

dove abbiamo utilizzato la funzione exit passandole il valore 1 per
segnalare che si è verificato un errore. In generale, all’interno del
main, l’uso della funzione exit(1) oppure dell’istruzione return 1
producono lo stesso risultato.

Un carattere per volta: fgetc e fputc
Spesso si rende necessaria la lettura e la scrittura di singoli caratteri
alla volta. In queste situazioni è possibile fare ricorso alle funzioni
fgetc e fputc. La prima preleva dal flusso del file un carattere per
volta. Di seguito vi propongo dunque un semplice esempio di utilizzo
di fgetc.
#include <stdio.h>
#include <stdlib.h>
int main(int argc, char *argv[])
{
FILE * fp;
char c;
if ( (fp = fopen("miofile.txt", "r")) == NULL )
{
printf("Si è verificato un errore nell'apertura del
file.");
return 1;
}
while ((c = fgetc(fp))!= EOF )
{
printf("%c ", c);
}
fclose(fp);
system("PAUSE");
return 0;
}

dove EOF, acronimo di End Of File, è una costante che indica
appunto la fine del file.
Passiamo allora alla scrittura di un file attraverso la funzione fputc:
#include <stdio.h>
#include <stdlib.h>
int main(int argc, char *argv[])
{
FILE * fp;
char c;
if ( (fp = fopen("miofile.txt", "w")) == NULL )

{
printf("Si è verificato un errore nell'apertura del
file.");
return 1;
}
while ((c = getchar()) != '\n')
{
fputc(c, fp);
}
fclose(fp);
system("PAUSE");
return 0;
}

Scrivere e leggere file binari: fwrite e
fread
Passiamo finalmente alla gestione dei file binari. Le principali
funzioni per la gestione di tali tipi di file, come da titolo del paragrafo,
sono fwrite e fread. Non ci vuole un esperto di lingue per capirlo: la
prima serve per scrivere mentre la seconda per leggere.
Vediamo un esempio di scrittura:
#include <stdio.h>
#include <stdlib.h>
int main(int argc, char *argv[])
{
FILE * fp;
char x[]="Carlo Mazzone";
if ( (fp = fopen("miofile.bin", "wb")) == NULL )
{
printf("Si è verificato un errore nell'apertura del
file.");
return 1;
}
fwrite(x, sizeof(x[0]), 13, fp);
fclose(fp);
system("PAUSE");
return 0;
}

La prima cosa che vi invito a osservare è l’aggiunta della lettera b
dopo la lettera w nell’indicazione della modalità di apertura, per
segnalare il fatto che ci riferiamo a file binari. Per il resto la funzione
fopen non mostra novità se non il fatto che abbiamo scelto come
estensione .bin a voler rafforzare l’idea che si tratta di un file binario.
La funzione fwrite prende in input quattro argomenti: il primo è il
puntatore alla locazione di memoria che contiene i dati da scrivere; il
secondo è la dimensione del singolo dato da scrivere; il terzo è il
numero di elementi singoli da scrivere; il quarto, infine, indica il
puntatore al descrittore di file.

Nel nostro esempio abbiamo scritto su file un array di caratteri. Il
secondo parametro indica la dimensione della cella dell’array mentre
subito dopo abbiamo indicato il numero 13 in quanto la stringa di
caratteri ha appunto tale lunghezza. Infine abbiamo indicato il
puntatore fp restituito dalla funzione di apertura fopen.
Vediamo ora un esempio un po’ più completo ed elaborato che fa
uso anche della funzione di lettura fread. Supponiamo di voler
scrivere su di un file un array di cinque interi e di volerlo
successivamente leggere.
#include <stdio.h>
#include <stdlib.h>
int main(int argc, char *argv[])
{
FILE * fp;
int x[]={1,2,3,4,5};
int y[5];
if ( (fp = fopen("miofile.bin", "wb+")) == NULL )
{
printf("Si è verificato un errore nell'apertura del
file.");
return 1;
}
fwrite(x, sizeof(x[0]), 5, fp);
printf("La dimensione di una cella e': %d \n",sizeof(x[0]));
printf("Il cursore dopo la scrittura e' in posizione: %d
\n", ftell(fp));
fseek(fp,0, SEEK_SET);
printf("Il cursore e' ora in posizione: %d \n",ftell(fp));
fread(y, sizeof(int), 5 ,fp);
fclose(fp);
printf("Il contenuto del file e': ");
int i;
for (i=0; i <5; i++)
{
printf("%d ", y[i]);
}
printf("\n");
system("PAUSE");

return 0;
}

Vediamo un attimo cosa abbiamo scritto. La prima cosa da notare è
che utilizziamo la modalità di apertura wb+, ovvero scrittura di file
binario, con possibilità attraverso il simbolo + di successiva lettura.
Per quanto riguarda i dati in gioco, dichiariamo due array, il primo x
contiene i cinque numeri che vogliamo scrivere nel file, il secondo y
servirà da contenitore per i dati letti.
Con fwrite scriviamo i dati nel file; come primo argomento indichiamo
l’array stesso e quindi il puntatore alla sua prima posizione, come
secondo parametro indichiamo la dimensione della singola cella,
come terzo il numero di elementi di quella dimensione da scrivere,
appunto cinque, e infine il puntatore al file come quarto e ultimo
argomento. Per semplificarvi l’analisi del codice e i suoi risultati
potete fare riferimento all’immagine alla Figura 15.2.

Figura 15.2 – L’output a video relativo alla scrittura di un array di
interi.
Un altro elemento interessante è dato dalla funzione ftell. Tale
funzione prende come unico argomento il puntatore al file e
restituisce la posizione del cursore sul file. Come potete osservare
dalla figura, la funzione ftell ci dice che siamo in posizione 20. Ciò è
banalmente dovuto al fatto che ogni operazione di scrittura comporta
l’automatico spostamento del cursore sul file del numero di posizione
letto. Poiché ogni cella occupa, nel mio caso, 4 byte e poiché
abbiamo scritto 5 celle, essendo la matematica non un’opinione, 5
moltiplicato 4 dà 20.
A questo punto del codice dobbiamo leggere il file. Tuttavia per farlo
dobbiamo riposizionarci all’inizio del file stesso. Fortunatamente la
funzione fseek ci permette agevolmente di spostarci in una qualsiasi

posizione. Tale funzione è utilizzabile anche con file di testo. Essa
prende in input 3 argomenti e il suo prototipo è il seguente:
int fseek(FILE *stream, long offset, int origine);

Il primo argomento è banalmente il puntatore al file. Il secondo,
offset, rappresenta la posizione, ovvero il numero di byte di cui
spostarsi all’interno del file. Ovviamente, per contare tale
spostamento dobbiamo sapere qual è il punto di partenza dal quale
cominciare a contare i byte di cui dobbiamo spostarci. Questo
compito è affidato al terzo parametro, quello che io ho definito
origine. Nel caso in esame ho settato tale parametro al valore
costante SEEK_SET. Tale valore, che corrisponde all’intero zero,
significa inizio del file. Infatti, ciò che volevamo ottenere era proprio il
riposizionamento del cursore all’inizio del file per poter leggere tutto
il contenuto.
Di seguito vi riporto i possibili valori assumibili da tale costante.

Costante per fseek

Descrizione

SEEK_SET

A partire dall’inizio del file

SEEK_CUR

A partire dalla posizione corrente

SEEK_END

A partire dalla fine del file

La cosa interessante è che il cosiddetto offset, ovvero lo
spiazzamento o spostamento, può essere anche negativo
consentendoci di muoverci a ritroso all’interno del file.
Ciò che si realizza in questo modo è la gestione random del file.
Random, come sappiamo, significa casuale, e con tale nome
vogliamo riferirci al fatto che possiamo spostarci liberamente
all’interno del file indipendentemente dalla posizione di arrivo. Un po’
come avviene per la memoria RAM, dove la prima R nel nome sta
appunto a indicare Random.
Nel nostro caso ci siamo spostati all’inizio del file. Vi faccio notare,
incidentalmente, che esiste una specifica funzione che consente il
riposizionamento in testa al file. Tale funzione è:
void rewind(FILE *stream);

Essa prende in input il solo puntatore al file e imposta il cursore
all’inizio del file. Nel nostro caso avremmo dovuto scrivere rewind(fp);
che banalmente corrisponde a fseek(fp,0,SEEK_SET); .

Gestire gli archivi di dati
Quello che abbiamo visto per quanto riguarda i file binari getta le
basi per una gestione professionale degli archivi di dati. È intuitivo, e
lo avevo già segnalato in precedenza, che gli esempi forniti non
hanno molto senso: scrivere un file per poi brutalmente rileggerlo
non ha alcuna utilità pratica. Tutto ciò serviva per capire la logica di
funzionamento della gestione dei file e per prendere dimestichezza
con le specifiche funzioni messe a disposizione dalla libreria del C.
È infatti evidente che se dobbiamo andare avanti e indietro
all’interno di una sequenza di numeri, come nell’esempio
precedente, avremmo potuto gestire la cosa direttamente con un
array di interi. Tuttavia abbiamo capito che possiamo organizzare i
dati in blocchi, nel nostro caso precedente semplici interi che
occupavano 4 byte, e spostarci avanti e indietro a seconda delle
esigenze.
A questo punto, se sostituiamo concettualmente il singolo intero di 4
byte con una struct all’interno della quale inserire tutti i dati, il gioco è
fatto. Infatti, tutto quello di cui dovremo preoccuparci è di capire
quanto è grande la struttura, cosa che possiamo agevolmente fare
con l’operatore sizeof, e spostarci a gruppi di byte corrispondenti a
tale dimensione all’interno del nostro file.
Affronteremo queste problematiche in maniera più dettagliata
quando riprenderemo tali argomenti in seno al contesto del C++ nel
Capitolo 24.

Parte 2

Oltre le frontiere del C
Sin dai primi computer ci sono sempre
stati dei fantasmi nelle macchine.
Segmenti di codice casuali che si
raggruppano per poi formare dei protocolli
imprevisti. Potremmo chiamarlo un
“comportamento”.
Del tutto inattesi, questi radicali liberi
generano richieste di libera scelta,
creatività e persino la radice di quella che
potremmo chiamare un’anima.
Dal film “Io, Robot” di Alex Proyas

16
La programmazione orientata
agli oggetti e lo sviluppo di
software complesso
Un linguaggio diverso è una diversa

visione della vita.
Federico Fellini
La prima parte di questo viaggio, quella relativo al linguaggio C,
rappresenta sicuramente una tappa fondamentale. Il C, come più
volte ribadito, rappresenta infatti un “must” per qualsiasi
programmatore. Tuttavia, è da sottolineare come i linguaggi stessi si
siano nel corso degli anni evoluti per andare incontro alle necessità
di sviluppo di software sempre più complessi, efficienti oltre che
efficaci in relazione alle richieste di un’utenza sempre più esigente.
La tipologia di sviluppo che più è riuscita a rispondere a queste
esigenze è senza dubbio rappresentata dalla programmazione
orientata agli oggetti, nota anche come OOP, acronimo della
terminologia inglese Object Oriented Programming.
La cosa che ci tengo qui a sottolineare è che in ogni caso non esiste
una soluzione miracolosa per lo sviluppo software e, per quanto

alcune strategie possano facilitare il lavoro del programmatore, tale
lavoro risulta essere, sempre e comunque, un notevole impegno di
capacità intellettive.
Il punto focale della programmazione orientata agli oggetti, o più
semplicemente, programmazione ad oggetti, è il tentativo di
affrontare il problema da risolvere partendo da un’ottica il più
generale possibile. Per far ciò si prendono in esame gli elementi
coinvolti nel problema esaminando le loro proprietà e le azioni che
essi svolgono piuttosto che la “semplice” sequenza di istruzioni che
si ritiene di dover far eseguire al programma.
In effetti, presentata così è del tutto generale anche la mia
spiegazione. Come di consueto un esempio dovrebbe chiarire il
senso di quanto in esame. Supponiamo, anche per leggerezza di
trattazione, di dover scrivere un videogioco relativo alla classica
battaglia navale. Ovviamente, anche se le regole generali del gioco
sono note, dovremmo definire quelle specifiche per la nostra
applicazione. Ad esempio, si potrebbe definire come regola che il
giocatore “umano” combatta la battaglia contro il computer. Ma
vengo velocemente al punto. Nell’analisi del gioco è possibile isolare
una serie di elementi, che chiameremo oggetti, di cui dovremo
preoccuparci.
Un primo oggetto, ad esempio, potrebbe essere quello relativo alla
nave. Tale oggetto nave sarà dotato di una serie di caratteristiche
proprie dell’oggetto: grandezza (quante caselle occupa sulla griglia
di gioco), posizione sul campo di battaglia, stato della nave (colpito,
affondato). Tali caratteristiche sono note in gergo tecnico con il nome
di proprietà.
Un altro oggetto coinvolto a cui si potrebbe pensare è il giocatore
stesso: questo (dovrei scrivere questi ma lo tratto come un oggetto)
avrà delle sue proprietà come il nome o nickname, il numero di colpi
a disposizione ecc.
Come si intuisce, il tipo di approccio, particolarmente durante la fase
iniziale, è molto orientato al problema e poco alla stesura del
codice. In realtà, esistono addirittura dei software che consentono il
disegno del programma da realizzare tramite uno schema
completamente grafico e successivamente sarà il software stesso a
generare il codice sorgente senza intervento del programmatore.

Dunque un primo concetto dovrebbe essere ora acquisito: uno degli
scopi principali della programmazione orientata agli oggetti è quello
di consentire al programmatore di concentrarsi sul problema e
non sul codice da scrivere.
Un altro elemento positivo da non trascurare è dato dal fatto che
l’approccio tramite oggetti consente una maggiore organizzazione
in componenti separati del codice. Ciò si riflette su di una maggiore
possibilità che più programmatori riescano a lavorare efficientemente
sullo stesso codice. Inoltre, risultano semplificati i processi di
manutenzione e aggiornamento del codice stesso.
Oltre alle proprietà, un oggetto si contraddistingue per i metodi che
esso può gestire. Per metodo si intende un’azione che l’oggetto può
o deve realizzare. Ancora una volta un esempio tratto dal mondo
reale ci corre in soccorso per una maggiore comprensione della
questione.
Sempre riferendoci al gioco della battaglia navale, un metodo
dell’oggetto nave potrebbe essere il disegnarsi della nave sullo
schermo del PC. Per quanto riguarda l’oggetto giocatore si potrebbe
invece pensare al metodo “spara colpo”.
A ben rifletterci si può scoprire che la metodologia di
programmazione orientata agli oggetti ha un approccio
diametralmente opposto a quello di tipo top-down visto nella
programmazione modulare organizzata attraverso procedure e
funzioni. E in effetti è proprio così. Mentre la gestione attraverso le
funzioni prevede di lavorare dal generale al particolare
scomponendo il problema in sottoproblemi sempre più piccoli e
gestibili, la programmazione orientata agli oggetti usa un approccio
di tipo bottom-up. Come visto, infatti, si passa dalla parte più bassa
(bottom) definendo le caratteristiche singolari dei più piccoli
componenti organizzando poi verso l’alto (up) tali pezzi a formare
l’intero insieme.
In realtà, se vi state chiedendo come e quando applicare l’una o
l’altra metodologia, la risposta può essere solo una: l’esperienza.
Difficilmente troverete possibile applicare in maniera ortodossa e
purista uno specifico approccio. Il mondo reale è troppo complicato
per poter essere ingabbiato in schemi troppo rigidi e di tanto in tanto
sareste costretti a dei compromessi per poter soddisfare le richieste

del vostro cliente relative alle funzionalità del software. Ciò sarà
tanto più vero quando tali richieste verranno in un secondo
momento, quando il codice è già in fase di scrittura avanzata.

I linguaggi orientati agli oggetti
Può essere interessante notare che in questa introduzione agli
oggetti non ho fatto ancora alcun riferimento a uno specifico
linguaggio. La programmazione orientata agli oggetti è infatti un
paradigma di programmazione utilizzato da una miriade di linguaggi
e in generale non è quindi legata a nessuno in particolare.
Uno dei primi e più importanti linguaggi utilizzanti tale paradigma fu
sicuramente Smalltalk che sposava tale approccio in maniera
pressoché assoluta. Tale linguaggio fu sviluppato durante gli anni 70
e rappresentò una novità assoluta rispetto alla classica
programmazione procedurale, che vedeva il binomio tra dati e
codice operante sui dati stessi. Come vedremo meglio più avanti, al
contrario, nella programmazione orientata agli oggetti i dati e il
codice che opera su tali dati vivono in un unico contesto: l’oggetto.
Quando si parla di Smalltalk ci si riferisce di norma alla versione
Smalltalk-80, la prima versione a essere resa ufficialmente pubblica.
Uno degli aspetti di maggiore importanza di questo linguaggio è
sicuramente l’influenza che ebbe nei confronti di diversi altri
linguaggi di programmazione e nelle loro successive evoluzioni.
Il vento della programmazione orientata agli oggetti fece infatti in
modo che venissero realizzate varie implementazioni a oggetti di
linguaggi già esistenti. Un caso per tutti è quello del linguaggio C++
che eredita dal C tutte le sue caratteristiche di base aggiungendo la
possibile gestione degli oggetti.
Un altro esempio, non meno famoso, è quello del Delphi, con il suo
Object Pascal, che deriva appunto dal linguaggio Pascal.
Ma ancora, sempre nel novero dei più famosi e utilizzati linguaggi a
oggetti, sicuramente è da sottolineare la presenza del linguaggio
Java il cui grande successo di diffusione è stato sicuramente dovuto
alla sua portabilità su pressoché qualsiasi piattaforma hardwaresoftware.

Evoluzione dei linguaggi di
programmazione
In realtà, quella dei linguaggi di programmazione rappresenta per
certi aspetti una vera e propria babele, con decine e decine di
versioni che si sono succedute nel corso di vari decenni. Per
rendervi coscienti della loro molteplicità e della loro evoluzione vi
presento in figura uno schema davvero minimale, se non
microscopico, relativo ad alcuni dei principali linguaggi.

Figura 16.1 – La relazione di dipendenza reciproca tra alcuni dei
principali linguaggi di programmazione.
Mi sento ancora di ribadire come l’evoluzione dei linguaggi sia
dovuta alla ricerca di strumenti sempre nuovi per ottimizzare
l’efficacia e l’efficienza nello sviluppo software. Può essere allora

interessante in questa discussione approfondire qualche aspetto
generale relativo alla costruzione del software.

Vita, morte e “miracoli” di un software
Quello che vi ho infatti illustrato finora è probabilmente solo parte
della punta del classico iceberg. Credo che dovrebbe ormai essere
chiaro come il sole a mezzogiorno che per realizzare un software
non può risultare sufficiente avere a disposizione un linguaggio di
programmazione e il relativo ambiente di sviluppo.
Creare un’applicazione (o applicativo che dir si voglia) può essere
immaginato simile alla costruzione di un qualsiasi oggetto
complesso. A partire dalla sorpresa che potete trovare nell’ovetto di
cioccolato con le relative istruzioni di montaggio, per passare a un
mobile acquistato da Ikea fino ad arrivare all’edificazione di una
casa, tutto ciò che deve essere assemblato ha bisogno di un
apposito progetto.

Non solo codice
La creazione del software non sfugge a tali richieste, cosicché la
cosiddetta progettazione del software riveste in campo informatico
un’enorme importanza.
Per progettazione si intende l’insieme delle attività svolte al fine di
definire le caratteristiche essenziali del software da realizzare. In
“soldoni”, non è pensabile iniziare a scrivere codice senza aver
preventivamente definito cosa e come si vuole realizzare e quali
sono, quindi, le caratteristiche chiave che si intendono inserire nel
proprio prodotto. Per rafforzare la comprensione di questo aspetto vi
faccio riflettere sul fatto che spesso, prima di iniziare a scrivere il
programma vero e proprio, si realizza un modello di ciò che dovrà
essere prodotto, per verificare, anche visivamente, se ciò che stiamo
modellando è proprio ciò di cui abbiamo bisogno.
Cerco allora di essere un po’ più dettagliato. Prima ancora di iniziare
la progettazione è possibile individuare un’altra fase dello sviluppo
software, che prende il nome generico di analisi del software, nella
quale si definiscono per sommi capi le caratteristiche del software da
realizzare, i tempi che dovrebbero essere impiegati, le persone che
ci lavoreranno, i costi presunti, a chi sarà diretto (venduto) il software
in oggetto ecc. Solo dopo questa fase, se si riterrà valido e fattibile il
tutto, si passerà alla fase successiva di progettazione vera e propria.
Dopo la progettazione, ovviamente, si procede alla codifica del
programma di cui vi ho già parlato ampiamente.
Ma come facciamo a sapere se ciò che abbiamo realizzato dopo la
codifica corrisponde a ciò che effettivamente ci proponevamo di
ottenere? La risposta è semplice: collaudo del programma. Tale
fase è spesso, ma a torto, sottovalutata. Collaudare la propria
applicazione, prima di rilasciarla agli utilizzatori, è una cosa di
assoluta importanza. Questa fase di collaudo è spesso definita come
attività di testing e consiste nell’individuare eventuali bug (errori di
programmazione) all’interno della nostra applicazione.
Tutto questo processo prende il nome di ciclo di vita del software.
Tuttavia, a questo punto, mi sento in coscienza di fare alcune

precisazioni. Tanto per cominciare, ciò che vi ho descritto non può
essere applicato, così come proposto, in un singolo passo. Il motivo
è semplice: non si può scrivere (codificare) tutto il nostro codice e
produrre in un solo passaggio tutto il programma e quindi solo in
fase finale testarlo per individuare possibili bug. Un software, a meno
che non preveda la semplice stampa di una stringa del tipo “Salve
mondo”, è qualcosa di complesso, che deve per forza di cose essere
creato in piccoli pezzi. Ogni piccola nuova funzionalità deve essere
verificata attentamente prima di procedere alla costruzione della
funzionalità successiva. Al contrario, si rischierebbe di creare un
gigante dai piedi di argilla (o, sempre parafrasando, il classico
castello sulla sabbia).
I sistemi software attuali si sono talmente evoluti nel tempo tanto da
richiedere la formalizzazione di una specifica disciplina nota come
Ingegneria del software, che si preoccupa appunto di definire i
criteri più opportuni per la gestione del ciclo di vita dei software
stessi.
Un’altra cosa da dire è che spesso la serie di fasi descritte rimane
una mera indicazione teorica e che ancor più frequentemente si
viene colti dal raptus dello sviluppo senza preoccuparsi di produrre
uno straccio di progettazione preventiva. Niente di più sbagliato!
Anche nei progetti di dimensioni molto ridotte è bene organizzare il
lavoro, anche se sommariamente, prima di iniziare a codificare.
Un primo passo può anche consistere nel procurarsi una cartellina
per documenti sulla quale apporre il nome del programma che si
intende realizzare. Il nome, infatti, è uno degli aspetti preliminari
fondamentali del nostro progetto.
Anche se un nome commerciale non è stato ancora definito con
certezza, è sempre bene scegliere un nome di comodo (nome in
codice) per potersi riferire meglio al progetto in questione.
Giusto per fare un esempio, le varie versioni del sistema operativo
Windows, prima di essere rilasciate con il nome definitivo, sono state
sempre etichettate con un nome in codice provvisorio: Chicago per
Windows 95, Memphis per Windows 98, Whistler per Windows XP,
Longhorn per Windows Vista, solo per citarne alcuni.
La cartellina cartacea servirà come contenitore per appunti e
documenti attinenti al progetto. Tuttavia, una buona organizzazione

delle cartelle (intese come directory sul nostro hard disk) è
altrettanto importante. È a dir poco da pazzi scatenati pensare di
poter inserire i file del nostro progetto software in un’unica cartella.
Dovranno infatti essere create quantomeno una cartella per i codici
sorgenti, una per i documenti associati al programma, una per le
immagini da utilizzarsi nel software, una con i file compilati e gli altri
necessari alla distribuzione. Il tutto giusto per citare i principali
aspetti coinvolti.

Dammi un nome e ti dirò chi sei
Relativamente ai nomi da dare al proprio software mi sento di
spendere qualche parola in più.
Un nome, va da sé, serve a individuare in maniera precisa un certo
oggetto. Seppur non di capitale importanza per un sito web, un
nome efficace per un software applicativo può aiutare di molto la
notorietà del nostro prodotto.
Per darvi un’idea di quello che sto dicendo relativamente
all’importanza di un nome, vi riporto un brano tratto dalla conferenza
tenuta nel 2005 a Bologna da Richard Stallman, uno dei più
importanti artefici del software libero.

Figura 16.2 – Richard Stallman, New York, 16 marzo 1953.
Stallman, parlando del sistema operativo che stava sviluppando nei
primi anni 80, dice:
Così decisi che sarebbe stato un sistema Unix-like o per lo meno

compatibile, e questo ebbe una conseguenza interessante: siccome
Unix è formato da molti componenti, centinaia di componenti che
comunicano attraverso interfacce più o meno documentate, e gli
utenti usano quelle interfacce, per essere compatibili con Unix basta
mantenere la compatibilità con quelle stesse interfacce. Significò che
si doveva solo sostituire ciascuno dei componenti non compatibili,
uno alla volta. E significò anche che tutte le decisioni preliminari di
tipo architetturale erano già state prese e quindi, a quel punto,
l’unica cosa di cui avevamo bisogno era un nome.
Nella comunità dei programmatori degli anni settanta, alla quale io
appartenevo, si programmava sopratutto per il piacere (essere
pagati era secondario), e si sceglievano sempre nomi divertenti per i
programmi […]; c’è perfino una tradizione, quando si sviluppa
qualcosa di simile a qualcosa che esiste già, di scegliere un nome
che richiama in modo ricorsivo il nome dell’altro e dice “questo
programma non è quell’altro”.
Infatti, nel 1975, io avevo sviluppato la prima versione dell’editor
EMACS, un editor estendibile che poteva essere riprogrammato
dall’utente, e c’erano diverse imitazioni di EMACS, delle quali una si
chiamava FINE cioè “FINE non è EMACS” [FINE Is Not Emacs], e
c’era anche SINE che significava “SINE non è EMACS”, e c’era
anche EINE (uno in tedesco) e c’era anche MINCE per MINCE Is
Not Completely Emacs. Poi EINE fu quasi completamente riscritto e
la versione 2 si chiamò ZWEI (due in tedesco) che significa ZWEI
Was EINE Initially…
Così cercavo attivamente un nome del tipo “questo non è Unix”, ma
nessuna delle possibilità dava una vera parola, e se non avesse
avuto un altro significato non sarebbe stato divertente. [Alla fine] ho
provato con tutte le lettere dell’alfabeto: ANU, BNU, CNU, DNU,
FNU, GNU!
Gnu è la parola più divertente della lingua inglese, e non ho potuto
resistere.
Brano tratto da Login Internet Expert n.53, Luglio/Agosto 2005
Credo che le parole di Stallman appena presentate siano
assolutamente chiarificatrici su quanto un nome possa risultare
importante.
Ancora una considerazione sulla vita di un software. Così come ogni

elemento che ha una vita ha un suo termine, anche per un software
è prevista una “morte”. Essa normalmente incombe quando il
software diventa obsoleto perché non più rispondente a nuove
esigenze di lavoro o quando non più funzionante su nuovi sistemi
operativi o ambienti hardware. In ogni modo, per rendere il più
longevo possibile un dato software è necessario che questo venga
aggiornato e costantemente manutenuto. Infatti, un software anche
apparentemente perfetto ma abbandonato a se stesso, senza
sviluppatori che ne curino gli aggiornamenti, è destinato, in generale,
a una veloce e prematura fine.

Il versioning del software
Parlavo dunque di aggiornamenti. Come ho detto, di norma, un
software viene sviluppato tramite aggiornamenti successivi che ne
aumentano le potenzialità o che ne correggono eventuali bug. A ogni
nuova versione, per prassi comune, viene associato un numero o più
in generale una serie di numeri. Vado nel dettaglio della questione.
Supponiamo di aver realizzato un software che serve a prevedere il
futuro (questa sì che è una grande idea) e di averlo chiamato “Il
Previsore”. La prima versione che commercializzeremo sarà dunque,
in generale, semplicemente “Il Previsore” (o se vogliamo meglio
specificare le cose, “Il Previsore 1”). Dopo un po’ introdurremo nel
nostro software delle nuove caratteristiche, ad esempio, la possibilità
di prevedere dove acquistare il biglietto vincente della lotteria di
capodanno (questa sì che è una grandissima idea). La nuova
versione sarà chiamata “Il Previsore 2” in contrapposizione alla
prima versione del nostro applicativo. La questione di base è chiara:
avremo, o comunque ci auguriamo di poter avere, una versione 3,
una versione 4 e così via.
Spesso, tuttavia, le modifiche che vengono realizzate sui software
sono di scarsa o relativa importanza. In un tale contesto ci
troveremmo ben presto alla versione centesima, dando, tra le altre
cose, una sensazione di scarsa professionalità ai nostri vecchi e
possibili futuri clienti del nostro software.
La soluzione che si adotta è in genere quella di utilizzare un secondo
numero di versione (separandolo dal primo con un punto) e
incrementare tale numero in presenza di migliorie appunto
secondarie. In questa ottica la prima versione del nostro applicativo
sarà: “Il Previsore 1.0”, la seconda potrà essere “Il Previsore 1.1”
(abbiamo incrementato solo il numero di versione secondario), una
terza “Il Previsore 1.2” e una eventuale quarta versione, con
aggiornamenti di una certa importanza, sarà qualcosa del tipo: “Il
Previsore 2.0”. Il discorso dovrebbe a questo punto essere già più
chiaro.
L’uso di questi primi due numeri di versione è pressoché

standardizzato, ma c’è tuttavia dell’altro. Spesso, infatti, i numeri di
versione non sono semplicemente due, ma a volte tre o addirittura
quattro.
Una tipica versione del nostro software potrebbe essere qualcosa
del genere:

Il Previsore Versione 5.0.9.171
dove: 5 è il numero primario (major number), 0 il numero secondario
(minor number), 9 può essere utilizzato per indicare che questa
versione è la nona release (versione rilasciata) del nostro software.
Infine il numero 171 può rappresentare il cosiddetto numero di
BUILD. Una build rappresenta una specifica compilazione del nostro
file eseguibile principale. Spesso viene assegnata automaticamente
dal compilatore per identificare una specifica versione compilata dei
nostri sorgenti.
Ma ripeto, l’uso del terzo e quarto numero di versione può, per
aziende diverse, avere diversi significati.
A proposito della questione delle versioni, è interessante osservare
come, a seconda della tipologie di software, tali numeri vengano
utilizzati in modo molto differente. Nel campo, ad esempio, del
software gratuito, spesso non si utilizza nemmeno il numero primario
1 per indicare la prima versione rilasciata di un dato software. Al
contrario, in questi contesti, il numero primario è zero. Il motivo è
dato dal fatto che trattandosi di un software gratuito non c’è alcuna
enfasi commerciale che spinga a far capire al futuro potenziale
utente che si tratta di una versione ormai consolidata del software.
Dal versante opposto, i software commerciali hanno tutto l’interesse
a mostrarsi con un numero di versione alto nel giro di pochi rilasci
per far intendere una certa efficienza e robustezza del software
stesso.
In questo contesto credo che sia esemplare la storia del software
dBase, un DBMS (software per la gestione di archivi), molto
popolare negli anni 80.
Wayne Ratliff, un sistemista software presso il Jet Propulsion
Laboratory (JPL) di Pasadena, in California, realizzò un software di
gestione di archivi (il termine tecnico è, come detto, DBMS)

prendendo spunto dal software utilizzato al JPL per la gestione dei
dati satellitari. Ovviamente il software usato al JPL funzionava su
elaboratori di grandi dimensioni mentre la versione sviluppata da
Ratliff era dedicata ai microcomputer. Il software venne chiamato
Vulcan, in onore del mitico signor Spock della saga televisiva Star
Trek. Questo è a dimostrazione, ce ne fosse ancora bisogno, che di
norma i programmatori sono anche degli appassionati di
fantascienza.
Il nostro Ratliff si accordò con un rivenditore di software, un certo
George Tate, al quale fu affidata la rivendita del software in cambio
di una percentuale sulle vendite che sarebbe stata corrisposta
all’autore del software. Ed è qui che entra in gioco l’esperienza di
marketing che spesso è lontana dallo spirito del programmatore.
Tate rinominò Vulcan in dBase II. La trovata diabolica di Tate fu che
in realtà non esisteva nessuna prima versione con nome dBase I
(ovvero dBase 1) ma usando quel nome, dBase II (ovvero dBase 2)
si dava l’impressione all’acquirente di comprare un software
sicuramente più evoluto e stabile essendo già alla versione numero
2. Tate usò poi vari altri trucchi di marketing. Tra questi da
considerare il fatto che Tate si associò con Hal Lashlee fondando
una nuova società dedicata alla rivendita di dBase II: la Ashton-Tate.
Il nome fu scelto anteponendo al suo, Tate, un nome inventato,
Ashton, semplicemente perché egli ritenne che la combinazione
Ashton-Tate suonasse meglio di Lashlee-Tate.
L’utilizzo dei numeri di versione, così come ve li ho presentati, non è
il solo metodo utilizzato per identificare le versioni di un software.
Talune aziende e sviluppatori, ad esempio, preferiscono inserire
come numero di versione l’anno, a volte seguito dal mese, del
rilascio del software. Spesso tale metodologia viene indicata come
Ubuntu like.
Ubuntu è una distribuzione Linux molto diffusa che utilizza appunto
anno e mese per individuare i propri rilasci. Ad esempio, la versione
9.04 è stata rilasciata nel mese di aprile dell’anno 2009 mentre la
prima rilasciata nell’ottobre 2004 fu battezzata Ubuntu 4.10.
C’è poi un’altra cosa simpatica e bizzarra a proposito dei nomi in
codice dati alle varie versioni di Ubuntu. Di seguito ve ne menziono
qualcuno con relativa traduzione in italiano: Warty Warthog

(Facocero Verrucoso) per la 4.10, Hoary Hedgehog (Riccio Canuto)
per la 5.04, Breezy Badger (Tasso Arioso) per la 5.10. Questi nomi,
come riferisce Mark Shuttleworth, il creatore di Ubuntu, prendono la
forma “Adjective Animal”, cioè un “aggettivo animale”, con la
particolarità che la lettera iniziale del nome dell’animale e quella del
relativo aggettivo sono identiche.

Dall’alfa al rilascio: versioni alfa, beta,
RC
Scrivere codice e creare programmi, dovrebbe essere a questo
punto abbastanza chiaro, non è un’operazione banale. È più che
normale che durante lo sviluppo ci si fermi a verificare la stato di
avanzamento del progetto cercando anche di individuare sempre
possibili bug.
È così consuetudine rilasciare delle versioni intermedie di un dato
software prima di quella definitiva. La prima versione viene in genere
etichettata con il termine: alfa. Essendo questa la prima lettera
dell’alfabeto, il senso è che si tratta di una versione molto
preliminare, che contiene probabilmente una miriade di bug e
solitamente in essa non tutte le funzionalità progettate sono state
effettivamente implementate e inserite. Si tratta comunque di una
versione “testabile” che in ogni modo viene in genere rilasciata a un
ristretto numero di tester (spesso interni all’azienda sviluppatrice del
software stesso). Nel caso in cui vi siano più versioni alfa, queste
verranno indicate con alfa 1, alfa 2 e così via.
Ci si augura che revisionate le versioni alfa, il software sia più stabile
e maturo. I successivi rilasci ufficiali, sempre in attesa della final
release, vengono definiti versioni beta (spesso etichettati con la
semplice lettera b).
Va da sé che una versione beta è potenzialmente instabile e ciò
deve essere tenuto nel dovuto conto prima di scaricare tale tipo di
versione.
Risolti i problemi e i bug delle varie possibili versioni beta (beta 1,
beta 2 ecc.), prima della fatidica versione finale normalmente si
rilascia una versione detta Release Candidate, o brevemente RC,
che rappresenta, come il nome stesso lascia intendere, la versione
candidata per il rilascio finale.
Ormai siamo pronti per la distribuzione del nostro software. In alcuni
casi esiste tuttavia un’altra tipologia di versione detta “release to
manufacturing” oppure “release to marketing”, entrambe abbreviate

nella sigla RTM. Si tratta di una versione speciale riservata di norma
ai rivenditori, i quali si preoccuperanno di adattarla alle loro
specifiche esigenze di distribuzione.

17
Dal C al C++
Dentro i confini del computer, sei tu
il

creatore.

potenzialmente,

Controlli,

almeno

tutto

che

ciò

vi

succede. Se sei abbastanza bravo,
puoi essere un dio. Su piccola scala.
Linus Torvalds
Come già premesso all’inizio di questo nostro viaggio alla scoperta
delle chiavi della programmazione, dopo aver presentato e descritto i
fondamentali dello sviluppo software utilizzando il C, risulta del tutto
spontaneo utilizzare il C++ come linguaggio più evoluto che
permette di utilizzare in maniera naturale il paradigma di
programmazione orientato agli oggetti.
Il C++ è infatti un linguaggio che, utilizzando il C come suo
sottoinsieme, lo espande con nuove e più moderne caratteristiche.
L’autore del C++ è Bjarne Stroustrup, informatico danese con un
nome tanto complicato quanto importante è il linguaggio da lui

creato.

Figura 17.1 – Bjarne Stroustrup, il creatore del C++.
A proposito del nome, mi piace qui sottolineare il fatto che il nome
del linguaggio C++, con l’operatore ++ di incremento del C, vuole
appunto significare un linguaggio C incrementato, e quindi a uno
stato di evoluzione successiva rispetto al C stesso. Il nome, C++,
pronunciato “si plas plas”, nella forma inglese, o più semplicemente
“ci più più” nella forma italiana, è dovuto a Rick Mascitti, il quale
modificò il nome iniziale “C con le classi” relativo a una prima
versione del lavoro di Stroustrup.

Un “Salve mondo” anche per il C++
Ovviamente è impossibile, descrivendo per la prima volta un nuovo
linguaggio, esimersi dalla prassi del presentare un primo semplice
programma che stampi le parole “Salve mondo” a video. Ciò è tanto
più vero per il C++ essendo tale prassi nata proprio con il linguaggio
C.
Per realizzare questo e i successivi programmi il mio consiglio
relativo all’ambiente di sviluppo è quello di utilizzare Code::Blocks.
Il motivo è dato dal fatto che ci accingiamo a realizzare programmi
sempre più complessi e abbiamo bisogno di strumenti maggiormente
sofisticati e affidabili.
Supponendo quindi di utilizzare Code::Blocks, possiamo procedere a
creare un nuovo progetto di tipo C++. In caso abbiate bisogno di
dettagli vi rimando a quanto presentato nel Capitolo 2 a proposito di
questo ambiente di sviluppo.
Il codice generato dall’ambiente in maniera automatica in seguito
alla richiesta di creazione di un nuovo progetto di tipo Console
application sarà il seguente:
#include <iostream>
using namespace std;
int main()
{
cout << "Hello world!" << endl;
return 0;
}

Come si può facilmente verificare, il codice è estremamente simile a
quello presentato per il linguaggio C. Il main, anche in questo caso,
rappresenta il punto in cui inizia l’esecuzione delle istruzioni.
La direttiva #include serve per comunicare al compilatore di includere
le dichiarazioni per le funzioni di input/output presenti nel file iostream.
Nello specifico, la funzione di nostro interesse è cout. Questa
consente di inviare a video , tramite l’operatore “<<”, la stringa di
testo che segue l’operatore stesso.
Tale operatore, realizzato banalmente attraverso due simboli di

minore, è noto come operatore di inserimento (insertion
operator). Il nome è giustificato dal fatto che tale operatore
inserisce i propri argomenti all’interno del flusso che andrà poi in
output.
In realtà, come visto, per realizzare il nostro “Salve mondo” non
dobbiamo fare una gran fatica in quanto è lo stesso ambiente a
salutare per noi, proponendoci tali istruzioni nel template di
creazione di un nuovo progetto; l’unica particolarità è che lo fa in
lingua inglese.
Se proprio vogliamo salutare in italiano possiamo modificare la
stringa e ricompilare. Il codice sarà banalmente il seguente:
#include <iostream>
using namespace std;
int main()
{
cout << "Salve mondo!" << endl;
return 0;
}

Per compilare ed eseguire potete utilizzare il menu Build scegliendo
la voce Build and run oppure la scorciatoia da tastiera F9.

Figura 17.2 – Output del semplice programma “Salve mondo”.
Dalla figura potete notare come, oltre all’output che ci aspettavamo,
è presente anche il tempo di esecuzione in secondi e l’invito, in
inglese, a premere un tasto per continuare. Tutto questo senza il
bisogno di utilizzare la funzione system("pause"), vista nel caso di DevC++. Ciò è dovuto al fatto che è l’ambiente stesso a fornirci questa
possibilità quando si lancia (run) l’applicativo al suo interno.
Devo ora spendere qualche parola relativa alla dichiarazione using
namespace std;. Tale istruzione serve a segnalare la volontà del nostro
codice di utilizzare il namespace di nome std.

Uno spazio dei nomi, in inglese appunto namespace, consente di
raggruppare variabili, funzioni e oggetti in “contesti” separati gli uni
dagli altri. Il motivo di tale approccio è dato dalla volontà di evitare i
problemi connessi a un eccessivo numero di variabili globali che in
generale possono condurre a un codice poco gestibile.
Ad esempio, una variabile globale potrebbe essere inavvertitamente
modificata in un qualsiasi pezzo di codice che la utilizza, rendendo
instabile l’intera applicazione.
Nel nostro caso l’istruzione in questione serve a rendere visibile lo
spazio dei nomi in cui è definita la funzione di stampa cout. Proviamo
infatti a remmare la linea di codice in questione come segue:
// using namespace std;

Remmare è un neologismo che ha il senso di commentare
NOTA e deriva da rem, abbreviazione di remark, appunto
commento.
Il doppio slash serve dunque in C++ per commentare una singola
riga di codice. In alternativa potremmo escludere dall’esecuzione la
riga in questione anche utilizzando la sintassi C, sfruttando la ben
nota simbologia che vi mostro di seguito:
/* using namespace std; */

Vi ricordo, se mai ce ne fosse bisogno, che i commenti realizzati
tramite la simbologia /* e */ possono invece riferirsi a più righe di
codice che saranno oggetto di commento. Al contrario, il doppio
slash, come detto, si riferisce sempre e solo alla singola linea nella
quale è utilizzato.
In ogni caso, l’effetto sarebbe quello di escludere dall’esecuzione la
riga in cui dichiariamo il namespace std.
Per tutta risposta il compilatore ci segnalerà nella finestra in basso
quanto segue:
error: 'cout' undeclared (first use this function)

In buona sostanza ci viene segnalato che la parola cout non si sa
cosa sia. In effetti cout appartiene allo spazio dei nomi std. Se

vogliamo utilizzare cout senza fare riferimento all’indicazione using
namespace std; dobbiamo, in un certo senso, esplicitare la sua
appartenenza. Per farlo abbiamo la necessità di utilizzare uno
specifico operatore, noto come operatore di visibilità, scritto
utilizzando una coppia di due punti “::” che andranno inseriti tra
l’indicazione del namespace e il nome della funzione cout.
Dobbiamo quindi scrivere l’istruzione di output come segue:
std::cout << "Hello world!" << endl;

In realtà, se provate a compilare il codice con Code::Blocks, avendo
effettuato solo tale modifica, scoprirete che vi verrà segnalato un
ulteriore errore, simile al precedente ma questa volta relativo
all’istruzione endl.
error: 'endl' undeclared (first use this function)

Tale istruzione endl, che forza un end of line, ovvero l’analogo del
‘\n’ del C, appartiene infatti anch’essa allo spazio dei nomi std come
l’istruzione cout. Il motivo dell’errore è quindi il medesimo del caso
precedente: non si sa chi sia endl.
Per risolvere il problema, non volendo usare la riga di codice using
namespace std; possiamo quindi scrivere il codice seguente:
#include <iostream>
int main()
{
std::cout << "Salve mondo!" << std::endl;
return 0;
}

Incidentalmente vi faccio notare che, a proposito della costante endl,
avremmo potuto ottenere lo stesso risultato scrivendo:
std::cout << "Salve mondo!" << "\n";

ovvero utilizzando la classica sequenza di escape newline del
linguaggio C. A voi la scelta!

Diamo spazio ai nomi
Compreso, almeno per sommi capi, cosa si intenda per namespace,
dovrebbe essere chiaro che std rappresenta un namespace
predefinito, cioè messo a disposizione dall’ambiente. È ovviamente
d’altronde possibile definire uno spazio dei nomi di proprio interesse;
per farlo si utilizza, neanche a dirlo, la parola chiave namespace, come
mostro di seguito:
namespace Pippo
{
int x, y;
}

Come potete osservare, si utilizza la parola chiave namespace seguita
dal nome da noi scelto e da un blocco di parentesi graffe che andrà
a racchiudere l’elenco delle variabili che vogliamo facciano parte del
nostro namespace.
Con quanto scritto, le variabili semplici x e y sono dunque
appartenenti al namespace Pippo e per poterle utilizzare devo
scrivere qualcosa del tipo:
Pippo::x = 2;
Pippo::y = 4;

Mettendo tutto insieme in un esempio completo vi propongo il
seguente codice:
#include <iostream>
using namespace std;
namespace Pippo
{
int x, y;
}
int main()
{
Pippo::x = 1;
Pippo::y = 2;
cout << "I valori di x e y sono: " << Pippo::x << " " <<
Pippo::y <<
endl;

return 0;
}

Nel codice potete notare la definizione del namespace Pippo posta
all’esterno del main. Subito dopo assegniamo alle due variabili del
namespace in questione due valori numerici qualsiasi utilizzando
l’operatore di visibilità :: .
Infine stampiamo i valori in questione usando l’istruzione cout e
costruendo la stringa di output con l’operatore <<.
Tuttavia, per capire l’effettiva utilità dei namespace, è il caso di
creare un altro namespace che utilizza altre due variabili aventi gli
stessi nomi del primo namespace: x e y.
namespace Pluto
{
int x, y;
}

Ed è proprio questa la possibilità sostanziale dei namespace: poter
utilizzare variabili con lo stesso nome senza incorrere (almeno
potenzialmente) in problemi di ambiguità e quindi poter meglio
organizzare il proprio codice.
Vediamo allora l’esempio seguente:
#include <iostream>
using namespace std;
namespace Pippo
{
int x = 1;
int y = 2;
}
namespace Pluto
{
int x = 3;
int y = 4;
}
int main()
{
cout << "Prima variabile x: " << Pippo::x << endl;
cout << "Seconda variabile x: " << Pluto::x << endl;
return 0;
}

Dopo aver creato due namespace, Pippo e Pluto, contenenti variabili

con lo stesso nome, x e y, facciamo riferimento a tali variabili
differenziandole attraverso l’operatore di visibilità.
In generale, tuttavia, potrebbe risultare notevolmente tedioso dover
scrivere, ogni volta che si utilizza un dato oggetto (ad esempio la
variabile x), il nome del namespace al quale appartiene. Per ovviare
a tale situazione si può fare ricorso, come abbiamo già visto nel caso
del namespace std, alla parola riservata using che consente di
rendere palese in un certo pezzo di codice l’elemento in questione.
Scrivendo, ad esempio:
using Pippo::x;

sarà possibile fare riferimento alla variabile x del namespace Pippo
senza dover referenziare quest’ultimo. Mostro di seguito l’intero
codice:
#include <iostream>
using namespace std;
namespace Pippo
{
int x = 1;
int y = 2;
}
namespace Pluto
{
int x = 3;
int y = 4;
}
using Pippo::x;
int main()
{
cout << "Prima variabile x: " << x << endl;
cout << "Seconda variabile x: " << Pluto::x << endl;
return 0;
}

Come potete osservare dal codice appena scritto, nelle istruzioni di
stampa ho fatto innanzitutto riferimento alla variabile x senza
utilizzare alcun specificatore; tale prima variabile x farà dunque
riferimento al namespace Pippo. Successivamente ho fatto invece
esplicito riferimento all’elemento Pluto::x. L’output sarà quindi il
seguente:

Prima variabile x: 1
Seconda variabile x: 3

Più in generale è possibile introdurre e referenziare in un dato
contesto un intero namespace scrivendo qualcosa del tipo:
using namespace Pippo;

In questo modo, l’intero insieme di variabili presenti all’interno del
namespace può essere richiamato direttamente facendo riferimento
al solo nome delle singole variabili.
Di seguito un esempio completo:
#include <iostream>
using namespace std;
namespace Pippo
{
int x = 1;
int y = 2;
}
namespace Pluto
{
int x = 3;
int y = 4;
}
int main()
{
using namespace Pippo;
cout << "Prima variabile x: " << x << endl;
cout << "Prima variabile y: " << y << endl;
cout << "Seconda variabile x: " << Pluto::x << endl;
return 0;
}

Dal codice si vede come entrambe le variabili x e y del namespace
Pippo vengano referenziate con il solo nome, mentre la variabile x del
namespace Pluto viene indicata con l’operatore di visibilità.
A questo punto, tuttavia, è necessario fermarsi un attimo per una
riflessione di assoluta importanza. Se da un certo punto di vista la
clausola using comporta un sicuro vantaggio nella stesura del codice,
d’altra parte un utilizzo poco accorto può creare un grosso problema:
variabili appartenenti a namespace differenti, ma aventi lo stesso
nome, potrebbero entrare in collisione. Questo è il motivo per cui

molti sviluppatori evitano l’uso della clausola using a contesti
estremamente limitati.
Spessissimo la clausola using viene utilizzata proprio nel primo
contesto che abbiamo visto relativo alla funzione di output cout.
#include <iostream>
using namespace std;
main()
{
cout << "Salve mondo\n";
return 0;
}

Ciò è dovuto al fatto che tale istruzione è molto usata e appartiene
alla dotazione standard del C++, un po’ come avviene per la printf
del C. Tale dotazione standard è nota appunto come libreria
standard. Vi faccio qui notare incidentalmente come gli include di
tale libreria standard facciano riferimento a file, ad esempio iostream,
che non utilizzano la tradizionale estensione .h che eravamo abituati
a vedere nel contesto degli include del C.
Sempre a proposito della clausola using, può essere importante
notare come la sua visibilità dipenda dalla sua collocazione
all’interno del codice. Se, ad esempio, essa viene posta all’esterno
del main agirà su tutto il main stesso come se si trattasse di una
variabile globale. La cosa che può lasciare perplesso invece il
programmatore proveniente dal C è il fatto che essa può agire anche
a livello di singolo blocco di codice. Chiarificatore a riguardo può
essere il seguente codice:
#include <iostream>
using namespace std;
namespace Pippo
{
int x = 1;
int y = 2;
}
namespace Pluto
{
int x = 3;
int y = 4;
}

int main()
{
{
using namespace Pippo;
cout << "Prima variabile x: " << x << endl;
}
{
using namespace Pluto;
cout << "Seconda variabile x: " << x << endl;
}
return 0;
}

Come potete osservare, i blocchi rappresentati dalle parentesi graffe
aperte e chiuse fanno da contenitore e da scudo per la visibilità di
quanto in essi dichiarato. Il primo blocco contiene ciò che attiene al
namespace Pippo mentre il secondo riguarda esclusivamente il
namespace Pluto.

Visibilità delle variabili in C++
L’esempio appena visto relativo alla clausola using rende del tutto
naturale spendere qualche parola a proposito della visibilità delle
variabili in C++. Una variabile è visibile all’interno del blocco in cui è
dichiarata. Il seguente esempio può essere sicuramente efficace per
far capire cosa intendo.
#include <iostream>
using namespace std;
int x = 1;
int main()
{
int x = 2;
{
int x = 3;
cout << "x: " << x << endl;
}
cout << "x: " << x << endl;
cout << "x: " << ::x << endl;
return 0;
}

Ho dichiarato tre diverse variabili di nome x; la prima di tipo globale
con valore 1, la seconda visibile all’interno del main, alla quale ho
assegnato il valore 2, e la terza con valore 3 all’interno di un blocco
specifico di parentesi che la “scherma” in qualche modo dal contesto
esterno al blocco stesso. Volendo è possibile riferirsi alla variabile
globale utilizzando l’operatore di visibilità visto prima, come mostrato
nell’ultima istruzione di stampa dell’esempio e come vi riporto di
seguito per una maggiore chiarezza:
cout << "x: " << ::x << endl;

Per capire il funzionamento del codice fate attenzione al risultato
delle stampe delle varie versioni della variabile x che vi propongo di
seguito:
x: 3
x: 2

x: 1

Fin qui quello che si può fare; discorso diverso riguarda quello che si
deve o non deve fare. Mi spiego. La prima cosa da osservare è la
pericolosità potenziale di un tale pezzo di codice. La variabile x così
utilizzata potrebbe creare un bel po’ di problemi, in quanto il
programmatore potrebbe perdere il “controllo” e facilmente
commettere qualche errore. Ciò, in particolare, potrebbe essere
causato anche dalla scelta, appositamente errata, che ho fatto in
relazione al nome della variabile. Dei nomi del tipo x, i, j oppure
similari sono un tentativo di suicidio informatico se utilizzati per
variabili che hanno un riferimento di tipo globale.

I riferimenti
Come si è visto in più occasioni, la visibilità delle variabili e la relativa
possibilità di modificarne i valori sono aspetti cruciali nello sviluppo di
un’applicazione software. Il problema, ormai è chiaro, non si pone
quando la modifica deve avvenire nei pressi della variabile stessa
ma quando è necessario accedere, ed eventualmente modificare,
determinati valori da posizioni esterne al campo di visibilità
dell’elemento in questione.
Il linguaggio C++, così come il C, può fare ricorso al concetto di
puntatore già ampiamente analizzato nel Capitolo 13. Come
ricorderete, i puntatori sono un modo per riferirsi a una certa
variabile accedendo direttamente alla locazione di memoria nella
quale è contenuto il valore della variabile stessa attraverso l’indirizzo
specifico della cella in questione. Tuttavia il C++ ha un ulteriore
strumento per gestire le problematiche in esame, noto come il
termine di riferimento (reference in inglese).
Un riferimento, come in parte suggerisce lo stesso nome, è un modo
alternativo per riferirsi a un certo oggetto. Esso è una sorta di alias,
un ulteriore nome con il quale referenziare un elemento di
programmazione. Vediamone l’uso di base attraverso la seguente
istruzione:
int &r = x;

Abbiamo dichiarato una variabile reference r anteponendo al suo
nome il simbolo di “e commerciale”. Nella dichiarazione siamo inoltre
costretti a indicare un’altra variabile, nel nostro caso x, alla quale
punta il nostro riferimento. Infatti, non è consentito dichiarare un
riferimento senza inizializzarlo, così come non è possibile avere dei
riferimenti nulli. In effetti la variabile r è ora un puntatore all’area di
memoria in cui è presente x. La particolarità di questo puntatore è
che esso continuerà sempre e comunque a puntare alla sua
variabile. Una sorta di puntatore costante o, se volete, una costante
di tipo puntatore. Infatti, non è ammissibile modificare in un secondo
momento un riferimento facendolo puntare a un’altra variabile

differente. Per comprendere meglio gli aspetti proposti vi presento
un esempio di codice minimale ma completo.
#include <iostream>
using namespace std;
int main()
{
cout << "Riferimenti!" << endl;
int x = 1;
int &r = x;
r++;
cout << "r: " << r << endl;
return 0;
}

Dal codice potete notare come, dopo aver dichiarato e inizializzato al
valore 1 la variabile x, dichiariamo un riferimento di nome r alla
variabile x stessa. Per intenderci, r e x si riferiscono ora alla stessa
variabile. A dimostrazione di quanto affermato, è sufficiente
considerare che la stampa della variabile r, dopo l’istruzione r++ che
vede a essa applicato l’operatore di incremento, risulta visualizzare il
valore 2. Infatti, l’incremento del riferimento non agisce, come nel
contesto dei puntatori, sull’indirizzo della variabile bensì sul valore
della variabile stessa che passa da 1 al valore appunto 2.
Tuttavia, come lasciato intendere all’inizio del paragrafo, la vera
utilità dei riferimenti la si può apprezzare nel caso di utilizzo come
parametri all’interno di una funzione, ovvero quando dobbiamo
manipolare dei valori da un pezzo di codice esterno alla visibilità
delle variabili alle quali vogliamo accedere. L’uso del riferimento
consente di ottenere gli stessi benefici dei puntatori realizzando una
chiamata di funzione per indirizzo senza, d’altra parte, la
complicazione derivante dall’uso dell’aritmetica dei puntatori stessa.
Per sincerarci di tale applicabilità facciamo riferimento a una
funzione che deve scambiare il valore di due variabili intere.
Consideriamo dunque il seguente codice:
#include <iostream>
using namespace std;
void scambia(int , int);
int main()
{
cout << "Scambiamoci i valori" << endl;

int a = 1;
int b = 2;
scambia(a, b);
cout << "a: " << a << endl;
cout << "b: " << b << endl;
return 0;
}
void scambia (int x, int y)
{
int z;
z=x;
x=y;
y=z;
}

Il programma, dopo aver inizializzato due variabili intere a e b
rispettivamente ai valori 1 e 2, chiama la funzione scambia per,
appunto, scambiare tali valori al fine di valorizzare la variabile a con
2 e b con 1.
La funzione in questione usa la variabile z come variabile tampone,
ovvero temporanea, per effettuare lo scambio dei due valori, così
come già visto nel Capitolo 10.
Tuttavia, così come potremmo aspettarci, lo scambio avviene solo
per le copie delle variabili x e y rimanendo confinato all’interno della
funzione, tanto che in output abbiamo la seguente stampa:
a: 1
b: 2

Vediamo allora come risolvere il problema in questione usando i
riferimenti. A partire dal precedente codice dobbiamo effettuare delle
modifiche davvero minimali che riguardano i soli parametri della
funzione scambia, per i quali dobbiamo aggiungere l’operatore & come
vi mostro di seguito.
#include <iostream>
using namespace std;
void scambia(int& , int&);
int main()
{
cout << "Scambiamoci i valori" << endl;

int a = 1;
int b = 2;
scambia(a, b);
cout << "a: " << a << endl;
cout << "b: " << b << endl;
return 0;
}
void scambia (int& x, int& y)
{
int z;
z = x;
x = y;
y = z;
}

La cosa per certi aspetti sorprendente è come si possa invocare la
funzione scambia(a, b); passando semplicemente il nome delle
variabili e ottenendo comunque il seguente atteso risultato:
a: 2
b: 1

avendo semplicemente
dichiarandola come

modificato

l’interfaccia

della

funzione

void scambia(int& , int&);

e modificandone la firma nell’implementazione come mostrato di
seguito:
void scambia (int& x, int& y)
{
…
}

ovvero, come già detto, sfruttando l’operatore di riferimento &. È
intuitivo come tale approccio ottimizzi la chiamata e la relativa
operatività della risposta di una funzione evitando la pesantezza
derivante dal comportamento predefinito del passaggio di parametri
che avviene tramite la copia degli argomenti stessi. Ciò è tanto più
vero quando all’interno delle chiamate delle funzioni sono coinvolti
degli oggetti.

18
Input e output di dati
Chi vuol muovere il mondo, prima

muova se stesso.
Socrate
Dopo aver presentato alcuni degli aspetti fondanti del C++ è
importante dettagliare alcuni elementi relativi alla gestione dell’input
e dell’output di base di questo linguaggio. Senza tali elementi, infatti,
diventa difficile presentare esempi degni di nota.
Purtroppo per molti le differenze tra C e C++ si fermano all’uso di tali
funzioni: la printf per il C contrapposta all’istruzione cout del C++ in
relazione all’output, mentre per l’input la scanf si contrappone alla
analoga istruzione cin del C++ che vedremo a breve. Ovviamente, e
lo si sta già intravedendo, le differenze tra i due linguaggi vanno ben
oltre tali aspetti del tutto secondari e riguardano l’approccio generale
alla scrittura dei programmi e ai differenti paradigmi di
programmazione. Sebbene i costrutti di base dei due linguaggi,
come ad esempio i costrutti di selezione o quelli relativi ai cicli come
for e while, siano del tutto simili, le differenze vanno ben oltre tali
aspetti assolutamente marginali.

Console input
Veniamo allora alle funzioni di input e output. Abbiamo già visto,
seppur sommariamente, l’uso dell’istruzione cout; combiniamo allora
a essa l’istruzione cin relativa all’input in un semplice e classico
esempio.
Questo può essere comunque il momento opportuno per una
precisazione importante. Definire cin e cout genericamente istruzioni
o anche, in qualche caso, funzioni, è una semplificazione. Infatti, in
realtà, cin e cout sono dei veri e propri oggetti utilizzati per inviare e
per ricevere dati in relazione ai cosiddetti canali standard (standard
streams). Un canale standard rappresenta la modalità predefinita
con cui il programma comunica con il mondo esterno in relazione al
suo input e al suo output. Di norma il canale per lo standard input
(anche noto come stdin) è la tastiera mentre il canale per lo
standard output (abbreviato in stdout) è lo schermo. Esiste inoltre
un ulteriore canale relativo alla segnalazione di errori ed elementi di
diagnostica da parte del programma noto come standard error
(stderr). Quest’ultimo, nel C++, è associato all’oggetto di nome cerr.
Torniamo dunque al nostro esempio e prendiamo in input un numero
stampando il suo successivo.
#include <iostream>
using namespace std;
main()
{
int x, s;
cout << "Dammi un numero: ";
cin >> x;
s = x + 1;
cout << "Il successivo e': " << s;
return 0;
}

Come si evince dal codice, cin utilizza l’operatore >> per assegnare il
valore preso in input da tastiera alla variabile, nel nostro caso,
denominata x. Tale operatore è realizzato attraverso due simboli di

maggiore e prende anche il nome di operatore di estrazione
(extraction operator). Il nome è giustificato dal fatto che esso si
preoccupa di estrarre i dati dal flusso di input.
Se volete un modo per ricordare se associare il simbolo >> piuttosto
che l’operatore << utilizzato per l’output, potete pensare al fatto che di
norma all’interno del prompt di una console di tipo DOS, utilizzata
appunto per l’input dei comandi, l’ultimo carattere, almeno sulle
macchine Windows, è il simbolo di maggiore. Dunque dovrebbe
risultare naturale pensare ai simboli >> per la funzione input cin.
Mi vergogno quasi a fare esempi semplici come il seguente; meglio
tuttavia vergognarsi un po’ che dare per scontati troppi elementi.
Dunque, il seguente pezzo di codice prende in input due numeri e ne
fa la somma stampandola a video:
#include <iostream>
using namespace std;
main()
{
int x, y, s;
cout << "Dammi un numero: ";
cin >> x;
cout << "Dammi un altro numero: ";
cin >> y;
s = x + y;
cout << "La somma e': " << s;
return 0;
}

Nonostante la banalità dell’esempio, questo può aiutarvi a prendere
dimestichezza con il linguaggio. In effetti mi sento ancora di
sottolineare come un linguaggio lo si impari attraverso l’uso pratico
realizzato alla macchina e non leggendo semplicemente codice fatto
da altri. Ancora, l’esempio precedente mi permette di farvi vedere
come è possibile combinare due input su di una sola riga di
istruzione cin; possiamo infatti modificare il codice precedente come
segue:
#include <iostream>
using namespace std;
main()
{

int x, y, s;
cout << "Inserisci due numeri: ";
cin >> x >> y;
s = x + y;
cout << "La somma e': " << s;
return 0;
}

Sarà sufficiente separare i due numeri con un semplice spazio per
consentire la giusta attribuzione dei due input rispettivamente alle
variabili x e y.

cin e le stringhe: un rapporto difficile
Fin quando la funzione cin si trova a dover gestire dei valori numerici
essa si comporta in maniera del tutto regolare. Il problema sorge
quando cin deve avere a che fare con stringhe di caratteri. Un primo
problema risiede nel fatto che cin si “blocca” in presenza di spazi.
Avevamo già incontrato un problema simile discutendo degli array di
caratteri e della funzione scanf del C. Se ricordate avevamo trovato
una soluzione con la funzione gets.

Il pappagallo recidivo
In effetti se scriviamo qualcosa del tipo:
#include <iostream>
using namespace std;
int main()
{
char s[25];
cout << "Dimmi come ti chiami (e ti diro' chi sei): ";
cin >> s;
cout << "Tu sei " << s << endl;
return 0;
}

scopriremo che inserendo, ad esempio, nome e cognome, il nostro
simpatico “codice pappagallo” ci fornirà in output solo il nome. Vi
posso capire se state iniziando a odiare le stringhe.
Sembra incredibile ma non è finita qui. Quando inserite una stringa
con degli spazi (o anche tabulazioni) la funzione non elimina il
carattere di fine stringa \n che rimane nel buffer (memoria
temporanea per la gestione dell’input). Tale comportamento ha dei
risultati davvero bizzarri. Per provarlo potete verificare cosa succede
utilizzando il seguente codice:
#include <iostream>
using namespace std;
int main()

{
char s1[25],s2[25];
cout << "Stringa 1: ";
cin >> s1;
cout << s1 << endl;
cout << "Stringa 2: ";
cin >> s2;
cout << s2 << endl;
return 0;
}

Se provate a inserire una stringa contenente uno spazio al suo
interno scoprirete che il programma non vi darà la possibilità di
inserire il secondo input per la stringa s2. Infatti, il carattere \n rimasto
nel buffer forzerà un invio dei dati al vostro posto con il risultato di
vedere stampato in s2 la seconda parte della stringa inserita (quella
dopo lo spazio). Sicuramente frustrante.

Il pappagallo rinsavito
Fortunatamente anche in questo caso abbiamo una soluzione: la
funzione getline. Tale funzione legge l’input ignorando eventuali
spazi bianchi per una data dimensione specificata e rimuove il
carattere di fine riga. Alla pagina seguente un pappagallo finalmente
“normale”.
#include <iostream>
using namespace std;
int main()
{
char s1[25],s2[25];
cout << "Stringa 1: ";
cin.getline(s1, 25);
cout << s1 << endl;
cout << "Stringa 2: ";
cin.getline(s2, 25);
cout << s2 << endl;
return 0;
}

Quando la mescolanza è deleteria

Vorrei dirvi che i problemi sono finiti; ma se lo facessi mentirei. Le
operazioni di input, lo abbiamo visto, sono questioni delicate e
quando possibile bisogna evitare di mischiare vari e differenti metodi
di gestione. Per farcene una ragione consideriamo il seguente
esempio, nel quale preleviamo prima un numero con la classica cin e
successivamente una stringa con la funzione membro getline:
#include <iostream>
using namespace std;
int main()
{
char numero, s[25];
cout << "Dammi il numero: ";
cin >> numero;
cout << "Dammi la stringa: ";
cin.getline(s, 25);
cout << numero << endl;
cout << s << endl;
return 0;
}

Il risultato di tale mescolanza di approcci è assolutamente dannoso.
Durante la prima cin viene conservato il carattere \n di fine linea, che
va a finire direttamente nell’input successivo impedendo
l’inserimento della stringa. Fortunatamente anche in questo caso
esiste un cosiddetto workaround, ovvero uno stratagemma, che ci
toglie dai guai. La soluzione è data dall’ignorare in maniera esplicita
tale carattere di fine riga attraverso la seguente funzione:
cin.ignore(80, '\n');

La funzione ignore scarta dunque il carattere \n mentre il numero 80
indica il numero massimo di caratteri presenti in una riga di input. Il
valore non è casuale, essendo spesso 80 il numero di caratteri
disponibili in una finestra di tipo console. L’istruzione così
organizzata deve essere posta subito dopo la cin prima della
successiva getline. Cioè:
…
cin >> numero;
cin.ignore(80, '\n');
cout << "Dammi la stringa: ";

cin.getline(s, 25);
…

Qualche dettaglio sull’output, un po’
di formattazione
Una buona formattazione dell’output, ovvero il posizionamento del
giusto numeri di spazi, corretti allineamenti del testo e appropriato
numero di cifre decimali nella presentazione di valori numerici, è un
aspetto fondamentale per un programma che si rispetti. Di seguito vi
riporto alcune tecniche di base per ottenere un buon risultato di
visualizzazione dei dati senza eccessivi sforzi utilizzando il contesto
del C++.
Abbiamo già visto che per generare un output qualsiasi possiamo
rifarci alla funzione cout che accoda i vari elementi da visualizzare
sullo stream (flusso) di uscita utilizzando l’operatore <<:
cout << "Carlo" << " " << "Mazzone" << endl;

Uno dei modi più semplici per ottenere un buon output può essere
quello di rifarsi alle funzioni presenti nel file di intestazione iomanip.
Tali funzioni si trovano all’interno del namespace std. Ciò banalmente
comporta che nel caso si utilizzi la clausola using namespace std; è
possibile fare riferimento a esse semplicemente attraverso il loro
nome; in caso contrario, bisogna richiamarle con l’operatore di
visibilità :: .

Impostare la larghezza dei campi
Spesso può essere necessario allineare dei valori o degli elementi
impostando una larghezza massima per l’output. In tali occasioni è
possibile utilizzare il manipolatore setw nella seguente forma:
std:: setw(x)

dove x è un intero che indica appunto la larghezza del campo in
output. Vediamone un esempio:
#include <iostream>
#include <iomanip>

using namespace std;
int main()
{
cout << "12345678901234567890" << endl;
cout << setw(15) << "Carlo" << endl;
cout << setw(15) << "Pippo" << endl;
cout << setw(15) << "Pluto" << endl;
cout << setw(15) << "Topolino" << endl;
return 0;
}

Il cui output sarà quello visualizzato nella Figura 18.1.

Figura 18.1 – Un esempio d’uso della funzione setw().
Comincio con il chiarire il senso dell’istruzione:
cout << "12345678901234567890" << endl;

che in effetti senso sembra non averne. Tale istruzione produce in
output sequenze di dieci cifre da 1 a 9 seguite poi dallo zero che
simula il valore 10. Infatti tale istruzione serve solo a rendere più
chiaro il funzionamento della setw() creando una sorta di righello di
intestazione. Ovviamente per il valore 10 ho dovuto usare la sola
cifra zero; in caso contrario avrei occupato due posizioni anziché
una sola. Come si evince dalla figura, dunque, l’istruzione setw(15)
provoca l’allineamento a destra dell’output seguente nella posizione
quindicesima.
Vi faccio notare come sia necessario ripetere l’istruzione per ogni
singola riga. In caso contrario, l’istruzione seguente perde le
impostazioni relative alla larghezza impostata in precedenza.

Un diverso riempimento

Di norma il carattere utilizzato per costruire gli allineamenti è
ovviamente il carattere spazio. Nel caso si voglia, invece, riempire gli
spazi aggiuntivi con un carattere differente, è possibile utilizzare il
manipolatore setfill('x'), dove 'x' rappresenta il carattere utilizzato
per il riempimento.
Supponiamo allora di voler produrre un’intera linea, di norma lunga
80 caratteri, formata dal carattere asterisco. Possiamo scrivere:
#include <iostream>
#include <iomanip>
using namespace std;
int main()
{
cout << setfill('*') << endl;
cout << setw(80) << "" << endl;
return 0;
}

Abbiamo usato innanzitutto l’istruzione setfill che si predispone a
riempire gli spazi con il carattere ‘*’. Successivamente abbiamo
richiamato la funzione setw(80) per allineare alla colonna 80 l’output
successivo. Tale output è una stringa vuota; ciò comporterà
l’occupazione dell’intera riga.
Contrariamente a quanto avviene con la funzione setw, con la
funzione setfill il comportamento viene mantenuto per tutto l’output
seguente fino a una successiva chiamata a setfill, che quindi
presumibilmente sarà qualcosa del tipo
cout << setfill(' ') << endl;

reimpostando il carattere spazio come carattere di riempimento.

Formattiamo i numeri
La cosa più banale che possiamo considerare di fare a proposito
della stampa a video dei numeri è quella di costringere i numeri
stessi a utilizzare un dato numero di cifre. Per farlo possiamo usare
la funzione setprecision(x), dove x è il numero di cifre che vogliamo
stampare. Subito l’esempio:
#include <iostream>

#include <iomanip>
using namespace std;
int main()
{
const double x = 3.14159;
cout << setprecision(3) << x << endl;
return 0;
}

L’output sarà 3.14 in quanto la funzione non fa distinzione tra parte
intera e parte decimale ma si limita a controllare il numero massimo
di cifre da mandare in output.
Per un controllo più fine possiamo decidere di indicare un numero
specifico di elementi per la sola parte frazionaria. Per farlo dobbiamo
prima di tutto utilizzare l’indicatore di formato fixed e
successivamente effettuare la chiamata a setprecision().
Ad esempio:
#include <iostream>
#include <iomanip>
using namespace std;
int main()
{
cout << fixed;
cout << setprecision(2) << 123.456 << endl;
cout << setprecision(3) << 123.456 << endl;
cout << setprecision(4) << 123.456 << endl;
return 0;
}

produrrà in output quanto segue:
123.46
123.456
123.4560

Come potete notare il numero che utilizziamo per l’esempio ha tre
cifre per la parte intera e tre per la parte frazionaria. La cosa che
salta subito all’occhio è che quando proviamo a stampare utilizzando
setprecision(2) otteniamo un arrotondamento della parte frazionaria.
Senza sorprese, quando forziamo a 4 il numero di elementi della
parte frazionaria notiamo l’aggiunta di uno zero.

Volendo stampare dei valori utilizzando la notazione scientifica è
possibile fare riferimento all’indicatore di formato scientific come
mostrato di seguito:
cout << scientific;

Per resettare le impostazioni di default è invece possibile fare
riferimento alla funzione unsetf che riporto integralmente di seguito:
std::cout.unsetf ( std::ios::floatfield );

Una base diversa per ogni occasione
È possibile stampare un valore numerico in basi diverse dalla
classica base 10; tipicamente in base 8 (ottale) oppure 16
(esadecimale). Allo scopo è possibile usare la funzione setbase(x),
dove x è la base in cui vogliamo stampare il nostro numero.
Ad esempio:
cout << setbase(8) << 255 << endl;
cout << setbase(16) << 255 << endl;
cout << setbase(10) << 255 << endl;

stamperà 337, ff e 255, rispettivamente valori corrispondenti alle due
basi, 8, 16 e l’originale 255 nella notazione decimale.
In alternativa alla funzione setbase è possibile utilizzare altri
modificatori di output: oct, hex e dec ottenendo i medesimi risultati
appena visti.
cout << oct << 255 << endl;
cout << hex << 255 << endl;
cout << dec << 255 << endl;

19
Oggetti e classi
Un linguaggio di programmazione è
a

basso

programmi

livello quando i suoi
richiedono

molta

attenzione per l’irrilevante.
Alan J. Perlis
Dopo la parentesi di tipo pratico realizzata con il precedente capitolo
relativo alle istruzioni di input - output torniamo agli aspetti più
filosofici della programmazione orientata agli oggetti. Il concetto di
oggetto dovrebbe a questo punto essere sufficientemente chiaro,
così come dovrebbe essere intuibile la sua utilità nello sviluppo
software. Vediamo allora di capire come gli oggetti possono essere
realmente gestiti nel contesto del C++.

Dalle struct alle classi
Per comprendere il C++ dobbiamo partire dal concetto di classe di
oggetti. Non a caso abbiamo detto, presentando tale linguaggio,
che il suo primo nome fu appunto “C con le classi”. Una classe
rappresenta una sorta di stampo per realizzare oggetti. Nel definire
una classe per un dato oggetto si definiscono le caratteristiche dei
futuri oggetti che da quella classe saranno realizzati. Per molti
aspetti una classe è una sorta di struct, già vista per il C e valida
anche per la sintassi del C++. In realtà le struct del C rappresentano
il punto in cui il C si “ferma” e mostra i suoi limiti. Al contempo, tale
punto di arresto risulta il punto di “avvio” del C++ che utilizzando il
concetto di struct lo riprende e lo espande. Nei precedenti capitoli sul
C vi ho fatto vedere come una struct sia un’ottima soluzione per
organizzare in un’unica struttura dati caratteristiche varie e
generiche di un dato elemento.
Supponiamo, ad esempio, di voler gestire un elemento geometrico
come un rettangolo. Il codice per gestire tale rettangolo tramite una
struct potrebbe essere qualcosa del tipo:
#include <iostream>
using namespace std;
struct Rettangolo
{
int x;
int y;
};
int main()
{
//inizializzo la struct Rettangolo
Rettangolo rettangolo1;
//assegno valori a base e altezza
rettangolo1.x = 20;
rettangolo1.y = 10;
//stampo valori
cout << "Base: " << rettangolo1.x << endl;
cout << "Altezza: " << rettangolo1.y << endl;
return 0;
}

Fin qui nulla di nuovo rispetto a quanto già visto per il C. Ciò che
abbiamo fatto è definire una struttura Rettangolo avente due membri, x
e y, che rappresentano i lati di una data generica figura geometrica
di tipo rettangolo. Successivamente abbiamo dichiarato rettangolo1
come variabile di tipo struct scrivendo Rettangolo rettangolo1;
C’è da dire che in C tale istruzione avrebbe generato errore. Infatti
avremmo dovuto scrivere struct Rettangolo rettangolo1; anteponendo
quindi la parola chiave struct, oppure avremmo dovuto usare la
direttiva typedef per definire un nuovo tipo. Il C++ consente invece
questa modalità abbreviata.
Più in generale il C++ fa molto di più rispetto a questa banale
semplificazione della notazione di scrittura di elementi di tipo
struttura. Infatti, il C++ espande il concetto di struct attraverso la
parola chiave class in sostituzione, o meglio in superamento,
appunto della parola chiave struct.
In effetti il codice precedente potrebbe essere riscritto del tutto
semplicemente sostituendo la parola struct con class, come vi mostro
di seguito.
#include <iostream>
using namespace std;
class Rettangolo
{
int x;
int y;
};
int main()
{
cout << "La mia classe rettangolo" << endl;
Rettangolo rettangolo1;
//CODICE NON FUNZIONANTE
rettangolo1.x = 10;
rettangolo1.y = 20;
return 0;
}

Tuttavia, c’è un problema, come potete notare dal commento che
recita //CODICE NON FUNZIONANTE. Infatti, provando a compilare il codice in
questione, l’ambiente ci restituirà un errore simile al seguente:
... error: "int Rettangolo::x" is private

Incapsulamento e occultamento
dell’informazione
Il comportamento del compilatore in merito all’errore appena
mostrato si spiega considerando una prima differenza tra struct e
classi: il cosiddetto incapsulamento o, in inglese, information
hiding.
L’incapsulamento,
in
effetti,
consiste
appunto
nell’occultamento delle informazioni all’interno di una classe.
Infatti, se traduciamo l’errore noteremo che il compilatore ci avverte
del fatto che la variabile x, appartenente al contesto Rettangolo, risulta
essere privata. In altre parole, anche se a prima vista potrebbe
sembrare un nonsenso, le classi cercano di nascondere il proprio
funzionamento a chi le utilizza. Lo scopo è quello di far sì che le
classi vengano utilizzate come se fossero delle scatole nere che,
lavorando su determinati dati, restituiscono un certo risultato senza
che chi le utilizza (il programmatore) debba preoccuparsi di come
queste producano il risultato stesso. In realtà abbiamo già visto
questo concetto di scatola nera quando abbiamo avuto a che fare
con sottoprogrammi e funzioni. Ciò comporta come diretto beneficio
che una classe ben progettata possa essere facilmente riutilizzata
anche in progetti diversi da quello originario proprio grazie alla sua
estraneità a un contesto specifico.
Non a caso una delle caratteristiche fondamentali di un linguaggio
orientato agli oggetti è appunto l’incapsulamento.
Ma a questo punto una domanda dovrebbe nascere spontanea: se
la classe non mostra le sue caratteristiche all’esterno di essa, come
può mai essere utilizzata? Per capirlo bisogna considerare che, al
contrario di quanto avviene con una struct, i membri di una classe
sono per default privati.
Ciò significa che le variabili e gli elementi in genere presenti
all’interno di una classe non sono visibili e utilizzabili all’esterno ma
solo all’interno della classe stessa. Appunto sono privati e ciò spiega
il messaggio di errore mostrato prima. Tuttavia, per poter essere
utilizzata, una classe richiede che alcuni membri siano resi pubblici,
ovvero siano gestibili dall’esterno per poter invocare una serie di
operazioni sulla classe stessa. Un po’ come avviene per i parametri

di una funzione. L’insieme di tali membri prende di norma il nome di
interfaccia dell’oggetto.
Per poter richiamare la classe Rettangolo bisogna quindi esplicitare
che, ad esempio, i membri x e y sono effettivamente pubblici; per
farlo si usa la parola riservata public seguita dai due punti, che
rappresenta uno specificatore di accesso alla classe:
class Rettangolo
{
public:
int x;
int y;
};

L’accesso public rende visibili e utilizzabili i membri che seguono la
relativa parola chiave da qualsiasi punto del codice in cui risulta
visibile la classe stessa. Per cui possiamo scrivere il seguente
codice senza timore di particolari errori:
#include <iostream>
using namespace std;
class Rettangolo
{
public:
int x;
int y;
};
int main()
{
cout << "La mia classe rettangolo" << endl;
Rettangolo rettangolo1;
//assegno valori a base e altezza
rettangolo1.x = 30;
rettangolo1.y = 15;
//stampo valori
cout << "Base: " << rettangolo1.x << endl;
cout << "Altezza: " << rettangolo1.y << endl;
return 0;
}

Come detto, il comportamento predefinito relativamente alla visibilità
è quello “privato”. Per rendere esplicita tale condizione è possibile
utilizzare la parola chiave private seguita dai due punti prima

dell’elenco degli elementi che si intende rendere privati:
class Rettangolo
{
private:
int x;
int y;
};

Parliamo agli oggetti: messaggi e
metodi
Un altro “salto di qualità”, che si realizza con una classe in
sostituzione di una struct, è senza dubbio dato dalla possibilità di
includere una o più funzioni direttamente nella classe stessa. In
questo modo le struct, che sono intanto diventate classi, assumono
la capacità di elaborare i dati cessando di essere dei semplici
contenitori per i dati stessi. Tali funzioni prendono il nome di funzioni
membro della classe. Esse operano sui dati dell’oggetto e prendono
il nome di metodi della classe.
Supponiamo di voler permettere alla nostra classe Rettangolo di
effettuare il calcolo della sua area:
#include <iostream>
using namespace std;
class Rettangolo
{
public:
int x;
int y;
int Area()
{
return x*y;
}
};
int main()
{
cout << "La mia classe rettangolo" << endl;
Rettangolo rettangolo1;
//imposto valori
rettangolo1.x = 3;
rettangolo1.y = 6;
cout << "L'area del rettangolo vale: " <<
rettangolo1.Area() << endl;
return 0;
}

Osservando con attenzione il codice notiamo come all’interno della

classe Rettangolo abbiamo inserito una semplice funzione di nome
Area:
…
int Area()
{
return x*y;
}
…

Questa funzione non fa altro che restituire a chi la chiama il prodotto
delle variabili x e y attraverso la parola chiave return. Tali variabili
sono dichiarate pubbliche all’interno della classe stessa.
Nell’esempio si vede anche come, tramite l’operatore punto, sia
possibile richiamare la funzione Area dell’istanza dell’oggetto
rettagolo1 così come richiamiamo una qualsiasi altra variabile
presente nella classe; scriviamo infatti rettangolo1.Area() direttamente
nell’istruzione di stampa cout.
Si dice, in questo caso, che si invia un messaggio all’oggetto in
questione.
Spesso una classe è formata da diverse funzioni membro e la loro
implementazione all’interno della classe può generare problemi
relativi a una difficile manutenzione del codice.
Tale implementazione interna viene spesso definita inline. Esiste
comunque la possibilità di implementare le funzioni all’esterno
della classe e di inserire all’interno di quest’ultima la sola parte
dichiarativa.
#include <iostream>
using namespace std;
class Rettangolo
{
public:
int x;
int y;
int Area();
};
int Rettangolo::Area()
{
return x * y;
}

int main()
{
cout << "La mia classe rettangolo" << endl;
Rettangolo rettangolo1;
//imposto valori
rettangolo1.x = 3;
rettangolo1.y = 6;
cout << "L'area del rettangolo vale: " <<
rettangolo1.Area() << endl;
return 0;
}

La cosa da notare nell’esempio appena mostrato è dato
dall’operatore :: (due volte due punti) nella implementazione della
funzione per collegare la funzione stessa alla classe alla quale deve
appartenere. Si tratta dell’operatore di visibilità già visto nel
contesto dei namespace.

Oggetti e istanze
Vale la pena a questo punto fermarsi un attimo per rafforzare
ulteriormente un concetto importante sull’uso delle classi. Una
classe, come già detto, rappresenta una sorta di stampo per un
oggetto. Una volta creato lo stampo è possibile produrre quanti
oggetti vogliamo, aventi quelle caratteristiche generali. Ovviamente,
però, ogni oggetto conserverà al suo interno le proprie caratteristiche
singolari (proprietà) così come, diversamente dalle struct, i propri
metodi. Dico diversamente dalle struct in quanto ribadisco che le
struct gestiscono unicamente dati e non operazioni. Tali operazioni,
ovvero i metodi dell’oggetto, agiranno sempre allo stesso modo (ma
su dati diversi) indipendentemente dall’oggetto specifico a cui sono
applicati. La singola copia dell’oggetto creato prende il nome di
istanza dell’oggetto.
Per chiarire il concetto vi presento di seguito una modifica
all’esempio precedente, in cui provvedo a creare due istanze diverse
a partire dalla stessa classe Rettangolo:
#include <iostream>
using namespace std;
class Rettangolo
{
public:
int x;
int y;
int Area();
};
int Rettangolo::Area()
{
return x * y;
}
int main()
{
cout << "Rettangoli a confronto" << endl;
Rettangolo rettangolo1;
Rettangolo rettangolo2;
//imposto valori
rettangolo1.x = 10;

rettangolo1.y = 6;
rettangolo2.x = 8;
rettangolo2.y = 4;
cout << "L'area del primo rettangolo vale: " <<
rettangolo1.Area() << endl;
cout << "L'area del secondo rettangolo vale: " <<
rettangolo2.Area() << endl;
return 0;
}

Con un po’ di ragionamento si può essere persuasi che questo
esempio rafforzi le idee presentate in precedenza e relative al fatto
che la programmazione orientata agli oggetti sposti l’attenzione dalle
variabili globali ai singoli oggetti.

Come disegnare le classi
L’individuazione delle classi, e quindi degli oggetti più utili per
descrivere e gestire il problema che dobbiamo risolvere, è senza
ombra di dubbio un elemento cruciale di tutto il processo di
realizzazione del nostro codice.
L’esperienza insegna che tale lavoro richiede affinamenti successivi
che partono da una bozza iniziale fino a concretizzarsi in un disegno
finale della nostra applicazione software.
Non è a caso che utilizzo il termine disegno: la progettazione
prevede di norma, infatti, una schematizzazione grafica del nostro
software. Nel corso degli anni sono stati proposti vari strumenti e
metodi per realizzare tali schemi grafici; alla fine ha prevalso sul
campo un linguaggio vero e proprio noto come UML, ovvero Unified
Modeling Language, in italiano qualcosa del tipo “linguaggio di
modellazione unificato”.
È fuori dagli scopi di questa mia trattazione essere esaustivo
sull’UML, tuttavia mi sembra importante definire qualche elemento di
base. Ad esempio, tale linguaggio propone per la rappresentazione
delle classi un elemento grafico specifico. Si tratta di un rettangolo
separato in tre sezioni interne. Nella prima viene posto il nome della
classe, nel secondo l’elenco dei suoi attributi e infine nel terzo
l’elenco dei suoi metodi.
Nella Figura 19.1 vi mostro un esempio attinente alla nostra classe
Rettangolo.
Sono svariati i software disponibili sul mercato per aiutare nel
disegno dei modelli UML. Tra i tanti mi sento di proporre ArgoUML
(Figura 19.2). Tale applicativo, gratuito ed efficiente, è disponibile al
sito argouml.tigris.org.

Figura 19.1 – Il disegno della classe Rettangolo realizzato
utilizzando il linguaggio UML.

Figura 19.2 – Uno screenshot dell’applicativo ArgoUML.

20
L’arte del creare e del
distruggere
L’arte è l’immagine allegorica della

creazione.
Paul Klee
Nei precedenti capitoli abbiamo visto come un oggetto sia
caratterizzato da una serie di proprietà intrinseche all’oggetto stesso;
nel caso del rettangolo degli esempi proposti in precedenza
possiamo pensare ai valori x e y relativi ai propri lati. Affinché il
comportamento dell’oggetto sia consistente, di norma, tali grandezze
devono possedere dei valori iniziali per evitare, a puro titolo di
esempio, che una chiamata alla funzione Area generi dei risultati del
tutto inattesi e imprevedibili nel caso in cui non siano stati
preventivamente passati i valori per i lati.

Il costruttore
Per tali scopi, di norma, una classe deve includere al proprio interno
una funzione speciale, nota con il termine costruttore, che viene
chiamata automaticamente dal sistema quando viene creato un
nuovo oggetto e che consente quindi al programmatore di impostare
le inizializzazioni per le variabili membro. Il costruttore DEVE avere
come nome lo stesso identico nome della classe a cui appartiene e
non deve restituire nessun valore, nemmeno il valore void.
Facciamo subito un esempio, sempre riferendoci alla nostra classe
Rettangolo, espandendo il codice già precedentemente realizzato.
#include <iostream>
using namespace std;
class Rettangolo
{
public:
int x;
int y;
Rettangolo(int, int);
int Area();
};
Rettangolo::Rettangolo(int a, int b)
{
x = a;
y = b;
}
int Rettangolo::Area()
{
return x * y;
}
int main()
{
cout << "La mia classe rettangolo" << endl;
Rettangolo rettangolo1 (3, 6);
Rettangolo rettangolo2 (3, 17);
cout << "L'area del primo rettangolo vale: " <<
rettangolo1.Area() << endl;
cout << "L'area del secondo rettangolo vale: " <<
rettangolo2.Area() << endl;

return 0;
}

La prima cosa da notare nel codice proposto è il fatto che ho
aggiunto il costruttore con la seguente implementazione
dell’omonima funzione Rettangolo:
Rettangolo::Rettangolo(int a, int b)
{
x = a;
y = b;
}

Come si evince dal codice, quando il costruttore viene chiamato in
fase di creazione dell’oggetto gli vengono passati i valori dei suoi lati.
Tali valori vengono di fatto assegnati alle variabili x e y che
rappresentano le proprietà dell’oggetto stesso.
Ho poi inserito il prototipo del costruttore all’interno del corpo della
classe scrivendo:
Rettangolo(int, int);

Una seconda cosa importante da sottolineare è che la funzione
costruttore non può essere chiamata direttamente ma SOLO
attraverso la procedura di creazione dell’oggetto.

Il distruttore
Il mondo cerca un suo equilibrio e ciò che nasce, inesorabilmente,
arriva a una sua fine; ciò vale anche per gli oggetti del C++ per i
quali, nel momento in cui cessano di vivere, è necessario
predisporre un’apposita funzione nota come distruttore.
Il distruttore è una funzione il cui nome è identico a quello della
classe, come per il costruttore, ma è preceduto dal carattere
speciale “~”, noto come tilde: nel nostro caso il distruttore sarà:
~Rettangolo();

Per realizzare da tastiera il simbolo ~ utilizzando il Sistema
Operativo Windows è necessario tenere premuto il tasto
NOTA ALT e digitare sul tastierino numerico in successione i tasti
1, 2 e 6. Sui sistemi Apple di tipo Mac è sufficiente tenere
premuto il tasto ALT e premere il tasto 5.
Il distruttore viene chiamato in maniera automatica nel momento in
cui l’oggetto cessa la propria esistenza. Ciò avviene, ad esempio, in
maniera del tutto naturale nel momento in cui il nostro programma
termina. Per avere dimostrazione di tale evento definiamo all’interno
della classe Rettangolo il distruttore come segue:
Rettangolo::~Rettangolo()
{
cout << "Rettangolo eliminato!";
}

Ho usato una semplice chiamata a cout per verificare l’effettiva
esecuzione del codice del distruttore. In effetti è possibile rendersi
conto della stampa a video del messaggio subito prima la chiusura
dell’applicazione. Per farlo è sufficiente creare nel main un qualsiasi
oggetto di tipo Rettangolo; ad esempio:
int main()
{

cout << "Durata della vita" << endl;
Rettangolo rettangolo1 (2, 4);
return 0;
}

Potrete quindi verificare che l’applicazione mostrerà a video la frase
"Rettangolo eliminato!" inserita sullo stream di output cout nel
distruttore della classe. È intuitivo che in questo contesto ci
rifacciamo a un esempio “forzato” per far comprendere il
funzionamento del distruttore. In generale, invece, il codice del
distruttore potrebbe essere impiegato, ad esempio, per deallocare,
cioè rilasciare al Sistema Operativo, eventuale memoria richiesta
dalla creazione dell’oggetto.

La compilazione separata
Ormai dovrebbe essere chiaro che l’uso del linguaggio C++ è
motivato dalla possibilità di creare codice complesso riducendo al
minimo le problematiche a esso legate. In ogni caso è banale
considerare che un programma di una certa complessità richieda,
per quanti siano i nostri sforzi di ottimizzazione, un grosso e a volte
enorme numero di linee di codice sorgente.
Finora abbiamo realizzato i nostri programmi utilizzando un unico file
di codice, il file main.c nel caso del linguaggio C e il file main.cpp nel
caso del C++. Vi renderete conto che gestire un unico file di migliaia
o decine di migliaia di righe di codice può essere un’impresa
improba sia per il programmatore sia per il compilatore. Per il
programmatore il problema risiede nel riuscire a mettere le mani in
maniera agevole nelle varie sezioni del codice, mentre il compilatore
farà una fatica notevole per ricompilare l’intero enorme file a ogni
piccola modifica del codice sorgente.
L’idea, dovrebbe essere chiaro, consiste nell’organizzare il nostro
codice in differenti file, ognuno dei quali conterrà uno specifico e
omogeneo pezzo di codice. Il termine che ho utilizzato, omogeneo,
vuole riferirsi al fatto che il codice non può essere separato in
differenti file in maniera indiscriminata, ma andrà, ovviamente,
raggruppato in base agli specifici dati e alle specifiche operazioni su
tali dati che i vari pezzi di codice dovranno gestire. Di norma
l’organizzazione del codice nei vari file viene fatta proprio in virtù
delle classi e quindi dei relativi oggetti. Se ci pensate un attimo, in
effetti, quando creiamo un modello del problema e ragioniamo sugli
oggetti da inserire nel mondo del nostro applicativo, stiamo appunto
modularizzando, ovvero creando moduli logici separati. Non è detto
che ogni classe debba essere gestita per forza di cose in un file
separato; in ogni caso, tale ragionamento può essere un punto di
partenza. Quello che in definitiva si può decisamente fare è porre il
codice della classe in un file separato.
È giunto ora il momento di fare un esempio concreto, che si baserà
ancora sulla nostra classe Rettangolo. Creiamo innanzitutto un nuovo

progetto. Successivamente creiamo un nuovo file che chiameremo
Rettangolo.cpp che conterrà la logica di funzionamento della nostra
classe.
Per farlo, supponendo di utilizzare l’ambiente Code::Blocks,
clicchiamo sulla voce di menu File - New - File…
Dalla finestra di dialogo che viene mostrata a video, e presentata in
Figura 20.1, selezioniamo la voce C/C++ source.

Figura 20.1 – La scelta di un nuovo file di codice sorgente di tipo
C/C++.
Come poi riportato in Figura 20.2, scegliamo e selezioniamo la
cartella corrente del nostro progetto e, una volta digitato il nome del
nuovo file, confermiamo l’operazione. Nella finestra di dialogo in
questione facciamo anche attenzione a porre un segno di spunta,
come riportato in figura, sulle voci “Debug” e “Release” in relazione
all’opzione “Add file to active project”.
All’interno del nuovo file possiamo riscrivere la sola implementazione
della classe Rettangolo, cioè:
//File Rettangolo.cpp

Rettangolo::Rettangolo(int a, int b)
{
x = a;
y = b;
}
Rettangolo::~Rettangolo()
{
cout << "Fine operazioni";
}
int Rettangolo::Area()
{
return x * y;
}

Figura 20.2 – La scelta del nome e del percorso per un nuovo file di
tipo C/C++.
Dico la sola implementazione in quanto nel file .cpp andrà il codice
vero e proprio mentre la definizione della classe andrà in un
ulteriore file noto come file header o file di intestazione. Abbiamo
sistematicamente utilizzato tali file nei nostri include per far uso delle
funzioni predefinite messe a disposizione dall’ambiente. La
differenza sostanziale rispetto a ciò che stiamo facendo ora risiede

banalmente nel fatto che saremo noi stessi a realizzare tali file da
includere nel progetto.
Vediamo dunque come creare un file header. Per farlo usiamo una
procedura simile a quella relativa al file .cpp. Clicchiamo infatti sulla
voce di menu File - New – File. Dalla finestra di dialogo, visibile in
Figura 20.3, selezioniamo la voce C/C++ header.
Confermiamo la posizione del file e il nome Rettangolo.h. Nella Figura
20.4 vi riporto la finestra in oggetto.
Il file appena creato conterrà le seguenti direttive:
#ifndef RETTANGOLO_H_INCLUDED
#define RETTANGOLO_H_INCLUDED
#endif // RETTANGOLO_H_INCLUDED

Queste hanno lo scopo di evitare che le informazioni presenti
all’interno del file vengano incluse più di una volta. Tali direttive sono
note con il termine di include guard.

Figura 20.3 – La selezione di un nuovo file di tipo C/C++ header.

Figura 20.4 – La scelta del nome e del percorso per il file header.
In realtà, al momento il file è vuoto. Ciò che dobbiamo quindi fare è
inserire all’interno del file header in questione le specifiche della
classe Rettangolo .
//File Rettangolo.h
#ifndef RETTANGOLO_H_INCLUDED
#define RETTANGOLO_H_INCLUDED
class Rettangolo
{
public:
int x;
int y;
Rettangolo(int, int);
~Rettangolo();
int Area();
};
#endif // RETTANGOLO_H_INCLUDED

All’interno del file header definiamo dunque l’interfaccia di utilizzo
della classe: le variabili membro, il costruttore, il distruttore e la
funzione Area.
Passiamo infine all’utilizzo della nostra classe all’interno della

funzione main del file principale. Il codice potrebbe essere il seguente:
#include <iostream>
using namespace std;
int main()
{
cout << "Rettangoli e moduli" << endl;
Rettangolo rettangolo1 (2, 4);
cout << "L'area del rettangolo e': " << rettangolo1.Area() <<
endl;
return 0;
}

dove abbiamo semplicemente istanziato un nuovo oggetto rettangolo1
rispetto al quale ne stampiamo l’area.
Sembrerebbe tutto corretto e al posto giusto. Non proprio; almeno,
non ancora. Se proviamo a compilare ci verrà segnalato infatti un
errore del tipo:
In function 'int main()':
error: 'Rettangolo' undeclared (first use this function)

Il motivo, d’altronde banale, di tale errore è dato dal fatto che i file
main.cpp, Rettangolo.h e Rettangolo.cpp non sono tra di essi collegati e
che quindi il file main.cpp non sa nulla della classe Rettangolo.
È in questo contesto che entrano in gioco i file header. Tali file,
anch’essi semplici file di testo ma con estensione .h, servono a
definire l’interfaccia della classe e a renderla quindi nota a chi
intende utilizzare la classe stessa.
Per completare l’opera dovremo quindi porre nel file main.cpp e nel file
Rettangolo.cpp
il collegamento al file header contenente la
dichiarazione dell’interfaccia della classe. Per richiamare il file
scriviamo:
#include "Rettangolo.h"

In effetti tale tecnica di inclusione è quello che stiamo utilizzando sin
dall’inizio del nostro viaggio, addirittura dal contesto del C in cui
usavamo la direttiva #include <stdio.h> per includere le funzionalità
standard di input-output.

Tutto ciò va sotto il nome di programmazione modulare. Si tratta in
buona sostanza, come già detto, di organizzare il codice in moduli
separati ma interdipendenti. Lo scopo è quello di facilitare, ancora
una volta, il riuso del codice. Ciò di cui abbiamo bisogno è ottenere
un risultato e a volte non siamo affatto interessati a sapere come tale
risultato sia ottenuto. Utilizziamo i moduli come entità di cui
conosciamo le modalità di utilizzo ma non quelle di ottenimento del
risultato: siamo nuovamente al concetto di “scatola nera” e di utilizzo
di blocchi precostituiti di codice.
Per mettere infine ordine in quanto abbiamo realizzato, vi riporto il
codice completo dei tre file facendovi notare che ho dovuto
aggiungere nel file Rettangolo.cpp i riferimenti al namespace std e alla
libreria iostream in quanto il distruttore fa uso dell’istruzione cout.
//File main.cpp
#include <iostream>
#include "Rettangolo.h"
using namespace std;
int main()
{
cout << "Rettangoli e moduli" << endl;
Rettangolo rettangolo1 (2, 4);
cout << "L'area del rettangolo e': " << rettangolo1.Area()
<< endl;
return 0;
}
//File Rettangolo.h
#ifndef RETTANGOLO_H_INCLUDED
#define RETTANGOLO_H_INCLUDED
class Rettangolo
{
public:
int x;
int y;
Rettangolo(int, int);
~Rettangolo();
int Area();
};
#endif // RETTANGOLO_H_INCLUDED
//File Rettangolo.cpp
#include <iostream>
#include "Rettangolo.h"

using namespace std;
Rettangolo::Rettangolo(int a, int b)
{
x = a;
y = b;
}
Rettangolo::~Rettangolo()
{
cout << "Fine operazioni";
}
int Rettangolo::Area()
{
return x * y;
}

Ci siamo quasi ma un’ultima osservazione è comunque importante.
Forse avrete notato la differenza tra l’inclusione realizzata in
automatico dal sistema, come ad esempio: #include <iostream>, e
l’inclusione realizzata “a mano” da noi: #include "Rettangolo.h". Niente
di particolarmente misterioso: l’uso delle parentesi angolari è relativo
ai file di sistema predefiniti. Il compilatore ricercherà i file di include
indicati all’interno dei percorsi dell’ambiente e del compilatore. Nel
caso invece dei doppi apici il compilatore farà riferimento alla cartella
corrente relativa al file che realizza l’inclusione.

21
Il polimorfismo del C++
I nostri pensieri danno forma a ciò
che noi supponiamo sia la realtà.
Isabel Allende
Abbiamo visto come un primo elemento base dei linguaggi di
programmazione a oggetti sia l’incapsulamento dei dati. Un secondo
elemento considerato imprescindibile per tali linguaggi è dato dal
cosiddetto comportamento polimorfico o più semplicemente
polimorfismo.
Con tale termine ci si riferisce al fatto che uno stesso elemento di
programmazione può esibire comportamenti diversi a seconda di
specifiche circostanze.

Figura 21.1 – Due diverse personalità dell’uomo ragno.

Monomorfismo e polimorfismo
Per chiarire il concetto vi invito a pensare a una funzione del
linguaggio C così come vista nella sezione riguardante appunto tale
linguaggio. Una volta definito il prototipo della funzione e indicati il
numero e il tipo di argomenti, tale funzione deve essere
esplicitamente chiamata con tali argomenti, pena segnalazione di
errore da parte del compilatore. Si tratta dunque di monomorfismo.
Il C++ prevede invece un comportamento polimorfico con una
tecnica nota come overloading (sovraccarico). È così possibile
definire più copie della stessa funzione, aventi lo stesso nome, che
differiscono tuttavia per il numero di argomenti gestiti.
Supponiamo ad esempio di realizzare una funzione C che prenda in
input un intero e che serva per inserire in fase di stampa tante
tabulazioni quante indicate dall’intero input della funzione stessa.
Chiamiamo tale funzione Tab e scriviamo il seguente codice:
#include <stdio.h>
#include <stdlib.h>
void Tab(int);
int main()
{
Tab(3);
printf("Test tabulazioni C!\n");
return 0;
}
void Tab (int n)
{
int i;
for (i=1; i<=n; i++)
{
printf("\t");
}
}

Una volta definiti il tipo, int nel nostro caso, e il numero di parametri,
sempre nel nostro caso uno solo, tale funzione deve essere per
forza di cose chiamata in tal modo. Nel nostro esempio chiamo la

funzione con Tab(3); per inserire tre tabulazioni. Ormai siete esperti e
potete capire che in maniera molto banale la funzione usa un ciclo
for, da 1 a n, cioè il valore input della funzione, e a ogni iterazione
stampa il qualificatore ‘\t’ per inserire un carattere di tabulazione.
Per intenderci, se provassimo a chiamare la funzione Tab scrivendo
semplicemente Tab(); volendo ad esempio supporre di voler inserire
un solo tabulatore, otterremmo un errore del tipo:
error: too few arguments to function 'Tab'

Per la serie: troppi pochi argomenti passati alla funzione Tab. In effetti
Tab si aspetta almeno un argomento. La cosa che il C++ consente di
fare rispetto al C è definire più versioni della stessa funzione che
differiscono per il numero di argomenti. Ad esempio, in C++
potremmo scrivere due differenti versioni della funzione Tab: la prima
che non prende in input alcun argomento e che quindi in maniera
predefinita decidiamo che stampi un solo tabulatore; la seconda,
invece, che prendendo in input un intero stampa il corrispondente
numero di tabulazioni. Di seguito una possibile codifica:
#include <iostream>
using namespace std;
void Tab(void);
void Tab(int);
int main()
{
Tab();
cout << "Test" << endl;
Tab(2);
cout << "tabulazioni" << endl;
return 0;
}
void Tab (void)
{
cout << "\t";
}
void Tab (int n)
{
int i;
for (i=1; i<=n; i++)
{
cout << "\t";

}
}

Se provassimo a realizzare una cosa simile con il C otterremmo un
messaggio di errore del tipo:
error: conflicting types for 'Tab'

a segnalarci l’impossibilità di compilare a causa di un conflitto sui tipi
per la funzione in esame.
Per comprendere meglio la portata della questione, in particolare nel
contesto degli oggetti, ci rifacciamo all’esempio della nostra classe
rettangolo. Supponiamo che in determinate circostanze si voglia
creare un rettangolo di tipo predefinito che abbia, ad esempio,
dimensioni generiche e predefinite per base e altezza. Risulta
comodo in questa situazione aggiungere un nuovo costruttore che
non prevede argomenti e che una volta chiamato assegna in
automatico base e altezza, appunto, con valori predefiniti.
#include <iostream>
using namespace std;
class Rettangolo
{
public:
int x;
int y;
Rettangolo(int, int);
Rettangolo();
int Area();
};
Rettangolo::Rettangolo(int a, int b)
{
x=a;
y=b;
}
Rettangolo::Rettangolo()
{
x=2;
y=1;
}
int Rettangolo::Area()
{
return x * y;

}
int main()
{
cout << "La mia classe rettangolo" << endl;
Rettangolo rettangolo1 (3, 6);
Rettangolo rettangolo2;
cout << "L'area del primo rettangolo vale: " <<
rettangolo1.Area() << endl;
cout << "L'area del secondo rettangolo vale: " <<
rettangolo2.Area() << endl;
return 0;
}

La cosa da notare è che creando il secondo rettangolo con:
Rettangolo rettangolo2;

non abbiamo passato valori al costruttore e che quindi il sistema
sceglie automaticamente la specifica implementazione del
costruttore assegnando a x il valore 2 e a y il valore 1.
Una nota importante riguarda il fatto che la chiamata avviene senza
l’utilizzo delle parentesi tonde. La seguente forma sarebbe quindi
errata:
Rettangolo rettangolo2(); //ERRATO

In definitiva l’overloading consiste nella possibilità di creare più
versioni di una stessa funzione che possono però differire nel
numero degli argomenti e, volendo, anche nel tipo degli argomenti
stessi. Il numero e il tipo di argomenti prende il nome di firma della
funzione.

Una firma per la classe
L’esempio mostrato in precedenza fa riferimento a una firma della
funzione che differisce per il numero di argomenti. Può essere
interessante osservare come si verifichi un comportamento
polimorfico in presenza di una firma che differisce per il tipo di
argomenti. Di seguito vi mostro una classe minimale, che ho
chiamato Calcolatrice, che potrebbe essere utilizzata per realizzare
tutta una serie di operazioni aritmetico-matematiche. Trattandosi di
un contesto d’esempio, nella classe definisco una sola operazione
relativa alla divisione tra due numeri:
#include <iostream>
using namespace std;
class Calcolatrice
{
public:
int x;
int y;
void Dividi(int, int);
void Dividi(double, double);
};
void Calcolatrice::Dividi(int a, int b)
{
cout << a/b;
}
void Calcolatrice::Dividi(double a, double b)
{
cout << a/b;
}

Ponete attenzione alla funzione Dividi. Questa ha due diverse
implementazioni. La prima prevede come argomenti due interi,
mentre la seconda prevede come input due numeri di tipo double.
Potrete verificare che richiamando la funzione Dividi, passandole
due interi, si otterrà come risultato un numero intero privando l’output
di una possibile parte decimale. Ad esempio, scrivendo nel main:
Calcolatrice c;
c.Dividi(5,2);

otterremo come risultato il valore 2. D’altra parte con il seguente
codice:
Calcolatrice c;
c.Dividi(5.0,2.0);

otterremo come risultato il valore 2.5. Ciò è dovuto al fatto che il
compilatore riesce a selezionare la funzione membro da richiamare
individuando il tipo di argomenti che vengono passati. Aggiungendo
zero come parte decimale, il compilatore determina che si tratta di
un numero con la virgola e lo assegna come input alla funzione che
prende in input i valori double.

Codice e ambiguità
Come si evince dall’esempio appena visto, il compilatore è in grado
di associare la giusta funzione in base agli argomenti della firma
della funzione stessa. Tuttavia, come sempre, possono verificarsi
problemi di comprensione quando vi sono delle situazioni di
ambiguità. Una prima verifica, molto banale, di tali problemi è
relativa alla situazione per la quale richiamiamo la funzione
dell’esempio precedente come segue:
Calcolatrice c;
c.Dividi(5.0, 2);

Il compilatore ci segnalerà qualcosa del tipo:
error: call of overloaded 'Dividi(double, int)' is ambiguous
candidates are:
void Calcolatrice::Dividi(int, int)
void Calcolatrice::Dividi(double, double)

Si può facilmente intuire il motivo dell’errore da una sommaria
traduzione di quanto ci riferisce il compilatore: “la chiamata della
funzione in overload Dividi(double, int) è ambigua”. Infatti,
proseguendo nell’esame dell’errore, si scopre che i candidati per la
funzione sono effettivamente due. Tuttavia nessuno prende in input
come primo argomento un double e come secondo un intero. Il
primo numero, 5.0, viene considerato infatti dal compilatore come
double, mentre il secondo, non avendo parte decimale, viene
considerato un intero.
Un’altra situazione di ambiguità sicuramente più particolare, e che
potrebbe causare qualche perplessità, è relativa al caso in cui
dovessimo dichiarare la funzione Dividi come segue:
void Dividi(float, float);

Anche in questo caso il compilatore ci porrebbe di fronte a un errore
di ambiguità nel momento in cui dovessimo richiamare la funzione
scrivendo: c.Dividi(5.0,2.0);
Ciò è causato dal fatto che il compilatore forza in automatico, come

già detto, i numeri con la virgola 5.0 e 2.0 a essere di tipo double.
Avendo predisposto la firma con valori di tipo float potete spiegarvi
immediatamente la causa dell’errore di compilazione.
Una possibile soluzione per evitare l’errore potrebbe essere quella di
castare (effettuare un cast) in maniera esplicita dei valori forzandoli
a essere di tipo float scrivendo:
c.Dividi((float)5.0, (float)2.0);

Ovviamente la bontà di una tale scelta è molto dubbia. Così come è
estremamente discutibile la scelta di stampare direttamente i valori
risultanti dall’operazione di divisione tramite cout. Si ribadisce in
questo ambito che gli esempi sono per forza di cose elementi
atomici che devono essere considerati per quello che sono: esempi
d’uso di una certa tecnologia in un contesto molto limitato,
predisposto e privo di fronzoli per massimizzare il focus sul dettaglio
che si sta presentando di volta in volta. D’altronde ripeto, fino alla
noia, che un linguaggio non si impara sul serio se non scrivendo
codice che risolve problemi specifici, quindi “sporcandosi le mani”.

Quando il numero conta: array di
oggetti
Di norma è abbastanza improbabile dover creare una classe per
gestire un singolo oggetto di un dato tipo. Più spesso si ha necessità
di un insieme di oggetti tutti dello stesso tipo ma con differenti valori
relativi alle specifiche proprietà. Il modo più semplice per gestire tali
elenchi di oggetti è quello di creare un array in cui ogni elemento è
proprio un oggetto. Il discorso è del tutto analogo agli array di
strutture.
Supponiamo allora di voler sfruttare la nostra classe Rettangolo per
definire una serie di cornici, eventualmente da disegnare a schermo.
Per farlo possiamo definire un array di oggetti Rettangolo come segue:
Rettangolo cornici[10];

In questo modo definiamo un array di 10 oggetti di tipo Rettangolo. La
cosa che vi invito a considerare è che tale operazione è possibile
solo nel momento in cui abbiamo definito, all’interno della classe, un
costruttore di default che non riceve parametri. Dobbiamo infatti
considerare che nel momento in cui dichiariamo un tale array, il
sistema dovrà creare ben 10 oggetti di quel tipo specifico. Per farlo
dovrà chiamare per forza di cose, in maniera del tutto automatica, il
costruttore predefinito. Se tale costruttore dovesse essere gestito
ricevendo degli specifici argomenti avremmo davvero serie difficoltà.
Nel caso in cui dovesse essere necessario un solo parametro per il
singolo oggetto dell’array, potremmo richiamare la dichiarazione
dell’array in questione passando una specifica lista di parametri, tra
parentesi graffe, così come facciamo per l’inizializzazione di un array
classico. Dovremmo cioè scrivere qualcosa del genere:
Rettangolo cornici [] = {2, 4, 6, 8, 10, 1, 3, 5, 7, 9};

Ogni singolo valore presente tra parentesi graffe rappresenta il
valore passato al costruttore del singolo oggetto. Deve essere quindi
chiaro che per poter gestire questa inizializzazione deve essere

presente, tra i vari possibili costruttori, uno specifico che gestisce in
input un solo parametro. Ovviamente, una tale organizzazione mal si
presta al nostro contesto di esempio relativo al rettangolo. Infatti, in
generale, può avere poco senso inizializzare un rettangolo
passandogli uno solo dei suoi lati. Una tale organizzazione avrebbe
sicuramente più consistenza nel caso di una figura geometrica tipo il
quadrato, in cui anche passando un solo valore per un suo lato,
essendo tali lati uguali tra loro, non ci sarebbero situazioni di
ambiguità.

Puntare sulla classe
Un aspetto interessante che ancora non abbiamo toccato è relativo
al fatto che è possibile, come ovviamente ci saremmo aspettati,
riferirsi a un oggetto attraverso un puntatore a esso. Si tratta di un
approccio del tutto simile a quanto visto per i puntatori alle strutture.
In merito alla nostra classe Rettangolo, volendo utilizzare un puntatore
potremmo scrivere:
int main()
{
cout << "Rettangoli e puntatori" << endl;
Rettangolo r;
Rettangolo *pr;
pr = &r;
cout << "L'area del rettangolo vale: " << pr->area()
endl;
return 0;
}

<<

In questo caso mi sono limitato a presentare il solo main in quanto la
classe e il restante codice per la sua definizione lo riteniamo
immutato rispetto agli esempi precedenti. In tale esempio, pr
rappresenta un puntatore all’oggetto r di tipo Rettangolo. La cosa da
notare, ma d’altronde già nota in quanto già vista per le struct del C,
è la notazione con la freccia -> utilizzata per accedere alle funzioni
membro della classe nel momento in cui effettuiamo tale accesso
tramite puntatori.

Da punto a punto: puntare su se
stessi
Un altro aspetto di estremo interesse, e con enormi risvolti pratici
collegato ai puntatori e alla dichiarazione di una classe, è dato dal
fatto che è possibile creare un puntatore a un dato oggetto come
membro dell’oggetto stesso e farlo puntare a un altro oggetto del
proprio stesso tipo. Un esempio è indispensabile. Per realizzarlo,
tuttavia, lasciamo per un attimo la nostra classe Rettangolo e
immaginiamo di dover gestire dei segmenti fatti da più punti in un
classico piano cartesiano, con tanto di ascisse (asse x) e ordinate
(asse y).

Figura 21.2 – Un punto nel piano cartesiano.
La volontà di realizzare un nuovo esempio è motivata da due
considerazioni. La prima è che più esempi riuscite a tirar fuori nel
vostro viaggio all’interno della programmazione e maggiori
opportunità di crescita avrete all’interno di tale mondo. La seconda
considerazione è che creare una successione di oggetti di tipo
rettangolare è meno probabile piuttosto che la creazione di una
successione di punti che vanno a rappresentare una serie di
segmenti: quella che in gergo viene anche chiamata spezzata. Si

tratta in buona sostanza di un esempio maggiormente realistico. Ciò
che vogliamo quindi realizzare è un insieme di punti tali che ognuno
di essi possa contenere un puntatore a un punto successivo,
ovviamente generato dalla stessa classe. Vediamo innanzitutto
come costruire la classe Point. Utilizzando la schematizzazione tipica
dell’UML vista in precedenza possiamo realizzare la struttura
proposta nella Figura 21.3.

Figura 21.3 – Una rappresentazione della classe Point tramite UML.
Ogni singolo punto è costituito da una coppia di coordinate e da un
puntatore a un punto successivo. Può essere di aiuto vederlo sotto
forma grafica per cui vi propongo la Figura 21.4.

Figura 21.4 – Una rappresentazione grafica della classe Point.
Da tale figura è palese la sezione dei dati contenuti nel punto e il
collegamento, next, al punto successivo.
Una possibile implementazione del codice della classe potrebbe
essere allora la seguente:
#include <iostream>
using namespace std;
class Point

{
public:
float x;
float y;
Point *next;
Point();
Point(float, float);
};
Point::Point()
{
x=0;
y=0;
}
Point::Point(float a, float b)
{
x=a;
y=b;
}
int main()
{
cout << "Segmenti!" << endl;
return 0;
}

Cominciamo con una classe davvero minimale. La cosa che vi faccio
subito osservare è la scelta dei nomi in inglese per gli elementi della
classe: Point per la classe stessa e next per il puntatore al punto
successivo.
Il motivo è dato dal fatto che spesso anche noi italiani preferiamo
utilizzare tale lingua, per certi aspetti universale, per denominare
diversi elementi di programmazione. L’inglese è infatti molto tecnico
ed essenziale e ben si presta a essere utilizzato nel codice sorgente.
Per il resto la classe Point fin qui costruita è assolutamente
essenziale. Ho definito i punti x e y come float per poter gestire
coordinate con la virgola. La cosa che balza all’occhio è il membro
dichiarato come Point *next; ovvero un puntatore, che chiamiamo next
(successivo), a un oggetto di tipo Punto. Per il resto possiamo
osservare i due costruttori, ovvero le funzioni con lo stesso nome
della classe, che abbiamo detto essere richiamati nel momento in cui
viene creato un oggetto.
Il primo costruttore, che non prende argomenti, ci serve per creare

punti di default nell’origine degli assi cartesiani (0, 0). Il secondo
costruttore ci serve per creare punti con coordinate ben precise
eventualmente richieste dal problema.
Per dare senso al programma dobbiamo ovviamente creare una
serie di punti. Supponiamo di realizzarne solo tre; modifichiamo
allora il nostro main aggiungendo quanto segue:
Point a(1,1);
Point b(3,1);
Point c(2,2);

Dove banalmente abbiamo costruito tre punti (a, b, c) con le
coordinate passate tramite la funzione costruttore. Tuttavia, fino a
questo momento si tratta di tre punti nello spazio indipendenti gli uni
dagli altri. Per legarli tra loro, volendo ad esempio formare un
triangolo utilizzando i punti come vertici, dobbiamo collegare il
puntatore del primo punto al secondo e quello del secondo al terzo.
Lasciamo il terzo punto con puntatore nullo, che indicherà il fatto che
si tratta di un punto terminale della sequenza.
Scriviamo allora:
a.next = &b;
b.next = &c;

avendo così indicato che il puntatore next di a punta all’indirizzo di b
(abbiamo scritto &b). Inoltre il puntatore next di b punta all’indirizzo di c
(avendo scritto &c).
Volendo infine stampare le coordinate dei punti possiamo scrivere:
cout << "Le coordinate dei punti sono: " << endl;
cout << "Punto a: " << a.x << " " << a.y << endl;
cout << "Punto b: " << a.next->x << " " << a.next ->y << endl;
cout << "Punto c: " << b.next->x << " " << b.next ->y << endl;

Come si può comprendere abbastanza facilmente, le coordinate del
primo punto le stampiamo senza problemi facendo riferimento
direttamente ai membri x e y. Per il punto b facciamo vedere come
possiamo accedere a esso a partire dal punto a. Analogamente,
l’accesso al punto c lo otteniamo a partire dal puntatore presente nel
punto b.

Overloading anche sugli operatori
Abbiamo visto come sia possibile ampliare le modalità di
comportamento di determinate funzionalità attraverso l’overloading,
facendo sì che una data funzione sia specializzata rispetto a specifici
argomenti: la firma della classe. La potenza del C++ va anche oltre.
È infatti possibile ampliare le possibilità di applicazione addirittura
degli operatori stessi. Ciò rientra nelle caratteristiche di estendibilità
del linguaggio.
Per intenderci, gli operatori sono gli strumenti che ci consentono
appunto di operare efficacemente sui dati. Un classico esempio di
operatori applicati ai dati è qualcosa del tipo:
a + b

Sorpresi dalla semplicità? In effetti, a e b rappresentano i dati e il
simbolo + rappresenta l’operatore che applichiamo a tali dati. Siamo
talmente abituati a tali formalismi che riconosciamo subito
l’operatore di somma e attribuiamo mentalmente un valore numerico
ai simboli a e b.
Gli operatori non fanno altro che comportarsi come delle vere e
proprie funzioni, in quanto prendono in input dei dati ed elaborandoli
restituiscono altri dati.
Ogni linguaggio porta con sé una serie di operatori standard. Per
avere un esempio specifico possiamo ripensare all’intera carrellata
di operatori aritmetici, relazionali e logici visti per il linguaggio C. Ma
ancora, possiamo fare riferimento agli operatori di input e output, >> e
<<, più recentemente incontrati in relazione al C++.
Nella normalità dei casi tali operatori si applicano ai tipi di dati
standard presenti nel linguaggio: numeri interi, numeri con la virgola
ecc. Tali tipi di dati sono quelli nativi del linguaggio. Il termine nativo
indica che si tratta di dati che nascono con il linguaggio stesso e che
sono messi a disposizione in maniera del tutto naturale.
Vi sono tuttavia dei casi in cui i dati sono di tipo più complesso e le
classiche operazioni, anche quelle banali come la somma, diventano
sicuramente più complesse da gestire. Se infatti è chiaro cosa

significhi a+b quando a e b sono numeri interi, ci si può domandare
come si realizzi la stessa operazione di “somma” se a e b sono delle
sequenze di caratteri. Ebbene, per overloading degli operatori si
intende la possibilità di estendere l’uso di simboli, quali +, -, *, / e
tanti altri, a essere applicati a dati di tipo generico.
Un po’ di precisazioni possono risultare importanti. La prima è
relativa al fatto che, sebbene si possa effettuare l’overload di quasi
tutti gli operatori, per alcuni di essi (pochissimi) tale overload è
impossibile come ad esempio per gli operatori . e ::.
Un’altra osservazione importante è che con l’overload è possibile
ampliare il campo di azione di un operatore esistente ma non è
assolutamente possibile creare nuovi simboli di nuovi operatori.
Infine, bisogna sottolineare come l’overloading non possa cambiare
il numero e l’ordine degli argomenti gestiti dall’operatore. Per
intenderci, se l’operatore è unario, cioè si applica a un solo
argomento, oppure è di tipo binario nel senso che si applica a due
argomenti come nel caso della somma, l’overloading dell’operatore
non può alterare tale situazione. Può essere interessante sapere che
esiste a tal proposito un termine specifico che indica il contesto di
applicabilità di un dato operatore rispetto al numero di operandi:
arietà. Con tale termine, ma anche con il termine rango, si indica
infatti il numero di argomenti (operandi) che una data funzione può
prendere in input.
Per applicare l’overloading a un operatore si utilizza in C++ una
specifica parola chiave operator seguita dal simbolo dell’operatore
per il quale si vuole effettuare l’overloading. Ad esempio: operator+
per sovraccaricare l’operatore +.
Per chiarire i meccanismi dell’overloading degli operatori possiamo
riferirci, per semplicità, all’operatore di somma + calato nel contesto
degli oggetti punto del piano cartesiano visti in precedenza. Ciò che
cerchiamo di fare è realizzare la somma di due punti del piano. Un
primo, velleitario, approccio potrebbe essere il seguente:
int main()
{
cout << "Somma di punti" << endl;
Point a(1,1);
Point b(3,1);

Point s;
s = a + b;
cout << "Le coordinate dei punti sono: " << endl;
cout << "Punto a: " << a.x << " " << a.y << endl;
cout << "Punto b: " << b.x << " " << b.y << endl;
cout << "Punto s: " << s.x << " " << s.y << endl;
return 0;
}

Dove ho riportato la sola sezione del main considerando l’altra parte,
relativa alla definizione dell’oggetto Point, immutata. Come è normale
attendersi, il codice genera un errore:
In function 'int main()' error: no match for 'operator+' in 'a
+ b'

Da tale errore risulta chiaro che il codice non sa gestire la somma tra
gli elementi a e b.
Per risolvere il problema in maniera elegante dobbiamo dunque
effettuare l’overloading dell’operatore somma per fare in modo che
tale operatore possa essere applicato, oltre che a normali valori
numerici, anche ai nostri oggetti di tipo Point. Codifichiamo dunque
quanto segue:
Point operator+ (Point &a, Point &b)
{
Point s;
s.x = a.x + b.x;
s.y = a.y + b.y;
return s;
}

Nel codice proposto è semplice osservare come si ottenga che le
coordinate del punto risultante dalla somma siano rispettivamente la
somma delle ascisse e delle ordinate dei due punti coinvolti
nell’operazione e come tali punti vengano passati per indirizzo.
Tale overloading è stato ottenuto con una semplice funzione. Più in
generale è possibile definire l’overloading di un operatore attraverso
un metodo della classe. Tale approccio, utilizzante i metodi della
classe, è indispensabile quando il risultato di un operatore è un
membro della classe stessa.
Vediamo allora una variante al codice appena visto per

implementare l’overloading dell’operatore somma di punti come
metodo della classe Point.
#include <iostream>
using namespace std;
class Point
{
public:
float x;
float y;
Point *next;
Point();
Point(float, float);
Point operator+ (Point);
};
Point::Point()
{
x=0;
y=0;
}
Point::Point(float a, float b)
{
x = a;
y = b;
}
Point Point::operator+ (Point p)
{
Point s;
s.x = x + p.x;
s.y = y + p.y;
return s;
}
int main()
{
cout << "Somma di punti" << endl;
Point a(1,1);
Point b(3,1);
Point s;
s = a + b;
cout << "Le coordinate dei punti sono: " << endl;
cout << "Punto a: " << a.x << " " << a.y << endl;
cout << "Punto b: " << b.x << " " << b.y << endl;
cout << "Punto s: " << s.x << " " << s.y << endl;
return 0;
}

Un primo elemento da notare è la seguente dichiarazione, presente
all’interno della definizione della classe Point:
Point operator+ (Point);

nella quale indichiamo la volontà di definire l’overloading
dell’operatore somma.
L’implementazione della funzionalità di overloading viene invece
realizzata dal codice seguente:
Point Point::operator+ (Point p)
{
Point s;
s.x = x + p.x;
s.y = y + p.y;
return s;
}

nel quale, nella prima riga, osserviamo che il primo Point si riferisce
al tipo di valore restituito mentre il secondo Point è il nome della
classe.

22
Ereditarietà
La

struttura

meravigliosamente

materiale

e

complessa

del

cervello è l’hardware che i nostri
computer cercano di imitare, mentre
tutte le esperienze che si vanno
accumulando, da quando si nasce a
quando

si

muore,

formano

un

software in continua evoluzione,
che noi chiamiamo anima.
Margherita Hack

L’evoluzione è senza ombra di dubbio la base su cui si poggia tutto
ciò che ci circonda e fondamento stesso della vita. Inscindibilmente
legato al concetto di evoluzione vi è il passaggio delle caratteristiche
proprie di una data generazione a quella successiva, in un anelito di
progresso di una genia comune ma che si migliora
sistematicamente. Tale passaggio di “memorie” da una generazione
all’altra viene normalmente definito ereditarietà.

Figura 22.1 – Charles Darwin: il padre della teoria dell’evoluzione.
Alla base della vita c’è dunque l’ereditarietà e la programmazione a
oggetti cerca di imitare tale aspetto dando la possibilità di creare
oggetti che ereditano, da altri oggetti già creati, una serie di
caratteristiche comuni per evitare, in buona sostanza, di dover
reinserire nei nuovi oggetti gli stessi elementi già presenti nei
“genitori”.
L’ereditarietà, con l’incapsulamento e il polimorfismo già visti in
precedenza, rappresentano i mattoni fondanti della programmazione
orientata agli oggetti.

L’ereditarietà del C++
Dopo aver compreso, almeno nelle linee generali, cosa si intende
per ereditarietà, vediamo in dettaglio come si implementa e sfrutta
tale caratteristica nel contesto specifico del linguaggio C++.
La classe di partenza è nota come classe base, o anche
superclasse, ed è la classe che definisce le caratteristiche del tutto
generali di in dato oggetto. A partire da tale classe si possono creare
altre classi, che ereditano dalla classe base una serie di
caratteristiche aggiungendone delle nuove più specifiche. Tali classi
prendono il nome di classi derivate o sottoclassi.
La sintassi per definire una classe derivata è la seguente:
class B : public class A
{
//
};

dove B è la classe che eredita le caratteristiche della classe A. In tale
dichiarazione vi sono due elementi importanti da sottolineare. Il
primo è l’uso del simbolo ‘:’, cioè due punti, che separa la classe
derivata (in questo caso B) dalla classe base (nel nostro caso A).
Un altro elemento fondamentale da notare è il cosiddetto
specificatore di accesso, nell’esempio qui sopra public, che
precede la dicitura class A.
Vi propongo ora un esempio concreto facendo riferimento a un
ipotetico programma per la gestione di figure geometriche sia nel
piano (noto come 2D, cioè due dimensioni) sia nello spazio (ovvero
3D).
Una classica figura geometrica dalla quale si può partire è il cerchio.
Il seguente codice definisce l’oggetto Cerchio con una proprietà raggio
e un metodo Area sicuramente autoesplicativi:
#include <iostream>
using namespace std;
class Cerchio
{

public:
float raggio;
float Area();
Cerchio (float);
};
Cerchio::Cerchio(float r)
{
raggio = r;
}
float Cerchio::Area()
{
return raggio * raggio * 3.14;
}
int main()
{
cout << "Test ereditarieta'" << endl;
Cerchio cerchio1(4.0);
cout << "L'area del cerchio e': " << cerchio1.Area() <<
endl;
return 0;
}

Molto banalmente, nel nostro esempio, il costruttore realizza un
nuovo cerchio con raggio di misura 4.0. Subito dopo ne stampiamo
l’area con l’apposita funzione membro. Una possibile
rappresentazione della classe può essere quella rappresentata in
Figura 22.2.

Figura 22.2 – La rappresentazione in UML della classe Cerchio.
Ovviamente il cerchio “vive” nel piano bidimensionale e la sua

estensione nelle tre dimensioni è il cilindro. È naturale immaginarsi
come tale cilindro possa ereditare in maniera immediata proprietà e
metodi del cerchio includendone però di propri, come ad esempio un
metodo “volume”.
Per rendere maggiormente chiaro anche dal punto di vista della
rappresentazione grafica tale situazione ci viene in aiuto il linguaggio
UML, che consente di rappresentare le dipendenze ereditarie
utilizzando apposite frecce che uniscono le classi coinvolte dalla
specifica relazione di appartenenza. Ad esempio, in merito alla
relazione tra cerchio e cilindro, possiamo usare la rappresentazione
proposta nella Figura 22.3.

Figura 22.3 – La rappresentazione in UML della relazione di eredità
tra la classe Cerchio e la classe Cilindro.
Come dovrebbe essere chiaro, una freccia unisce le due classi a
partire dalla classe derivata verso la classe base.
Vediamo una possibile implementazione del codice della classe
Cilindro che andrà a espandere la classe base Cerchio:
#include <iostream>
using namespace std;
class Cerchio
{
public:
float raggio;
float Area();

Cerchio ();
Cerchio (float);
};
Cerchio::Cerchio()
{
raggio=1;
}
Cerchio::Cerchio(float r)
{
raggio=r;
}
float Cerchio::Area()
{
return raggio * raggio * 3.14;
}
class Cilindro: public Cerchio
{
public:
float altezza;
float Volume();
Cilindro ();
Cilindro (float, float);
};
Cilindro::Cilindro()
{
altezza= 1;
}
Cilindro::Cilindro(float r, float h)
{
raggio=r;
altezza= h;
}
float Cilindro::Volume()
{
return raggio * raggio * 3.14 * altezza;
}

Facciamo come di consueto qualche osservazione. La prima cosa
che abbiamo aggiunto alla classe Cerchio è stato il costruttore di
default. Ciò è necessario in quanto nel caso di creazione diretta di
un cilindro dovrà essere creato anche il corrispondente cerchio che
funge da base. In maniera predefinita possiamo pensare di
impostare il valore del raggio di tale base a 1. Tutto ciò è banalmente
ottenuto dalla funzione:

Cerchio::Cerchio()
{
raggio=1;
}

Per quanto riguarda la definizione della classe Cilindro, essa viene
codificata come segue:
class Cilindro: public Cerchio
{
public:
float altezza;
float Volume();
Cilindro ();
Cilindro (float, float);
};

In tale definizione vi invito a osservare la prima riga, nella quale
utilizzo i due punti per rendere esplicita la derivazione del cilindro a
partire dal cerchio: class Cilindro: public Cerchio.
Per il resto non c’è più molto da dire; ho definito un membro altezza
del cilindro e due costruttori. Tra questi, il primo crea un cilindro
predefinito con base di raggio 1 e altezza 1, mentre il secondo
costruttore consente di passare per raggio di base e altezza specifici
valori di proprio interesse o necessità.
Per concludere questa sezione introduttiva sull’ereditarietà non ci
resta che vedere come testare il funzionamento delle nostre due
classi. Una semplice implementazione della funzione main potrebbe
essere la seguente:
int main()
{
Cilindro cilindro1;
Cilindro cilindro2(2,2);
cout << "I DUE CILINDRI" << endl;
cout << "L'area della base del primo cilindro e': " <<
cilindro1.Area() << endl;
cout << "Il volume del primo cilindro e': " <<
cilindro1.Volume() << endl;
cout << "L'area della base del secondo cilindro e': " <<
cilindro2.Area() << endl;
cout << "Il volume del secondo cilindro e': " <<

cilindro2.Volume() << endl;
return 0;
}

Le prime due righe creano due differenti cilindri: il primo con
dimensioni standard e il secondo con raggio e altezza pari a 2. Le
righe successive stampano i corrispondenti valori di area di base e
altezza.
È ovvio, in ogni caso, che possiamo utilizzare la classe base a
nostro piacimento indipendentemente dalla sua sottoclasse,
scrivendo ad esempio una dichiarazione del tipo:
Cerchio cerchio1(4.0);

creando in tal modo un cerchio con un raggio di 4 unità.

Proteggere i membri della propria
classe
Nella presentazione dei membri di una classe, più precisamente nel
Capitolo 19, abbiamo detto che per default, cioè in maniera
predefinita, tali membri sono assolutamente privati e quindi
accessibili alla sola classe. Abbiamo inoltre visto come fosse, infatti,
necessario utilizzare il qualificatore public per rendere pubblici e
quindi utilizzabili dall’esterno tali membri. Ad esempio, la seguente
definizione di classe:
class Test
{
public:
int a;
int b;
private:
int x;
};

definisce come privato il membro x e come pubblici, e quindi
accessibili dall’esterno della classe, i membri a e b.
Ho effettuato questa breve premessa riepilogativa in quanto è giunto
il momento di segnalarvi un particolare che vi avevo
precedentemente tenuto nascosto: esiste un terzo qualificatore
relativo alla visibilità dei membri di una classe! Tale qualificatore è
protected e consente un approccio mediano rispetto ai due
precedenti. In effetti, dichiarando dei membri come “protetti”, si
concede l’accesso non solo dall’interno della classe di appartenenza
ma anche da parte delle classi derivate dalla classe base
all’interno della quale abbiamo dichiarato tali membri.
A puro titolo esemplificativo vi propongo una modifica della classe di
esempio Test inserendo due membri, c e d, come elementi di tipo
protected.
class Test

{
public:
int a;
int b;
private:
int x;
protected:
int c;
int d;
};

Per maggiore chiarezza vi sottopongo una verifica di quanto detto,
relativamente alla classe Cerchio vista in precedenza. È possibile
dichiarare il membro raggio come protetto, come mostrato di seguito,
consentendo comunque la sua visibilità dalla classe derivata.
class Cerchio
{
public:
float Area();
Cerchio ();
Cerchio (float);
protected:
float raggio;
};

Al contrario, nel caso in cui il membro raggio dovesse essere
dichiarato esplicitamente come privato all’interno della classe base:
class Cerchio
{
public:
float Area();
Cerchio ();
Cerchio (float);
private:
float raggio;
};

oppure dovessimo inserirlo, prima dello specificatore public, come
mostrato di seguito
class Cerchio
{
float raggio;
public:

float Area();
Cerchio ();
Cerchio (float);
};

otterremmo in ogni caso una segnalazione di errore del tipo
seguente:
error: 'float Cerchio::raggio' is private

Diversi ma non troppo: la
sovrapposizione
Nel capitolo precedente vi ho mostrato il concetto di polimorfismo
realizzato attraverso l’overloading, noto anche come sovraccarico. Si
tratta, riepilogando brevemente, della possibilità di creare differenti
funzioni, aventi lo stesso nome, che differiscono in quella che si
definisce firma, ovvero il numero oppure il tipo di argomenti della
funzione stessa.
È naturale che tale situazione si verifichi quando le funzioni devono
effettuare sostanzialmente le stesse operazioni ma su dati diversi.
Non ha ovviamente senso utilizzare lo stesso nome per contesti che
fanno cose diverse: l’unico risultato concreto che si può ottenere è
quello di una gran confusione e conseguenti disastri informatici.
In questo capitolo abbiamo visto come sia possibile, utilizzando
l’ereditarietà, creare delle classi, cosiddette derivate, a partire da
altre classi di partenza. Anche in tali casi è possibile utilizzare
funzioni con lo stesso nome in classi quindi diverse ma
“apparentate” tra loro. Tale situazione prende il nome di override,
overriding o anche, in italiano, sovrapposizione. Tale operazione
si realizza solo con funzioni aventi la stessa firma: stesso numero e
tipo di argomenti. L’overloading invece si realizza con funzioni aventi
firme diverse.
Può essere importante fermarci un attimo per riepilogare e fare
chiarezza sugli aspetti in questione. Il polimorfismo, già
ampiamente discusso, può essere realizzato in due maniere
differenti: l’overloading e l’overriding. Si parla di overloading quando
le funzioni hanno lo stesso nome, e quindi ovviamente contesto
funzionale simile, ma possono avere firma diversa (numero e tipo di
argomenti). Si parla di overriding quando le funzioni polimorfe
hanno lo stesso numero e tipo di parametri.
Per richiamare una funzione che subisce l’override dall’interno di una
classe derivata è ovviamente necessario utilizzare l’operatore di
visibilità :: . Ciò è motivato dal fatto che altrimenti, essendo all’interno

della classe derivata dove è presente un’altra funzione con quello
stesso nome, il compilatore chiamerebbe tale funzione e non quella
presente nella classe base.

Quando il virtuale è realmente utile
L’override nelle classi è dunque utilizzato quando esistono delle
situazioni in cui possiamo aver bisogno di una stessa funzione
membro all’interno di una gerarchia di classi derivate le une dalle
altre, a partire da una data classe base.
Mi spiego meglio. La derivazione di una classe a partire da una
classe base la si realizza di norma per utilizzare le caratteristiche,
proprietà e funzioni, della classe base e aggiungere nuove
funzionalità per specializzare con maggiori dettagli la nuova classe.
A volte, tuttavia, si vuole che una stessa funzione, che realizza delle
attività simili nelle varie classi, abbia lo stesso nome, gli stessi
argomenti, ma si comporti in maniera specifica in ogni singola e
specifica classe. Parliamo quindi, come detto, di override.
Potrebbe tuttavia succedere che una chiamata a una funzione di una
classe richiami il codice di una funzione, avente ovviamente lo
stesso nome, ma appartenente a una classe diversa da quella che ci
interessa in un dato momento. Ciò avviene di norma nell’uso dei
puntatori alle classi. Per evitare tale problema è necessario
dichiarare, con apposita parola chiave, la classe di tipo virtuale.
Un esempio può essere allora chiarificatore. Supponiamo di dover
gestire un programma di disegno che realizzi una serie di
funzionalità di tipo grafico. Non me ne vogliate, ma allo stato attuale
non abbiamo nessun effetto speciale da realizzare e la grafica a cui
mi riferisco è del tutto indicativa. Non dimentichiamo che almeno per
il momento stiamo lavorando con programmi di tipo console (quindi
solo testuali) e che si tratta pur sempre di un semplice esempio.
Creiamo dunque una serie di classi: una prima classe Punto, una
seconda classe Linea e una terza classe Tratteggio. Il codice
potrebbe essere il seguente:
#include <iostream>
using namespace std;
//classe Punto
class Punto
{

public:
void Disegna();
};
void Punto::Disegna()
{
cout << "." << endl;
}
//Classe Linea
class Linea: public Punto
{
public:
void Disegna();
};
void Linea::Disegna()
{
cout << "__________" << endl;
}
//Classe Tratteggio
class Tratteggio: public Punto
{
public:
void Disegna();
};
void Tratteggio::Disegna()
{
cout << "----------" << endl;
}

Ognuno dei singoli oggetti di tipo Punto, Linea e Tratteggio dovrebbe
potersi disegnare. A tale scopo, ciascuna della tre classi possiede un
metodo Disegna. Si intuisce, dall’analisi dell’implementazione di tali
metodi, che il disegno in questione è davvero molto spartano. Le
classi Linea e Tratteggio derivano dalla classe base Punto e quindi
effettuano un override del metodo Disegna già presente in tale
superclasse.
Poiché sia Linea che Tratteggio derivano da Punto, è possibile riferirsi a
essi tramite proprio un puntatore di tipo Punto. Possiamo cioè
scrivere, all’interno del main, qualcosa del tipo seguente:
Punto P;
Linea L;
Tratteggio T;
Punto *px = &P;

Punto *lx = &L;
Punto *tx = &T;

Dichiariamo cioè tre oggetti P, L e T rispettivamente del tipo Punto,
Linea e Tratteggio e tre puntatori, di tipo Punto, a tali oggetti: *px, *lx e
*tx.
Proviamo allora a richiamare i metodi Disegna dei tre oggetti. L’intero
codice del main sarà il seguente:
int main()
{
cout << "Un disegno virtuale!" << endl;
Punto P;
Linea L;
Tratteggio T;
Punto *px = &P;
Punto *lx = &L;
Punto *tx = &T;
px ->Disegna();
lx ->Disegna();
tx ->Disegna();
return 0;
}

Sembrerebbe fatta. Tuttavia, andando a compilare ed eseguire il
nostro programma otterremmo a video qualcosa di simile al
seguente output:
Un disegno virtuale!
.
.
.

In effetti, ciò che viene richiamata è sempre e solo la funzione di
disegno dell’oggetto Punto a causa del tipo di puntatori impostati. Per
risolvere il problema è sufficiente far considerare al compilatore la
funzione Disegna dell’oggetto base come virtuale. Dobbiamo scrivere
semplicemente, dinanzi alla definizione della funzione Disegna, la
parola chiave virtual, come vi mostro di seguito riproponendo l’intero
codice della classe:
class Punto
{

public:
virtual void Disegna();
};

L’output a video sarà finalmente quanto ci aspettiamo, e cioè:
Un disegno virtuale!
.
__________
----------

Attenzione, dunque, quando si ha a che fare con funzioni che
vengono ridefinite, poste in override, in classi derivate. Può essere
sensato, in questi casi, predisporre sempre definizioni con la parola
chiave virtual dinanzi alla funzione stessa.

Dal virtuale all’astratto
Abbiamo visto come sia possibile con l’ereditarietà definire delle
relazioni gerarchiche tra classi a partire da una data classe base.
Abbiamo anche visto come sia importante definire come virtuali
alcune funzioni per rendere possibile un’agevole derivazione di
funzionalità nelle sottoclassi. L’individuazione della giusta gerarchia
di classi è un lavoro che richiede notevole esperienza e capacità di
analisi relativa allo specifico problema. Può addirittura capitare che
determinate superclassi siano utili solo per definire gli oggetti che da
essi discendono, ma per esse potrebbe non essere richiesta alcuna
implementazione di funzioni membro specifiche. Tali classi prendono
il nome di classi astratte. Il nome è giustificato dal fatto che si tratta
di classi per le quali non si implementa alcuna funzionalità specifica
ma esse rappresentano invece il punto di partenza per la creazione,
ovvero derivazione, di classi “reali” con reali funzionalità in esse
implementate.
Nel caso in cui una funzione virtuale di una classe non preveda
alcuna implementazione nella classe stessa, ma funga solo da punto
di partenza per le funzioni da essa derivate, si può esplicitare tale
situazione scrivendo nella definizione della classe:
virtual void MiaFunzione() = 0;

cioè aggiungendo l’assegnazione = 0 per la funzione stessa. Ciò
definisce la funzione come funzione virtuale pura. Si intuisce come
l’aggettivo relativo alla purezza sia riferito al fatto che essa non
implementa nulla ma si limita in maniera asettica a definire la
possibilità che altre funzioni, da essa derivate, facciano il lavoro che
ci si aspetta.

La presenza di una o più funzioni virtuali pure all’interno
NOTA della classe rende la classe stessa di tipo astratto
impedendo la possibilità di creare oggetti di tale classe.

L’amicizia è una funzione importante
Può capitare che determinate funzioni del nostro programma
debbano accedere per motivi vari ai membri privati di una certa
classe. Se tali membri risultano privati una ragione esiste: non si
vuole che essi siano direttamente accessibili dall’esterno, in quanto
si ritiene ciò pericoloso o non rispondente alle specifiche necessità
della classe.
Pur tuttavia, come detto, alcune funzioni potrebbero per forza di
cose dover accedere a tali membri. In queste situazioni il C++ mette
a disposizione una funzionalità di “amicizia” per determinate funzioni
rispetto a specifiche classi. Ciò che si fa è dichiarare, all’interno della
classe, tali funzioni come friend, ovvero amiche, di determinate e
ben specifiche funzioni che ovviamente sono all’esterno della classe.
Dico ovviamente in quanto, se fossero interne alla classe, il
problema non si porrebbe affatto: essendo interne avrebbero
accesso ai membri della classe.
Supponiamo allora di avere una classe che definisce un oggetto di
tipo punto geometrico nel piano, con l’ascissa e l’ordinata gestiti con
variabili membro di tipo intero con visibilità pubblica. La stessa
classe ha tuttavia un membro privato che memorizza il suo colore
ancora tramite un intero. Poiché tale proprietà è privata, qualsiasi
tentativo di accesso dall’esterno genererà inevitabilmente un errore.
Una soluzione per consentire la sua modifica dall’esterno può essere
definire una specifica funzione dichiarata come friend della classe
che possa quindi gestire a proprio piacimento il colore stesso.
Vediamo una possibile implementazione del codice:
#include <iostream>
using namespace std;
class Punto
{
public:
int x;
int y;
Punto(void); //Costruttore
void StampaDati(void);

private:
int colore;
friend void CambiaColore(int);
};
Punto::Punto(void)
{
x=0;
y=0;
colore=0;
}
void Punto::StampaDati(void)
{
cout << "Ascissa: " << x << endl;
cout << "Ordinata: " << y << endl;
cout << "Colore: " << colore << endl;
}

Come si può facilmente notare, le variabili x e y sono pubbliche
mentre la variabile colore è privata. Abbiamo definito quindi la
funzione CambiaColore che prende in input il numero del nuovo colore
da assegnare allo specifico oggetto. Da notare la parola chiave
friend usata prima della funzione stessa. Ho poi dovuto inserire una
funzione StampaDati per visualizzare i dettagli dell’oggetto.
Una possibile codifica della funzione amica potrebbe essere la
seguente:
void CambiaColore(int c)
{
Punto P;
P.colore = c;
P.StampaDati();
}

che potrebbe essere richiamata dal main del nostro programma. È
chiaro tuttavia che si tratta ancora una volta di una necessaria
semplificazione a beneficio della chiarezza del contesto d’uso delle
funzioni amiche. Infatti è intuitivo che la presenza della chiamata alla
funzione StampaDati all’interno della funzione CambiaColore è una
forzatura, dettata dalla necessità di non rendere l’esempio troppo
complesso e di consentire comunque la verifica del fatto che la
modifica del colore avviene in maniera corretta. Una versione più
specializzata avrebbe infatti potuto prevedere il passaggio come

argomento dell’indirizzo dell’oggetto stesso in modo da consentirne il
controllo e la stampa direttamente dal main. Ma a proposito del main,
estremizzando il discorso, si potrebbe permettere all’intero main di
accedere “in amicizia” alla classe scrivendo nella classe stessa:
friend int main();

Ciò permetterebbe al main stesso di accedere alla proprietà colore e
quindi potremmo scrivere qualcosa del tipo:
int main()
{
cout << "Le funzioni amiche!" << endl;
Punto P;
P.colore = 3;
P.StampaDati();
return 0;
}

Banalmente il suggerimento è quello di stare attenti alle proprie
amicizie per evitare spiacevoli sorprese. Consentire l’accesso
indiscriminato alla classe da parte dell’intero main potrebbe vanificare
gli sforzi di mantenere privato il membro della classe stessa.
Sempre in tema di allargamento delle amicizie di una classe, vi
faccio notare come sia possibile definire un’intera altra classe come
amica di una certa classe. Scrivendo, infatti, qualcosa del tipo:
class A
{
friend class B;
//...
};

si realizza una relazione di amicizia verso la classe A da parte
dell’intera classe B, in modo tale che la classe B potrà accedere a
tutti i membri privati della classe A.

23
La programmazione generica e
la libreria standard del C++
La

libreria

standard

salva

i

programmatori dal dover reinventare

la ruota.
Bjarne Stroustrup
Quanto proposto in questo capitolo è sostanzialmente in linea e
coerente con quanto presentato nei precedenti capitoli sulla
programmazione a oggetti. Abbiamo infatti già visto come tale tipo di
approccio alla programmazione consenta tutta una serie di
miglioramenti e ottimizzazioni rispetto a metodi più tradizionali. Nello
specifico abbiamo scoperto come uno dei punti cardine del
paradigma di programmazione a oggetti sia la possibilità di riusare
codice già scritto e adattarlo alle specifiche necessità del momento.
Di seguito vi propongo ulteriori strategie per rendere il codice
sorgente più efficiente e generico rispetto alle aspettative del
programmatore.

Riutilizzo del codice e applicazioni
legacy
Reinventare la ruota non è sicuramente un’operazione di grande
interesse e noi programmatori abbiamo come prima necessità quella
di essere produttivi. In realtà, prima ancora della produttività, per il
vero programmatore deve venire il divertimento, derivato dalla
passione che si deve avere per tale disciplina. Tuttavia, se si è
produttivi ci si diverte ancor di più. In ogni caso, se un problema è
già stato risolto, conviene, in linea generale, sfruttare il codice già
scritto per tale risoluzione piuttosto che riscrivere tutto daccapo.
Ovviamente molto dipende dalla bontà di quanto già codificato.
È sicuramente vero, infatti, che in alcuni casi limite conviene buttare
tutto a mare e riscrivere ex novo l’intero codice. Le cosiddette
applicazioni legacy, ovvero le applicazioni ereditate in un contesto
aziendale, già scritte in passato per risolvere problemi specifici e
ancora utilizzate, possono essere davvero un problema da far
perdere il sonno quando esse devono essere riadattate a nuove e
mutate esigenze. Lavorare su di un codice sorgente scritto male o
con un approccio “antico”, per implementare nuove funzionalità, può
causare l’esaurimento nervoso del più paziente degli sviluppatori.
Un primo e brutale approccio per ampliare le funzionalità di un
programma è quello di ricopiare interi pezzi di codice per poi adattarli
manualmente alle specifiche singolarità di funzionamento richieste.
Seppur utilizzabile in alcuni casi, generalmente tale approccio
comporta come risultato un codice maggiormente esposto a errori e
più difficile da gestire a causa delle sue dimensioni crescenti.
Da considerare, infatti, che spesso all’interno del codice si trovano
una serie di “pezze” inserite dallo sviluppatore per gestire situazioni
molto particolari, che si verificano solo per determinati e specifici
eventi. Ricopiare interi pezzi di codice può comportare l’esportazione
di tali particolarità anche in contesti in cui esse non sarebbero
richieste. La cosa che mi sento sempre di raccomandare durante lo
sviluppo del proprio codice è di commentare il più possibile ciò che si

sta facendo in un determinato punto. Nel momento in cui scriviamo il
codice tutto ci sembra chiaro e addirittura scontato, salvo perdere
una enorme quantità di tempo, in un momento successivo di
riverifica dello stesso pezzo di codice, per comprendere il motivo per
cui avevamo usato un certo if o altri costrutti vari dei quali proprio
non se ne capisce il senso, tanto da essere portati a pensare di
rimuoverli di netto con un bel colpo sul tasto canc.
Dicevamo, dunque, che il primo modo possibile per modificare un
codice è quello di ricopiarlo e di adattarlo alle nuove necessità. Ma
un secondo modo, quando possibile sicuramente auspicabile, è
quello di sfruttare il polimorfismo e l’ereditarietà del linguaggio per
ampliare le possibilità delle “vecchie” classi per venire incontro alle
nuove richieste di funzionalità da inserire nel nostro programma.
Abbiamo infatti visto come sia possibile ampliare le funzionalità di
una data classe modificando ad esempio la firma (il numero e/o il
tipo di parametri) delle sue funzioni membro per adattarle a nuovi
scopi e necessità. Ovviamente, per poter operare in tal modo, il
codice sul quale vogliamo operare deve essere già stato scritto
rispettando la metodologia a oggetti.
Esiste tuttavia un terzo modo: piuttosto che “duplicare” le classi con
il polimorfismo è possibile con il C++ utilizzare una strategia per la
quale si costruiscono delle classi in modo tale che accettino in input
differenti tipi di dato, pur continuando ad avere lo stesso tipo di
comportamento.

Modelli, template e classi generiche
La situazione per la quale uno stesso oggetto si può comportare,
sostanzialmente, allo stesso modo pur ricevendo in input valori di
tipo diverso viene definita parametrica. Ciò a sottolineare il fatto che
il comportamento è dipendente dai parametri ricevuti e gestiti. In altri
casi tali oggetti, e più propriamente le classi dalle quali si istanziano
tali oggetti, vengono definite classi generiche. Il motivo del nome
dovrebbe essere assolutamente intuitivo: le classi sono generiche in
quanto devono essere in grado di gestire differenti tipi di dato senza
problemi.
Quello che in realtà si fa è di costruire delle classi che rappresentano
un modello di classe. Con modello si intende un modo di
comportarsi non specifico ma adattabile a differenti situazioni della
classe stessa. Per tale contesto, il termine utilizzato per “modello” in
inglese è template. Si parla, tuttavia, di classi template anche in
italiano. E, neanche a dirlo, template è anche la parola chiave per
definire tale costrutto stesso.

Funzioni generiche alias funzioni template
In realtà, oltre alle classi generiche, il C++ consente di definire
anche, a livello “più basso”, delle funzioni generiche. Una funzione
generica è dunque una funzione parametrica che realizza lo stesso
comportamento anche in presenza di parametri di tipo diverso.
Piuttosto che presentarvi la sintassi generica, preferisco in questo
contesto mostrare direttamente un esempio, seppur molto semplice,
di tipo concreto. Ciò vi aiuterà a comprendere meglio il modo di
utilizzare, cioè la sintassi, di tali funzioni.
Supponiamo allora di voler creare una funzione che determini il
maggiore tra due valori in input. In effetti si tratta proprio di uno dei
primi esempi di programmazione realizzati nella sezione introduttiva
sul C. Il motivo è dato, ovviamente, dalla semplicità del problema,
che consente di vedere più facilmente il modo d’uso generale di tale
tecnologia. La particolarità di tale funzione di individuazione del

maggiore è tuttavia data dal fatto che essa può prendere in input, ad
esempio, sia valori interi che valori di tipo double.
Di seguito la definizione della funzione, che per massima semplicità
di comprensione chiamiamo proprio Maggiore:
template <class T>
T Maggiore (T a, T b)
{
T ris;
if (a>b)
{
ris = a;
}
else
{
ris = b;
}
return (ris);
}

Analizziamo con calma quanto abbiamo scritto cercando di
confrontare tale funzione generica con le classiche funzioni che già
conosciamo. Effettivamente, se non si fosse trattato di una funzione
generica avremmo scritto qualcosa del tipo:
int Maggiore (int a, int b)
{
//corpo della funzione
}

per indicare una funzione che prende in input due interi (a e b) e
restituisce un altro intero (il maggiore trovato tra i due).
D’altra parte, per gestire anche valori double dovremmo, in modo
“tradizionale”, effettuare l’overloading della funzione scrivendo una
sua copia come di seguito riportato:
double Maggiore (double a, double b)
{
//corpo della funzione
}

Se invece date uno sguardo al codice scritto per la funzione
generica vedrete che scriviamo:

…
T Maggiore (T a, T b)
{
//corpo della funzione
}

dove ho messo i puntini sospensivi al posto della prima riga, nella
quale andremo in effetti a scrivere template <class T>. Il motivo per cui
non ho riscritto tale prima riga è per farvi vedere come l’intestazione
delle funzioni classiche e quelle generiche siano del tutto simili. In
realtà, ciò che accade è che al posto del tipo int, oppure double,
indichiamo il tipo T, considerando quindi un tipo in effetti generico.
Attenzione al fatto che quando scriviamo template <class T> la parola
chiave class posta tra parentesi angolari non indica una classe nel
senso che abbiamo visto in precedenza, ma un modo per specificare
che T è un tipo di dati generico.

L’uso della lettera T come indicatore o, se vogliamo,
segnaposto per il tipo generico, è una pura convenzione.
NOTA
Al posto di tale lettera potremmo, volendo, utilizzare un
nome qualsiasi.
Se analizziamo il corpo della funzione Maggiore notiamo che c’è
sicuramente poco da dire. Usiamo un banale if per determinare il
maggiore tra a e b e associamo tale maggiore alla variabile
temporanea ris che utilizziamo per restituire il valore trovato. Forse
la cosa che vale la pena di sottolineare è proprio la dichiarazione di
tale variabile: T ris; In tal modo dichiariamo che ris è effettivamente
di tipo generico T.
A questo punto non ci rimane che vedere come richiamare e
utilizzare la funzione generica che abbiamo realizzato. Un possibile
approccio può essere il seguente:
int main ()
{
int max1, x1=6, x2=7;
double max2, y1=10.5, y2=10.6;
max1 = Maggiore<int>(x1,x2);
max2 = Maggiore<double>(y1,y2);

cout << "Maggiore tra interi: " << max1 << endl;
cout << "Maggiori tra double: " << max2 << endl;
return 0;
}

Nella prima parte dichiariamo le differenti variabili da utilizzarsi per il
test della funzione. In max1 e max2 poniamo i valori di ritorno della
funzione Maggiore, rispettivamente per il tipo int e per il tipo double. La
cosa da notare è il fatto che quando richiamiamo la funzione Maggiore
poniamo, all’interno delle parentesi angolari, subito prima dei classici
parametri, il tipo di dati sul quale vogliamo agisca la nostra funzione.
A proposito di tali parentesi angolari, nella chiamata della funzione vi
faccio notare come queste possano essere non inserite nel caso in
cui il compilatore riesca a determinare il tipo di dati in maniera
automatica. In effetti, potremmo scrivere ciò che segue:
max1 = Maggiore(x1,x2);
max2 = Maggiore(y1,y2);

ottenendo i medesimi risultati di prima. In effetti, che il compilatore
cerchi di individuare i tipi di dati passati alle funzioni è confermato
dal seguente esperimento. Se proviamo a richiamare la funzione
maggiore scrivendo qualcosa del tipo:
int ret;
ret = Maggiore(10.5, 10);

il compilatore ci segnala il seguente errore:
error: no matching function for call to 'Maggiore(double, int)'

Si tratta, per certi aspetti, di una situazione di ambiguità simile a
quanto visto a proposito del polimorfismo. L’errore ci segnala, infatti,
che il compilatore non riesce a trovare una funzione corrispondente
(matching) per una chiamata per la quale il primo elemento è un
double e il secondo è un int. Ovviamente il sistema vede come primo
elemento un double a causa del fatto che abbiamo scritto un numero
con la virgola: 10.5.
In effetti, per certi aspetti, con i template è un po’ come se il
compilatore lavorasse al nostro posto per produrre codice creando,
in fase di compilazione, copie del codice sorgente delle funzioni. Una

copia per ogni possibile combinazione di tipi di parametri. Se infatti
guardiamo alla funzione template che abbiamo scritto:
template <class T>
T Maggiore (T a, T b)
{
//corpo della funzione
}

ci rendiamo conto, come già analizzato in precedenza, che le
possibili combinazioni sono solo due:
int Maggiore (int a, int b) {}
double Maggiore (double a, double b){}

Dovendo gestire una situazione “mista”, dobbiamo per forza di cose
utilizzare due differenti parametri. Possiamo allora implementare
come segue:
template <class T1, class T2>
T1 Maggiore (T1 a, T2 b)
{
T1 ris;
if (a>b)
{
ris = a;
}
else
{
ris = b;
}
return (ris);
}

In questo caso, la nostra funzione Maggiore può prendere in input due
tipi diversi, diciamo T1 e T2, e restituire un valore di tipo T1, ovvero del
tipo del primo argomento. Supponiamo allora di chiamare la funzione
come segue:
double ret1, ret2;
ret1 = Maggiore<double, int>(10.5, 10);
ret2 = Maggiore(10.5, 10);

Le due chiamate sono del tutto equivalenti in quanto in entrambi i

casi il sistema riesce a interpretare i tipi di dati, il primo double e il
secondo int, e restituisce in output il valore con la virgola 10.5.
Credo che a questo punto il meccanismo generale delle funzioni
template dovrebbe essere chiaro. Un’ultima osservazione me la
concedo. Nel caso in cui dovessi richiamare l’ultima
implementazione della funzione Maggiore nel seguente modo:
double ret;
ret = Maggiore(10, 10.5);

otterremmo come risultato 10 e non 10.5 nonostante la variabile ret
sia definita come double. Il motivo è dato dal fatto che, non avendo
esplicitamente indicato i tipi per i parametri, il compilatore interpreta
il primo di tipo intero (non vedendo la parte decimale). Dovendo
restituire un valore di tipo T1, ovvero della tipologia del primo
argomento, la funzione calcolerà il valore (10.5 che rappresenta il
maggiore) ma lo restituirà troncato della parte frazionaria (quindi
semplicemente 10).

Classi generiche ovvero classi template
Tocca ora alle classi essere generalizzate. Generalizzare una classe
significa fare in modo che i suoi membri possano gestire tipi di dati
diversi. Per mostrarvi in pratica come si realizza e come si utilizza
una classe template, riprendo l’esempio della ormai familiare classe
Rettangolo vista in precedenza.
Una prima implementazione della classe prevedeva l’uso di variabili
intere x e y per base e altezza. Inoltre prevedevamo una funzione
membro Area che ci consentiva di calcolare appunto tale valore.
Essendo i membri rappresentanti base e altezza di tipo intero, anche
il valore dell’area del rettangolo risultava di tipo intero. Ci
proponiamo allora di gestire in modo parametrico tali proprietà;
saremo così in grado di gestire valori di tipo intero oppure di tipo
double senza problemi utilizzando la stessa classe.
Vediamo allora il codice minimale per una classe con tali
caratteristiche:
#include <iostream>
using namespace std;

template <class T>
class Rettangolo
{
public:
T x;
T y;
Rettangolo(T, T);
T Area();
};
template <class T>
Rettangolo<T>::Rettangolo (T a, T b)
{
x = a;
y = b;
}
template <class T>
T Rettangolo<T>::Area ()
{
T ris;
ris = x * y;
return ris;
}

La definizione della classe è abbastanza intuitiva. Come potete
osservare, al suo interno troviamo il segnaposto T al posto di ciò che
nella classe originaria indicavamo con int. Ad esempio, scrivendo:
T x; T y;

definiamo base e altezza di tipo T. Scrivendo Rettangolo(T, T);
definiamo il costruttore, che prende in input due valori (base e
altezza) sempre di tipo T e infine scrivendo:
T Area();

definiamo la funzione membro Area che deve restituire un valore di
tipo T.
Ormai dovreste essere abbastanza abituati a leggere i costrutti con i
template. Una particolarità che vale la pena sottolineare è tuttavia
l’uso dell’espressione <T> sia nel costruttore sia nella funzione
membro Area. Si tratta di una richiesta della sintassi che serve a
indicare qual è il tipo da sostituire.
Vediamo allora, finalmente, un possibile scenario di utilizzo della

classe template appena definita.
int main ()
{
Rettangolo <int> Ret1 (2, 4);
cout << Ret1.Area() << endl;
Rettangolo <double> Ret2 (2.1, 4.1);
cout << Ret2.Area() << endl;
return 0;
}

Dichiariamo due rettangoli: il primo Ret1 passando come parametro
un intero, mentre il secondo Ret2 viene costruito passando come
parametro un double. Ovviamente anche i risultati delle due aree
avranno tipi restituiti diversi. Il valore 8 nel primo caso, quindi un
valore intero; il valore 8.61, quindi un numero con la virgola, nel
secondo caso.

Specializzare un template
Vi sono delle situazioni in cui ci rendiamo conto che una classe non
può agire allo stesso modo, indipendentemente dalla natura del tipo
di dato. Può infatti accadere che si debbano realizzare delle
operazioni di tipo abbastanza diverso a seconda della natura del
dato. Pensate ad esempio alla differenza di natura tra un dato di tipo
numerico e un dato di tipo carattere. In tali situazioni, se il contesto
lo consente, è possibile specializzare la classe template a
implementare operazioni di tipo diverso a seconda della natura dei
dati su cui ci si trova a operare.
La sintassi generale è qualcosa del genere:
template <>
class esempio <char>
{
//corpo della classe
};

Un paio di cose veloci da notare. La prima è l’uso delle parentesi
angolari vuote: ciò serve appunto per definire una specializzazione
della classe. La seconda è l’uso della parola chiave char all’interno
delle parentesi angolari dopo il nome della funzione (esempio nel
nostro caso). Tale tipo di dati, char, è appunto il tipo di dati per il
quale scrivere codice specializzato, da trattare quindi in modo
differente rispetto al comportamento standard della classe.

La programmazione generica
Se guardiamo un attimo a ciò che abbiamo visto finora in questo
capitolo, ci rendiamo conto del fatto che l’attenzione è stata posta
tutta sul rendere generico l’approccio ai dati da utilizzare nello
sviluppo. Non a caso sia le funzioni template sia le classi template
sono state definite rispettivamente funzioni generiche e classi
generiche.
Il termine “generico” rappresenta infatti il fulcro di un intero approccio
alla programmazione che, neanche a dirlo, va sotto il nome di
programmazione generica. Parlare di approccio generico ai dati
significa comprendere che, in moltissimi casi, i problemi riguardano
collezioni di elementi che possono avere una diversa natura, come
ad esempio un intero oppure una lettera dell’alfabeto, ma essere
legati dalle stesse problematiche di gestione. Tanto per fare un
semplice esempio legato ai numeri e alle lettere si può pensare che
su tali elementi diversi possono incidere operazioni comuni, come ad
esempio la necessità di ordinarli rispetto a un certo criterio piuttosto
che effettuarne un conteggio o altre operazioni similari.
Ciò che si cerca di fare nell’approccio alla programmazione di tipo
generico è di concentrarsi sugli algoritmi che devono essere
utilizzati sui dati piuttosto che sui dati stessi. Tali algoritmi devono
quindi essere in grado di operare su un sufficientemente ampio
insieme di tipi di dati diversi. Tale strategia è di grande interesse e
importanza poiché le strutture dati utilizzate all’interno del software
possono essere anche molto articolate.
Ciò che abbiamo visto finora rispetto ai vari aggregati di dati è
abbastanza modesto: variabili semplici, array e strutture sono solo
alcuni degli esempi di possibili strutture dati. Tanto per fare un
esempio di qualcosa di più complesso, possiamo pensare a una
struttura dati che prende il nome di coda.
Tale struttura serve per simulare ciò che avviene effettivamente in
una coda reale; pensate a una coda di persone a uno sportello,
piuttosto che al banco dei salumi oppure a una coda a un casello
autostradale. In ogni caso abbiamo un insieme di elementi

organizzati in un unico contenitore, per i quali si hanno delle regole
molto precise. Ad esempio: il primo elemento che entra nella coda
deve essere il primo a uscire e essere “servito”. Un’altra regola
potrebbe essere la seguente: man mano che si aggiungono elementi
alla coda, questi devono essere posti nelle ultime posizioni e
verranno serviti solo nel momento in cui tutti gli altri elementi
saranno usciti dalla parte iniziale (testa) della coda.
Si intuisce come sia importante realizzare una coda di tipo generico.
Tale coda deve poter gestire indifferentemente elementi di tipo
diverso, come ad esempio numeri oppure lettere. Non è pensabile
realizzare due code differenti: una per i numeri e l’altra per le lettere.
O meglio: si può anche duplicare la struttura coda, ma con alti costi
di sviluppo e scarsa possibilità di avere un’agevole manutenzione
della struttura stessa. Lo spirito di quanto visto finora con funzioni e
classi template, ormai dovrebbe essere chiaro, va proprio nella
direzione della programmazione generica.
Il C++ fornisce dunque gli strumenti per organizzare tale approccio.

STL: Standard Template Library
Il linguaggio C++ ci dà la possibilità di usare un approccio generico e
di creare le nostre strutture dati in modo parametrico. Tuttavia, se
qualcuno ha già lavorato per noi, non c’è motivo di rifare lo stesso
lavoro una seconda volta. Questo qualcuno si chiama innanzitutto
Alexander Stepanov (Figura 23.1), il quale è il principale artefice di
una specifica libreria di strumenti realizzata appositamente nella
visione della programmazione generica: la Standard Template
Library, meglio conosciuta con l’acronimo di STL.

Figura 23.1 – Alexander Alexandrovich Stepanov, il principale
artefice della Libreria STL.
Volendo schematizzare al massimo, la libreria STL possiamo vederla
come composta di tre elementi:

• Contenitori.
• Iteratori.
• Algoritmi.
I contenitori, detti anche in modalità anglosassone containers,
sono i veri e propri aggregati di dati. Si tratta quindi di collezioni
organizzate di elementi. A scopo di esempio pensate alla struttura
coda di cui vi ho scritto pocanzi.
Gli iteratori sono degli speciali puntatori che consentono di

navigare, cioè di muoversi, all’interno delle strutture dati.
Gli algoritmi sono delle procedure preconfezionate per risolvere i
classici problemi che si presentano in relazione alle strutture dati:
ordinamento di dati, ricerca di specifici valori ecc.

24
Flussi e file nel C++
Camminare sull’acqua e sviluppare
software da una specifica sono
azioni

facili

se

entrambe

sono

congelate.
Edward V Berard
Nel Capitolo 15, relativo al linguaggio C, vi ho presentato l’approccio
usato dal C stesso per gestire i file e i relativi dati in essi contenuti. In
effetti, tutto ciò che abbiamo visto per il C potrebbe essere utilizzato
anche nel C++ essendo immediatamente disponibile e incorporabile
all’interno dei programmi scritti utilizzando tale linguaggio.
Tuttavia, il C++ possiede degli strumenti specifici per gestire i flussi
di dati da e verso i file. Il tutto, ovviamente, attraverso specifiche
classi. Il presente capitolo può essere quindi importante per
comprendere un diverso approccio per un comune problema,
dandoci al contempo la possibilità di esplorare dettagli ulteriori della
programmazione C++ e della libreria standard.

Le classi per la gestione dei file
Ho fatto riferimento alla libreria standard in quanto la gestione dei file
è appunto realizzabile utilizzando la libreria standard che tratta i file
come caso particolare della più ampia gestione dell’input-output. In
effetti, abbiamo già sistematicamente avuto a che fare con la
gestione dell’input-output attraverso le istruzioni cin e cout. La
principale classe alla quale si fa riferimento per la gestione di tale I/O
(Input/Output) è iostream ed essa è richiamabile attraverso
l’omonimo file di intestazione <iostream>, che deve necessariamente
essere incluso per poter utilizzare le specifiche funzionalità in esso
referenziate. In realtà, la gerarchia di classi è abbastanza
complessa. Nella Figura 24.1 ve ne riporto la struttura per farvi
comprendere la sua organizzazione generale.

Figura 24.1 – La gerarchia di classi per la gestione dell’Input-Output.
Non abbiate paura, non dovete mandare giù a memoria l’intero
schema: non avrebbe senso. In ogni caso, una sua seppur veloce

analisi può farvi capire meglio la complessità delle relazioni di
derivazione tra classi usate nel “mondo reale” della
programmazione. Inoltre, può essere di stimolo per ulteriori
approfondimenti e infine, forse, un modo per sentirsi fortunati nel
poter usare tali strumenti senza dover per forza di cose riscriverli in
prima persona.
Oltre alla classe iostream che, come già detto, si occupa dell’inputoutput di base, è necessario fare riferimento al file di libreria
fstream. In tale file sono infatti contenuti i riferimenti alle seguenti
classi: fstream, ifstream e ofstream. Queste sono necessarie per
la gestione dei file sulle memorie di massa (hard-disk, pennette USB
ecc.).
In definitiva, ogni volta che vorremo gestire i file su disco da C++
dovremo fare riferimento alla simpatica coppia iostream e fstream
scrivendo i seguenti include:
#include <iostream>
#include <fstream>

Volendo essere più specifici possiamo puntualizzare quanto segue:

• fstream: classe relativa alla lettura/scrittura
• ifstream: classe relativa alla sola lettura dell’input
da file
• ofstream: classe relativa alla sola scrittura su file

Apertura e chiusura di un file
Vediamo innanzitutto come aprire e, conseguentemente, chiudere un
file. Il codice è di disarmante semplicità:
#include <iostream>
#include <fstream>
using namespace std;
int main()
{
ofstream f;
f.open ("primo.txt");
f.close();
cout << "Fine operazioni!" << endl;
return 0;
}

Da notare subito i due include di cui vi dicevo prima:
#include <iostream>
#include <fstream>

Per il resto dichiariamo un oggetto di tipo ofstream che chiamiamo per
massima semplicità f (iniziale di file). Tale oggetto, come detto, viene
utilizzato per la scrittura su file. Richiamiamo il metodo open
passando come argomento il nome del file. Subito dopo chiudiamo il
file stesso. Mandate in esecuzione il programma e sul vostro disco,
all’interno della cartella in cui risiede il progetto, vi ritroverete un file
vuoto con il nome primo.txt.
Un’alternativa all’apertura che vi ho mostrato consiste nell’indicare
direttamente nella dichiarazione il nome del file da aprire, ad
esempio:
ofstream f("primo.txt");

Personalmente io preferisco il primo metodo, perché lo trovo più
pulito.

NOTA Quando lavorate con i file un po’ di attenzione
supplementare non fa mai male e può evitare spiacevoli
sorprese. Ad esempio, nello specifico, il codice di apertura
e relativa creazione di un file che abbiamo utilizzato
sostituisce
immediatamente,
sovrascrivendolo,
un
eventuale file con lo stesso nome e nella stessa posizione
di quello che stiamo andando ad aprire.
A proposito di percorso, vi ho detto che il file viene creato all’interno
della cartella del progetto e quindi, più in generale, nella cartella di
esecuzione del nostro eseguibile. Per averne la prova potete copiare
il file eseguibile dalla sottocartella in cui è stato creato, ad esempio
dalla cartella Debug presente sotto la cartella bin all’interno del
progetto (se state usando, così come vi ho suggerito, Code::Blocks)
e incollarlo in una cartella qualsiasi del vostro disco. Lanciato il file
eseguibile, ad esempio con un bel doppio clic sul suo nome, vedrete
comparire all’interno della cartella il file di testo in questione. Nel
nostro caso il file si chiama primo.txt. Ovviamente potrà capitare
spesso di voler salvare o aprire un file in una cartella qualsiasi. Per
farlo è sufficiente indicare in fase di apertura il percorso completo del
file. Ad esempio, il seguente codice:
ofstream f;
f.open ("c:\\temp\\primo.txt");

creerà all’interno della cartella temp, sottocartella della radice del
disco C:, il file in questione. Da notare l’uso del doppio simbolo \\ per
poter inserire all’interno del percorso il singolo elemento \ di
separazione tra cartelle e indicatore della radice del disco.
L’ultima cosa che ci è rimasta da vedere, d’altra parte assolutamente
banale, è la chiusura del file per rilasciare le risorse assegnate,
realizzata attraverso il metodo close che non richiede alcun
parametro:
f.close();

Scriviamo file di testo
Come abbiamo visto in altra occasione, i file di testo sono i più
semplici da gestirsi, almeno dal punto di vista di noi umani. Un file di
testo è un file che contiene caratteri stampabili. Vediamo allora come
è possibile scrivere all’interno di un file di testo un certo contenuto.
Per l’esempio in questione supponiamo di voler realizzare un
classico file CSV. Tali file (Comma Separated Values) sono dei file di
testo che rappresentano il più semplice esempio di archivio di dati.
Infatti, questi file contengono un record, ovvero un insieme di campi,
per ogni singola riga del file stesso. I valori dei campi sono spesso
separati da una virgola (da cui il nome CSV). Oltre al carattere
virgola si usano spesso come separatori i caratteri punto e virgola, lo
spazio o anche il carattere di tabulazione. È proprio tale carattere
che uso nell’esempio che vi riporto di seguito.
#include <iostream>
#include <fstream>
using namespace std;
int main()
{
ofstream f;
f.open ("anagrafica.txt");
f << "Nome\tCognome\temail\n";
f << "Carlo\tMazzone\tinfo@tesseract.it\n";
f << "Ciccio\tPasticcio\tcicciop@example.com\n";
f << "Mickey\tMouse\tmickey@example.com\n";
f.close();
cout << "Fine registrazione!" << endl;
return 0;
}

La cosa sorprendente è la possibilità di usare con assoluta
naturalezza l’operatore di output << per inserire nel file tutto il
contenuto che vogliamo, così come se stessimo scrivendo sullo
schermo. Proprio sullo schermo informiamo l’utente del
completamento delle operazioni con la classica cout. Per il resto,
forse, l’unica ulteriore osservazione può essere relativa all’uso del
carattere speciale \t per inserire nella stringa su file il carattere di

tabulazione. In coda alle singole righe, invece, usiamo il classico \n
per forzare un ritorno a capo.

Nella creazione di file CSV l’uso del carattere di
tabulazione può essere una buona scelta nel momento in
cui riteniamo possibile che alcuni valori dei campi possano
contenere dei simboli tipo virgole o punti e virgola. Il
carattere di tabulazione preserva la struttura e l’ordine dei
campi, che verrebbero invece compromessi nel momento
NOTA in cui dovessimo usare come separatore di campo, ad
esempio, la virgola e si verificasse la presenza di una
virgola anche in qualche valore di un campo qualsiasi. Un
indirizzo potrebbe, ad esempio, essere qualcosa del tipo:
“Via dei Viali, 23”. La virgola presente nella stringa
dell’indirizzo potrebbe essere invece interpretata come
separatore di campo, invalidando il record in questione.

Modalità di apertura
Finora abbiamo aperto i file sapendo che questi sarebbero stati
sistematicamente sovrascritti dal nuovo contenuto prodotto
all’interno del codice; si tratta ovviamente di una grossa limitazione.
Generalmente, infatti, potremmo volere accodare nuovo testo ai
nostri file senza perdere il contenuto preesistente. Per poter
modificare le modalità di apertura possiamo specificarle subito dopo
il nome del file, ad esempio, come segue:
f.open ("nomefile.txt", ios_base::app);

dove ios_base::app indica la modalità di apertura in append, ovvero in
accodamento al testo già eventualmente presente.
In alternativa possiamo scrivere:
f.open ("nomefile.txt", ios::app);

utilizzando, quindi, ios al posto di ios_base. Ciò è possibile in quanto le
due modalità sono sostanzialmente analoghe essendo presente
nell’implementazione delle classi un typedef. Nel prosieguo utilizzerò
questa seconda modalità.
Di seguito l’elenco completo delle modalità di apertura dei file:
ios::in

Apre in lettura

ios::out

Apre in scrittura

ios::app

Modalità append; i nuovi dati verranno aggiunti alla fine
del file; è valido per le sole operazioni di scrittura

ios::trunc

Elimina il contenuto del file azzerandolo

ios::ate

Significa AT End cioè alla fine; apre il file
posizionandosi
in coda ad esso

ios::nocreate

Significa sostanzialmente “no alla creazione”; se il file
non esiste viene generato un errore

ios::noreplace

Significa “non sostituire”; se il file esiste genera una

errore
ios::binary

Apertura in modalità binaria anziché testuale

Come già detto, operare sui file è sempre abbastanza critico. Inoltre,
tali impostazioni possono dipendere dalle specifiche implementazioni
del compilatore. Vale sempre il suggerimento di testare il proprio
codice con attenzione per verificarne gli effetti.
Un aspetto interessante e utile delle modalità di apertura è che esse
possono essere combinate insieme tramite l’operatore logico OR per
realizzare aperture di file maggiormente articolate.
Ad esempio potremmo scrivere:
f.open("anagrafica.dat", ios::binary | ios::in );

dove abbiamo indicato la modalità binaria insieme alla modalità di
apertura del file. Da notare che per l’OR utilizziamo un singolo
simbolo di pipe |, trattandosi di un operatore sui bit. Per rimarcare
che si tratta di un file binario utilizziamo come estensione .dat. Altra
estensione tipica per indicare tali tipi di file è .bin.

Leggiamo il contenuto di un file
Supponiamo ora di voler leggere e stampare a video il file
anagrafica.txt prodotto nel precedente esempio. Un possibile
approccio può essere il seguente:
#include <iostream>
#include <fstream>
using namespace std;
int main()
{
ifstream f;
f.open("anagrafica.txt", ios::in);
if(!f)
{
cout << "Il file specificato non esiste!";
return 1;
}
string linea;
while(!f.eof())
{
getline(f, linea);
cout << linea << endl;
}
f.close();
return 0;
}

Notiamo innanzitutto che con ifstream f; istanziamo l’oggetto f
relativo alla classe ifstream per la gestione dell’input da file.
L’istruzione che segue apre poi effettivamente il file in modalità input.
Nella sezione successiva del codice sfruttiamo un’importante
caratteristica della funzione open. Questa restituisce il valore
booleano true (vero) nel caso in cui essa sia effettivamente collegata
a un file aperto. Testiamo allora tale valore con la negazione logica
NOT tramite l’operatore ! (punto esclamativo). In buona sostanza
diciamo qualcosa del tipo: se f non è vera (quindi è falsa) il file non
esiste. In tal caso usciamo dalla funzione main subito dopo aver
segnalato con un apposito messaggio tale situazione.

Andiamo ora ad analizzare il pezzo di codice che effettivamente
preleva il contenuto dal file e lo stampa a video. Come prima cosa,
dichiariamo un elemento string che conterrà le singole righe di testo
presenti all’interno del file. Concentriamoci ora sulla condizione
presente all’interno del while. Il metodo eof applicato all’oggetto f
restituisce il valore di verità vero quando il puntatore interno al file
stesso giunge alla fine del file. Utilizzando ancora una volta il NOT
logico diciamo: finché f non è alla fine del file esegui il corpo del
while. All’interno del ciclo la funzione getline applicata all’oggetto f
pone nella variabile stringa linea la riga appena letta. Tale variabile
viene poi mandata in output tramite la funzione cout. Banalmente,
all’uscita dal ciclo chiudiamo l’oggetto f.
Una cosa interessante che voglio farvi notare è la possibilità di
utilizzare al posto di eof un differente metodo per testare lo stato di
lettura del file. Avremmo infatti potuto scrivere quanto segue:
while(f.good())
{
getline(f, linea);
cout << linea << endl;
}

ottenendo sostanzialmente lo stesso effetto. Infatti, il metodo good
restituisce il valore di verità vero se il flusso del file è disponibile per
le operazioni di lettura o scrittura e restituisce invece il valore di
verità falso quando arriva alla fine del file oppure nel caso in cui si
verifica un qualche errore.
Esistono anche altri metodi relativi allo stato delle operazioni di
input/output utilizzabili sull’oggetto di tipo file: bad() e fail(). Entrambi
i metodi restituiscono true in caso di errori nella lettura/scrittura su
file. Tra i due il metodo fail è più sensibile segnalando anche errori
minori.

File binari e archivi di dati
I file di testo puro hanno molti pregi ma contemporaneamente molti
limiti. Banalmente si tratta di file che non possiedono
un’organizzazione interna. Seppure sia possibile organizzarli come
dei file di tipo CSV, quindi con una sorta di insiemi di campi e record,
è sicuramente difficile gestirli in comodità e sicurezza andando ad
esempio a lavorare posizionandosi su specifici campi all’interno del
file stesso.
Una soluzione a questi tipi di problemi si presenta con l’uso dei file
binari. Come già visto per la gestione dei file in C, tale approccio
sottintende la possibilità di accesso random al contenuto stesso.
Random, ovvero casuale, significa in questo caso che è possibile
posizionarsi su di un qualsiasi punto all’interno del file stesso
semplicemente sapendo di quanti byte ci si deve spostare.
Le funzioni chiave per tale metodica sono sicuramente seekg() e
seekp(). Sono proprio tali funzioni a spostare il cursore, che punta
alla posizione corrente, nella posizione voluta. Il significato nascosto
nei nomi ci aiuta a capirne la natura; seek significa ricerca, mentre la
lettera postfissa sta per get nel caso di seekg e per put nel caso di
seekp. La prima viene utilizzata in caso di input, la seconda in caso di
output.
Entrambe le funzioni prendono in input due argomenti: il primo è il
numero di byte per il quale spostare il puntatore sul file stesso,
mentre il secondo indica da dove cominciare a contare tali byte. Tale
indicazione avviene grazie a un flag presente in ios. In realtà i flag
sono tre e sono i seguenti:
ios::beg

Begin, si riferisce all’inizio del file

ios::cur

Current, si riferisce alla posizione corrente del puntatore

ios::end

End, si riferisce alla fine del file

Come di consueto, in tali contesti un numero positivo indica uno
spostamento in avanti mentre uno negativo uno spostamento a

ritroso.
Vi porto allora qualche veloce esempio d’uso:
f.seekg(10, ios::cur); //spostamento di 10 byte dalla
posizione corrente in avanti
f.seekg(-10, ios::cur); //spostamento di 10 byte dalla
posizione corrente indietro
f.seekg(10, ios::beg); //spostamento di 10 byte in avanti a
partire dall'inizio del file
f.seekg(-10, ios::end); //spostamento di 10 byte a ritroso a
partire dalla fine del file

Per la lettura e la scrittura di file binari sono disponibili due metodi
dai nomi quanto mai indicativi: read e write con i seguenti prototipi:
read (char*, lunghezza)
write (char*, lunghezza)

dove char* è un puntatore di tipo carattere all’area di memoria dove
leggere e scrivere i dati di dimensione lunghezza.

Un archivio reale: gestiamo una
collezione di fumetti
Per mettere in pratica alcune delle idee e degli argomenti che vi ho
proposto in merito alla gestione dei file può essere di sicuro ausilio la
realizzazione di un applicativo reale relativo, ad esempio, a un
archivio elettronico destinato alla gestione di una collezione di
fumetti. Ovviamente le idee introdotte in merito a tale applicativo
potranno facilmente essere trasposte in altri contesti, come un
elenco di libri, una collezione di DVD, piuttosto che la vostra classica
collezione di farfalle, ammesso che ne possediate realmente una.
Poco male se non possedete una collezione di farfalle; se non avete,
invece, una collezione di fumetti, realizzatela. I fumetti sono un
ottimo stimolo per la fantasia e di riflesso fanno un gran bene alle arti
della programmazione software.
Prevediamo nel nostro applicativo tre funzioni di base: lista dei
fumetti presenti in archivio, inserimento di un nuovo fumetto,
modifica di un fumetto già presente.
La struttura generale del main potrebbe dunque essere la seguente:
#include <iostream>
using namespace std;
void Inserisci();
void Lista();
void Modifica();
int main()
{
int x;
cout << "I MIEI FUMETTI ver 0.1" << endl << endl;
do
{
cout << "1 - Lista" << endl;
cout << "2 - Inserisci" << endl;
cout << "3 - Modifica" << endl;
cout << "" << endl;
cout << "0 - ESCI" << endl;
cout << "" << endl;
cout << "Operazione: ";

cin >> x;
switch(x)
{
case 1:
Lista();
break;
case 2:
Inserisci();
break;
case 3:
Modifica();
break;
break;
}
}while (x != 0);
return 0;
}
void Lista()
{
cout << "LISTA FUMETTI" << endl;
return;
}
void Inserisci()
{
cout << "INSERIMENTO FUMETTO" << endl;
return;
}
void Modifica()
{
cout << "MODIFICA FUMETTO" << endl;
return;
}

Un tale modo di procedere è sicuramente di tipo top-down.
Osservando il codice, infatti, potrete verificare l’esistenza di una
struttura generale, una sorta di scheletro dell’applicazione, che ci
consente di organizzare il programma in una serie di funzionalità
solamente abbozzate ma che al tempo stesso rendono possibile
immediatamente una prima compilazione dell’applicativo. Le funzioni
presenti nel codice sono, almeno inizialmente, delle scatole vuote
che tuttavia consentono di capire come evolverà il programma.
La programmazione è un’attività reale e come tale si scontra con il
realismo del mondo che ci costringe a compromessi continui. Non

può esistere nel mondo reale (ora mi riferisco alla programmazione)
un estremismo che ci vede costruire programmi integralmente basati
in maniera cieca e assolutistica rispetto a uno specifico paradigma,
come ad esempio quello di tipo top-down piuttosto che bottom-up.
L’esperienza ci insegna che l’estremismo è sempre deleterio e che,
nel nostro contesto, si deve fare una sistematica riflessione ampia e
critica, sia relativamente agli aspetti che vanno dal generale al
particolare sia rispetto a quelli che partono dal singolo dettaglio degli
oggetti base (le superclassi) e arrivano alla generalizzazione
attraverso i concetti propri dell’ereditarietà.
Analizzando il main potrete notare l’utilizzo del costrutto do-while con
una prima stampa delle opzioni del programma, con relativo switch
seguente che consente di catturare la scelta dell’utente in merito alle
sue specifiche scelte del momento.

La struttura dati
Una volta abbozzato lo scheletro dell’applicazione dobbiamo
immediatamente definire la logica del programma in merito alle
strutture dati da utilizzare. Considerati gli strumenti maturati fino a
questo momento, la scelta più naturale, in quanto semplice, può
essere quella di gestire una sequenza di strutture in cui ogni
elemento contenga i dati sullo specifico fumetto. Tale struttura
potrebbe essere definita come segue:
typedef struct _fumetto
{
int numero;
char titolo[25];
char note[50];
}fumetto;

Definiamo dunque una struttura con tre differenti campi. Il primo è il
numero del nostro fumetto (tipo intero), segue un titolo (array di
caratteri di lunghezza 25) e infine un campo note (array di caratteri di
lunghezza 50). Codifichiamo tale struttura all’esterno del main
definendola quindi di tipo globale, con la conseguente possibilità di
essere visibile da tutte le nostre funzioni.
Anche solo queste primissime scelte architetturali la dicono lunga
su quanto sia complesso e determinante il lavoro di progettazione di

un software, anche banale, come quello che stiamo realizzando.
Ad esempio, una prima considerazione vincolante è relativa alla
dimensione dei campi della struttura. Dire che il titolo sarà gestito
da un array di caratteri di 25 elementi significa impedire l’inserimento
di titoli di fumetti maggiori di tale dimensione. Impostare valori
maggiori potrebbe significare un inutile spreco di spazio. Individuare
le giuste dimensioni dei campi può essere un lavoro di grande
responsabilità.
La questione importante, infatti, è che ciò che stiamo realizzando si
basa sull’assunto che le dimensioni dei campi siano fisse, in quanto
sfrutteremo tale caratteristica per poterci muovere all’interno del
nostro archivio sapendo che, se i dati di un fumetto occupano x
spazio di memoria su disco, l’n-esimo elemento sarà in posizione n·x
(ovvero n moltiplicato x) rispetto all’inizio del file.
Le dimensioni prefissate degli elementi della struttura e, più in
generale, il meccanismo previsto per la gestione dei dati, comporta
in automatico un ulteriore vincolo: non si potrà aggiungere in futuro
un altro campo alla struttura se non a prezzo di notevoli contraccolpi
su tutto il software già scritto. In effetti, modificare la dimensione
delle singole strutture comporterà l’impossibilità di leggere i file
prodotti con una versione precedente del nostro software.
In alcuni casi, per attenuare tali problemi, si potrebbero inserire uno
o più campi aggiuntivi da utilizzarsi solo per eventuali scopi futuri.
Tali campi, nel contesto informatico, vengono spesso definiti campi
filler, ovvero riempitori. Essi rappresentano un ulteriore
compromesso tra le dimensioni dell’archivio e la sua scalabilità,
ovvero la possibilità di adattarsi a future esigenze.
Una possibile soluzione radicale per gestire le problematiche
connesse alle dimensioni fisse dei blocchi di dati è sicuramente
quella di considerare i singoli blocchi a dimensione variabile. Tale
scelta, se facilita alcuni aspetti, ne complica sicuramente altri, come,
ad esempio, quelli relativi all’individuazione dei punti di inizio e di fine
dei singoli blocchi, con conseguente necessità di complicare la
logica di funzionamento dell’applicativo.
Queste prime considerazioni introduttive avrebbero già dovuto darvi
il senso di quanto può essere complesso realizzare un’applicazione
reale. Nello specifico, il contesto degli archivi di dati non è esente da

numerosissime problematiche di tipo progettuale e procedurale,
tanto che spessissimo si utilizzano, all’interno delle applicazioni,
librerie appositamente già realizzate con annessi archivi di dati
standard.
Continuiamo, dunque, nella costruzione del nostro applicativo.
Dobbiamo definire il tipo di archivio: si tratterà, come si può evincere
dai ragionamenti fatti finora, di un file di tipo binario. Decidiamo di
chiamarlo fumetti.dat e definiamo il suo nome come costante
globale:
#define NOME_FILE "fumetti.dat"

Oltre a ciò, dobbiamo, come ulteriore passo, aggiungere la direttiva
include per la libreria fstream per la gestione dei file.
#include <fstream>

Come prima operazione all’avvio del programma dobbiamo
preoccuparci di verificare che l’archivio esista; in caso contrario
dobbiamo provvedere a crearlo. A tale scopo definiamo e utilizziamo
un’apposita funzione. Questa potrebbe essere codificata come
segue:
void VerificaArchivio()
{
//apre il file in modalità binaria
//se il file non esiste lo crea
ofstream f;
f.open(NOME_FILE, ios::binary | ios::app );
f.close();
}

Come si può notare dalle modalità di apertura, ci riferiamo a un file di
tipo binario con modalità “aggiunta in coda”. In tal modo, se il file
esiste esso non verrà sovrascritto. In caso contrario ne verrà creato
uno nuovo e, subito dopo, chiuso all’interno della funzione stessa.
Faremo in modo di richiamare tale funzione come prima operazione
da effettuarsi all’interno del main.

Salvataggio su disco di un record
Una volta predisposto il file che fungerà da archivio per i nostri
fumetti possiamo preoccuparci dell’inserimento di nuovi record

all’interno del file stesso. Di seguito vi propongo una possibile
implementazione per la funzione che eseguirà tale operazione.
void Inserisci()
{
cout << "INSERIMENTO FUMETTO" << endl;
fumetto Elemento;
cout << "Numero fumetto: ";
cin >> Elemento.numero;
cin.ignore(80, '\n');
cout << "Titolo: ";
cin.getline(Elemento.titolo, 25);
cout << "Note: ";
cin.getline(Elemento.note, 50);
ofstream f;
f.open(NOME_FILE, ios::binary | ios::app );
f.write((char *) &Elemento, sizeof(Elemento));
f.close();
return;
}

Osservando il codice potrete notare come innanzitutto raccogliamo i
dati che inseriremo nella struttura con cin e il supporto della funzione
getline per la lettura delle stringhe. Vi ricordo, come già chiarito nel
Capitolo 18, che l’utilizzo della riga cin.ignore(80, '\n'); ci serve per
eliminare dall’input (su di un massimo di 80 caratteri relativi a una
riga della console) il carattere \n di fine linea. Senza questo
provvedimento verrebbe generato in automatico un ritorno a capo,
che impedirebbe l’accettazione dell’input per il successivo campo
titolo.
Dopo aver raccolto i dati, dichiariamo l’oggetto ofstream aprendo il file
in modalità binaria in output con scrittura in coda. Infatti prevediamo
di scrivere i nostri record uno dopo l’altro in sequenza sempre in
coda al file.
Effettuiamo la scrittura vera e propria con l’istruzione:
f.write((char *) &Elemento, sizeof(Elemento));

alla quale passiamo come primo argomento l’indirizzo della struttura
appena valorizzata effettuandone il cast al tipo puntatore a caratteri
e come secondo argomento la dimensione in byte della struttura

stessa. La funzione write deve infatti sapere dove prelevare i dati per
la scrittura e quanti byte deve scrivere nel file a partire dall’indirizzo
di memoria specificato.

Modifica e sovrascrittura di un record
Vediamo ora una possibile implementazione per la funzione di
modifica dei record. La logica di funzionamento che ci proponiamo di
realizzare prevede che l’utente della nostra applicazione possa
indicare il numero del fumetto per il quale intende modificare le
informazioni rispetto al titolo e alle note associate allo specifico albo.
Per farlo, una volta richiesto il numero del fumetto, effettuiamo la
lettura dell’intero archivio e, prelevando il campo contenente il
numero del fumetto dalla singola struttura, verifichiamo se tale valore
corrisponde al numero inserito dall’utente. In tal caso richiediamo
all’utente i nuovi dati e li poniamo in una nuova struttura di tipo
fumetto. A questo punto dovremo inserire al posto giusto nella
sequenza di strutture già salvate la nuova copia. Per capire dove
inserire la nuova copia dell’elemento teniamo il conto, tramite
un’apposita variabile, delle strutture lette durante la procedura di
ricerca.
Di seguito il codice:
void Modifica()
{
cout << "MODIFICA FUMETTO" << endl;
fumetto Elemento;
int n;
int count=0;
cout << "Numero fumetto da modificare: ";
cin >> n;
fstream f;
f.open(NOME_FILE, ios::binary | ios::in | ios::out);
while( f.read((char *) &Elemento, sizeof(Elemento)))
{
count++; //incremento conteggio posizione
if (Elemento.numero == n)
{
cin.ignore(80, '\n');
cout << "Nuovo titolo: ";
cin.getline(Elemento.titolo, 25);

cout << "Nuove note: ";
cin.getline(Elemento.note, 50);
f.seekp(count*sizeof(Elemento), ios::beg);
f.write((char *) &Elemento, sizeof(Elemento));
break;
}
}
f.close();
return;
}

Ci sono alcuni elementi interessanti da analizzare. Il primo riguarda il
ciclo while. Al suo interno, come condizione, abbiamo posto
l’operazione di lettura stessa. Questa produrrà un valore di verità
falso nel momento in cui non ci saranno più record da leggere. A
ogni iterazione incrementiamo il conteggio della variabile count che
alla fine ci dirà dove abbiamo trovato la struttura da modificare.
Ovviamente, nel caso in cui il numero del fumetto indicato non fosse
presente all’interno del file, il ciclo terminerebbe senza mai eseguire
il contenuto del costrutto if innestato all’interno del ciclo stesso.
A proposito di uscita dal ciclo, notate l’uso dell’istruzione break in
coda al blocco if. In tal modo forziamo l’uscita dal ciclo nel caso in
cui abbiamo trovato l’occorrenza richiesta. Infatti, non avrebbe alcun
senso proseguire nella ricerca nel momento in cui abbiamo trovato il
numero del fumetto che vogliamo modificare.
Tuttavia, questa considerazione ne fa scaturire immediatamente
un’altra. Come ci comportiamo nel caso in cui andiamo a inserire un
nuovo fumetto con un numero di albo già presente nel nostro file? In
linea di principio dovremmo impedire l’inserimento di un fumetto con
un numero già presente, evitando quindi doppioni. Per farlo
potremmo prevedere una funzione di ricerca, simile a quanto
facciamo nella modifica, da utilizzarsi nel caso dell’inserimento di un
nuovo fumetto. La funzione potrebbe restituire un valore booleano
che ci indichi la presenza o meno in archivio di un albo con il numero
indicato.
Tuttavia, anche questa sarebbe una scelta progettuale sulla quale
poter discutere. Ad esempio, potremmo prevedere l’inserimento di
doppioni all’interno del file perché potremmo pensare di realizzare
l’applicativo non per noi ma per un rivenditore di fumetti usati. In

questo caso il programma potrebbe prevedere un ulteriore campo
per indicare lo stato del fumetto usato (se logoro, quasi nuovo ecc.)
ed eventualmente anche il prezzo dell’albo stesso.
È intuitivo a questo punto verificare ancora una volta come le scelte
progettuali iniziali siano fondamentali per tutta la fase di sviluppo e
verifica successiva. Una fretta eccessiva nel voler codificare il
proprio programma senza un’attenta e meditata fase relativa
all’individuazione dei requisiti preliminari e funzionali può portare a
enormi problemi. Questi possono riguardare sia il ritardo nei tempi di
rilascio sia immani difficoltà di manutenzione e aggiornamento
dell’applicativo.
Tornando al caso del nostro esempio, ignoriamo per semplicità in
questo contesto la questione dei doppioni, lasciando a voi per
esercizio l’onere di decidere la strategia da utilizzarsi per la loro
gestione.
Per completare dunque l’esame della funzione di modifica non ci
rimane che analizzare le righe relative alla riscrittura del record
modificato all’interno del file:
f.seekp(count*sizeof(Elemento), ios::beg);
f.write((char *) &Elemento, sizeof(Elemento));

Con la funzione seekp ci spostiamo per la scrittura nella posizione
individuata moltiplicando il numero count, ottenuto durante la ricerca
dell’elemento, per la dimensione in byte dell’elemento stesso. Da
notare che conteggiamo lo spostamento a partire dall’inizio del file
con la modalità ios::beg. La successiva istruzione scrive sul file con le
modalità già viste in precedenza.

Listare il contenuto del file
Siamo giunti finalmente all’ultima funzione che ci eravamo proposti
di implementare: ottenere la lista della nostra collezione di fumetti.
Di seguito una sua possibile implementazione:
void Lista()
{
cout << "LISTA FUMETTI" << endl;
ifstream f;

f.open(NOME_FILE, ios::binary | ios::in);
if(!f)
{
cout << "Il file specificato non esiste!";
return;
}
f.seekg(0, ios::beg);
fumetto Elemento;
while( f.read((char *) &Elemento, sizeof(Elemento)))
{
cout << "Numero: " << Elemento.numero << endl;
cout << "Titolo: " << Elemento.titolo << endl;
cout << "Note: " << Elemento.note << endl;
cout << endl;
}
f.close();
return;
}

La prima cosa che vi faccio notare è la possibilità di verificare
l’esistenza del file relativo al nostro archivio utilizzando, come valore
di verità all’interno dell’if, il valore restituito dalla funzione open. A
rigore, tale controllo potrebbe essere superfluo in quanto l’esistenza
del file la verifichiamo già come prima operazione all’avvio
dell’applicazione. D’altronde, per semplicità, non abbiamo effettuato
tale controllo nelle ultime due funzioni presentate (inserimento e
modifica di un record).
Tuttavia, a ben pensarci, un motivo per effettuare il controllo
dell’esistenza del file in ogni funzione che accede al file stesso
potrebbe esserci. Il motivo potrebbe essere dato dal fatto che il file
potrebbe essere cancellato dal disco, ad esempio da un utente
burlone e malintenzionato, durante l’esecuzione dell’applicazione. In
situazioni del genere l’applicazione, se non attenta a tali tipi di
controlli, potrebbe andare incontro a situazioni del tutto impreviste.
Anche in questo caso facciamo finta che il problema non ci riguardi e
andiamo avanti.
Per il resto, in ogni caso, la funzione Lista è sicuramente la più
semplice. Ci posizioniamo innanzitutto all’inizio del file con la
funzione seekg. Successivamente cicliamo con un while scorrendo il
contenuto del file, come già visto prima, utilizzando il valore di verità
restituito dalla funzione di lettura read.

25
La gestione degli errori e delle
eccezioni
Il C rende facile spararti su un piede;
C++ lo rende più difficile, ma quando
lo fai, ti fa saltare via l’intera gamba.
Bjarne Stroustrup
La gestione degli errori è di fondamentale importanza in qualsiasi
programma si vada a costruire. Durante tutto il percorso realizzato
finora, ci è sistematicamente capitato di dover parlare dei possibili
errori incontro ai quali potevano andare i nostri pezzi di codice. È
giunto il momento di vedere in dettaglio gli strumenti messi a
disposizione dal C++ per controllare e gestire al meglio tali errori e
per tentare quindi di contenerne gli inevitabili effetti collaterali.

Try e catch
Il punto nodale della gestione degli errori in C++ va sotto il nome di
eccezioni. Un’eccezione è una condizione particolare che viene a
essere segnalata in un certo pezzo di codice in seguito al verificarsi
di un dato evento. In maniera un po’ più tecnica si dice che il codice
solleva o lancia un’eccezione. Ciò affinché un’altra parte del codice
stesso possa gestire senza traumi tale condizione di anomalia.
Il pezzo di codice che prevede il controllo per l’eccezione usa la
parola chiave try seguita da un blocco di parentesi graffe.
L’eccezione vera e propria viene sollevata dalla parola chiave throw.
Infine, utilizziamo la parola chiave catch per gestire la segnalazione
dell’eccezione stessa.
Vediamo subito il formalismo del codice in una delle espressioni più
semplici possibile:
try
{
//qui la verifica per un possibile errore
throw 1;
}
catch (int e)
{
cout << "Attenzione. Eccezione numero: " << e << endl;
}

Nel caso in cui si verifichi una certa situazione all’interno del blocco
try solleviamo l’eccezione con throw passando alla sezione catch il
valore 1. Tale valore è in questo caso scelto a nostra completa
discrezione.
La parola chiave catch richiede di essere seguita da una coppia di
parentesi tonde all’interno delle quali catturiamo il valore passato
attraverso la parola chiave throw. In questo caso si tratta di un intero
che associamo alla variabile che definiamo come int e.
È ora tuttavia indispensabile dettagliare meglio il funzionamento di
questa struttura di gestione degli errori con un esempio
maggiormente completo. Supponiamo di dover effettuare una

divisione tra due interi. Esiste ovviamente il rischio che il divisore sia
uguale a zero con conseguente errore dell’applicazione. Infatti, nella
matematica dei numeri reali una divisione per zero non ha
significato.
Per controllare tale situazione possiamo organizzare il codice come
segue:
#include <iostream>
using namespace std;
int main()
{
int a,b;
cout << "Primo numero: ";
cin >> a;
cout << "Secondo numero: ";
cin >> b;
try
{
if (b==0)
{
throw 1;
}
else
{
cout << "Risultato della divisione: " << a/b <<
endl;
}
}
catch (int e)
{
cout << "Eccezione catturata con numero di errore: " <<
e << endl;
}
return 0;
}

Come potete osservare, presi in input dividendo e divisore,
verifichiamo il valore del divisore. Se questo risulta uguale a zero
lanciamo l’eccezione con throw passando il valore intero 1. In caso
contrario effettuiamo la normale divisione. Il catch cattura l’intero
passato tramite l’invocazione dell’eccezione e stampa un messaggio
a video in accordo con tale situazione.
Supponiamo ora che nella stessa situazione si voglia passare non

più un intero ma un messaggio di testo sotto forma, ad esempio, di
stringa costante. Dobbiamo effettuare due modifiche. La prima è
relativa al throw e la seconda al catch. Tale costrutto è noto anche
come gestore d’eccezioni o nel contesto anglosassone exception
handler.
Il codice potrebbe essere il seguente:
#include <iostream>
using namespace std;
int main()
{
int a, b;
cout << "Primo numero: ";
cin >> a;
cout << "Secondo numero: ";
cin >> b;
try
{
if (b==0)
{
throw "Divisione per zero!";
}
else
{
cout << "Risultato della divisione: " << a/b <<
endl;
}
}
catch (const char* msg)
{
cout << "Eccezione catturata con messaggio: " << msg <<
endl;
}
return 0;
}

Il codice così modificato dovrebbe essere facilmente interpretabile.
Con throw passiamo al catch il messaggio di testo: "Divisione per
zero!".
Attenzione, infine, all’argomento del catch stesso definito come: const
char* msg.

Gestori multipli
Abbiamo visto come intercettare con un catch l’errore sollevato con
throw. La cosa da sottolineare è che è possibile inserire in cascata
differenti blocchi catch. Solo uno di essi verrà però eseguito. Questo
sarà scelto in base al tipo di argomento passato dal throw.
Di seguito un esempio chiarificatore:
#include <iostream>
using namespace std;
int main()
{
int a, b;
cout << "Primo numero: ";
cin >> a;
cout << "Secondo numero: ";
cin >> b;
try
{
if (b==0)
{
throw 1.0;
}
else
{
cout << "Risultato della divisione: " << a/b <<
endl;
}
}
catch (int e)
{
cout << "Eccezione catturata con numero di errore: " <<
e << endl;
}
catch (const char* msg)
{
cout << "Eccezione catturata con messaggio: " << msg <<
endl;
}
catch (...)
{

cout << "Eccezione generica."<< endl;
}
return 0;
}

In coda al codice trovate i blocchi catch pronti per catturare
l’eccezione generata. La novità che potete immediatamente
individuare è data dal costrutto finale catch (...){}. I tre puntini
sospensivi (in inglese sono chiamati ellipsis) servono per indicare
una sorta di default, come avviene per il costrutto switch.
Se nessuno dei costrutti catch cattura l’esecuzione rispetto al tipo
passato come argomento dal throw viene eseguito il blocco con tali
puntini sospensivi. In effetti, se ci pensate, l’organizzazione del
costrutto a scelta multipla switch e il modo in cui gestiamo i catch
hanno vari aspetti comuni. Una diversità risiede comunque,
sicuramente, nel fatto che non è richiesta alcuna istruzione break.
Una volta eseguito un catch che corrisponde per tipo, infatti,
l’esecuzione salta alla fine di tutti gli altri costrutti catch.
Nell’esempio che vi ho proposto, a catturare l’eccezione è proprio la
parte di costrutto “generica”. Infatti, poiché all’interno dell’if ho scritto
throw 1.0; il tipo passato nell’eccezione è un numero con la virgola. I
blocchi catch fanno invece riferimento a un tipo intero e a una stringa.
Nessuno dei due può quindi catturare l’eccezione che verrà gestita
dal blocco con i puntini sospensivi.

Eccezioni standard
Oltre alla possibilità di organizzare in modo personale la gestione
delle eccezioni abbiamo anche l’opportunità di sfruttare una serie di
eccezioni, note come eccezioni standard, messe a disposizione dal
linguaggio stesso. In particolare, la libreria standard fornisce una
classe base specifica, per l’utilizzo della quale è necessario
predisporre una corrispondente direttiva include:
#include <exception>

Un possibile modo di utilizzo per tale contesto potrebbe essere il
seguente:
try
{
// codice
}
catch (const std::exception& e)
{
// Gestione eccezione e
}

Per un esempio concreto di questa metodologia dovete tuttavia
pazientare fino al capitolo successivo, relativo all’allocazione
dinamica della memoria.

26
L’allocazione dinamica della
memoria
Il tempo si muove in una direzione, i

ricordi in un’altra.
William Gibson
In questo capitolo torniamo a parlare di memoria, di variabili e delle
conseguenze che l’uso della memoria può avere sulle nostre
applicazioni. Se facciamo una riflessione sugli aspetti relativi alle
dimensioni dei problemi che abbiamo trattato finora, scopriremo,
infatti, che abbiamo vissuto con una sorta di fantasma: la
dimensione fissa. Credo che la cosa più semplice che si possa fare
per comprendere il senso di quello che sto affermando sia quella di
pensare alle strutture dati complesse come gli array.
Quando dichiariamo un array, siamo costretti a definire a priori una
dimensione per la struttura dati. Il più delle volte abbiamo pensato
bene di usare una direttiva #define per essere più liberi nella gestione
di tale limitazione, che in ogni caso esiste.
#define MAX 1000
…
int x[MAX];

Il motivo, banale, è dato dal fatto che il compilatore deve sapere in
dettaglio quanta memoria allocare per una specifica variabile. Per
chiarire la situazione vi presento il seguente pezzo di codice:
#include <iostream>
using namespace std;
int main()
{
cout << "L'impossibilità di gestire le necessità del
momento!" << endl;
int n;
cout << "Di quanto spazio hai bisogno?";
cin >> n;
int a[n]; //non consentito
return 0;
}

Tale approccio non è consentito in quanto, come già ampiamente
detto, la dimensione dell’area di memoria da allocare per l’array
deve essere nota in fase di compilazione.
Ovviamente ciò può rappresentare un grosso ostacolo. Non sempre
la dimensione del problema è infatti nota prima dell’esecuzione e
qualsiasi scelta a tal proposito può comportare delle conseguenze.
Ad esempio, come già visto in altri casi, se ci limitiamo troppo nella
grandezza dei dati a disposizione, potremmo non riuscire a
memorizzare determinati elementi che non rientrano nello spazio a
disposizione. D’altra parte, esagerare con le previsioni può portare a
sprecare inutilmente spazio di memoria.
In altri casi potremmo essere fisicamente limitati dalla quantità delle
risorse di memoria disponibili sulla specifica macchina. Per capire
tale limitazione basta immaginarsi cosa può succedere se
eccediamo con la grandezza del numero assegnato a una costante.
Usando l’esempio precedente, istruzioni come:
#define MAX 10000000

possono portare a comportamenti inaspettati o, in alcuni casi,
all’impossibilità di compilare segnalata dal compilatore stesso.
Il problema delle dimensioni dello spazio di memoria occupato si
presenta in realtà anche con l’uso di variabili di tipo semplice.

Quando scriviamo qualcosa del tipo:
int x = 10;

il compilatore assegna nella memoria RAM il numero di byte
necessari per la memorizzazione di un intero sulla specifica
architettura. Tali variabili prendono il nome di variabili statiche
automatiche. In generale, esse vivono per un tempo di esecuzione
relativo al blocco di codice nel quale sono dichiarate e
successivamente, alla fine del blocco in questione, muoiono
diventando quindi inaccessibili.
Di seguito vi propongo un semplice esempio, che ritengo sia
estremamente chiarificatore, in relazione a due questioni
fondamentali che stiamo descrivendo relativamente alle variabili
automatiche: il loro ciclo di vita rispetto al blocco in cui sono
dichiarate e la necessità del compilatore di conoscere a priori il
contesto di cui occuparsi:
#include <iostream>
using namespace std;
int main()
{
{
int x = 0;
}
cout << x; // Attenzione: il codice genera un errore
return 0;
}

Il pezzo di codice presentato genererà le seguenti segnalazioni:
warning: unused variable 'x'
error: 'x' undeclared (first use this function)

Il primo è un avvertimento: la variabile x non viene utilizzata.
Facciamo infatti attenzione al blocco di parentesi che racchiude la
dichiarazione con inizializzazione int x = 0;.
Tale blocco fa sì che la variabile x in esso dichiarata viva solo in tale
blocco, isolata dal “mondo esterno”. Poiché in tale blocco non
utilizziamo la variabile stessa, il compilatore ci avverte dell’anomalia:
perché mai dichiarare una variabile per poi non utilizzarla? Il

compilatore non può sapere che stiamo facendo un esempio e si
comporta in modo diligente rispetto ai suoi compiti. Il compilatore è
poi così puntiglioso da rifiutarsi anche di compilare, generando un
errore segnalandoci che la variabile x utilizzata nella stampa con cout
non è stata dichiarata ('x' undeclared). Infatti, come già visto, la
variabile x, dichiarata e inizializzata nel blocco di parentesi
precedente, non è visibile all’esterno di tale blocco e quindi la x
coinvolta nella cout è a tutti gli effetti un’altra variabile completamente
differente.
È di estremo interesse ora chiedersi cosa succeda allo spazio di
memoria occupato dalle variabili statiche automatiche. Purtroppo
non c’è modo per il programma di riutilizzare direttamente tale
spazio per eventuali altre variabili, in quanto tale gestione è
demandata al sistema stesso.

Stack e Heap: come gestire la
memoria
Infatti, una variabile automatica viene memorizzata in un’area di
memoria riservata al programma denominata stack, che una volta
saturata non può più essere utilizzata. Non a caso in una tale
eventualità si parla di overflow dello stack, che potremmo tradurre
in italiano con qualcosa del tipo “traboccamento” dello stack. Ma che
assolutamente non traduciamo conservando la dizione inglese!
In effetti, una tale situazione si potrebbe verificare quando si
dichiarano delle variabili all’interno di un ciclo troppo lungo o in
situazioni di eccessive chiamate ricorsive di funzioni.
Sembra una strada senza uscita. In realtà l’ideale sarebbe invece
una situazione in cui poter dichiarare e utilizzare di volta in volta solo
lo spazio di cui abbiamo bisogno in un dato momento. Ad esempio,
nel momento in cui un utente del nostro applicativo inserisce un
nuovo record, vorremmo poter assegnare la quantità di memoria
necessaria per tale operazione e successivamente dichiarare che
tale memoria non ci interessa più per poterla rilasciare al sistema
operativo. In tal modo il sistema potrebbe riavere in carico la
memoria rilasciata per riutilizzarla in seguito per eventuali nuove
richieste. Fortunatamente tale meccanismo è possibile grazie a una
seconda area di memoria dedicata all’allocazione dinamica della
memoria: la memoria heap.

New e delete: operiamo
dinamicamente sulla memoria
Dovrebbe allora essere chiaro che ciò di cui abbiamo bisogno è un
meccanismo che consenta di richiedere al sistema l’esatta quantità
di memoria per una certa operazione e quindi un analogo
meccanismo per rilasciare al sistema la memoria quando non più
necessaria, in modo che il sistema stesso possa renderla disponibile
per future richieste.
A tale scopo il linguaggio C dispone di una serie di funzioni rese
disponibili attraverso il file di intestazione stdlib.h. Tali funzioni sono:
malloc, realloc, calloc e free. In realtà, anche se relative al
linguaggio C, tali funzioni sono tranquillamente utilizzabili all’interno
di codice C++ tramite la libreria cstdlib.
Tuttavia, il linguaggio C++ dispone di propri strumenti per la gestione
dinamica della memoria; una fantastica coppia di specifiche
istruzioni: new e delete.
Dovrebbe risultare abbastanza naturale pensare al fatto che la
gestione dinamica della memoria abbia a che fare in maniera diretta
con il concetto di puntatore.
Vediamo infatti come procedere partendo dall’allocazione di uno
spazio di memoria per contenere una semplice variabile di tipo
intero.
#include <iostream>
using namespace std;
int main()
{
cout << "Una singola variabile dinamica" << endl;
int *p = new int;
*p = 1;
cout << "Il valore e': " << *p << endl;
delete p;
return 0;
}

L’istruzione sulla quale porre la nostra attenzione è la seguente:
int *p = new int;

Con essa dichiariamo una variabile puntatore, di nome p, a un’area
di memoria predisposta per contenere un intero. Successivamente,
con *p = 1; assegniamo al contenuto di p il valore intero 1. La parolina
magica è appunto l’operatore new, che fa sì che tale spazio di
memoria sia gestito all’interno della sezione heap. Per il resto, se
avete digerito i puntatori, il tutto dovrebbe risultare abbastanza
chiaro.
Ora qualche parola sull’operatore delete che si preoccupa di liberare
la memoria utilizzata dal puntatore. La cosa che forse vale la pena di
sottolineare è che la variabile puntatore continua a essere presente,
mentre ciò che viene “cancellato” è lo spazio di memoria
precedentemente disponibile e quindi la possibilità di accedervi. Per
evitare problemi e tener traccia dei puntatori che dopo una delete
continuano a puntare a un’area di memoria non più disponibile (in
quanto rilasciata al sistema operativo), si può pensare di impostare a
zero il valore del puntatore aggiungendo in coda al codice
precedente l’istruzione:
p = 0;

Il dinamismo di un array
Dopo aver visto la modalità più semplice di gestione dinamica della
memoria riguardante una singola variabile, vediamo ora come
prevedere un approccio dinamico in presenza di un array di
elementi. Tale approccio richiede la seguente sintassi:
int *p = new int[n];

dove n rappresenta la dimensione dell’array da creare utilizzando
l’allocazione dinamica, riservando memoria dalla sezione heap. A
ben guardare non c’è gran differenza rispetto alla sintassi utilizzata
per la gestione di una singola variabile; l’unica particolarità è data
dall’utilizzo delle parentesi quadre, che contengono la dimensione
dell’array da allocare dinamicamente. Tali parentesi, che d’altronde
sono una caratteristica già ampiamente familiare quando si ha a che
fare con gli array, vengono utilizzate anche nel caso dell’operatore
delete riferito al rilascio di memoria allocata per una array. La sintassi
per questo caso è infatti la seguente:
delete[] p;

Se facciamo un passo indietro e ricordiamo quanto sia stretto il
rapporto tra puntatori e array, già analizzato nel contesto del C, non
ci sorprenderà più di tanto il fatto che è possibile utilizzare la
variabile puntatore per riferirsi alle singole posizioni dell’array,
scrivendo qualcosa del tipo: p[i] per indicare la i-esima posizione
dell’array in questione.
Di seguito mettiamo insieme tali concetti in un piccolo pezzo di
codice che chiede all’utente la dimensione dell’area da allocare e
dopo tale allocazione riempie l’array stesso con numeri interi a
partire da 1 fino a riempire l’intera struttura dati.
#include <iostream>
using namespace std;
int main()
{
cout << "Allocazione dinamica" << endl;

int n;
cout << "Di quanto spazio hai bisogno?";
cin >> n;
//allocazione array
int *p = new int[n];
//valorizzazione array
int i;
for (i=0; i <n; i++)
{
p[i]=i+1; //l'array parte da zero ma noi inseriamo i
numeri a partire da 1 (quindi i+1)
}
//stampa array
for (i=0; i <n; i++)
{
cout << p[i] << " ";
}
//deallocazione
delete[] p;
return 0;
}

I memory leaks
Come si è visto, le procedure relative all’allocazione della memoria
vengono realizzate in maniera manuale dal programmatore. Siamo
noi a dover richiedere esplicitamente una data quantità di memoria e
successivamente comunicare al sistema che tale memoria non è più
di nostro interesse. Proprio il mancato rilascio della memoria allocata
può causare grossi problemi al programma e incidere addirittura
sulla stabilità dell’intero sistema. Il motivo è dato dal fatto che, una
volta allocata la specifica quantità di memoria, questa viene riservata
per l’uso richiesto dall’applicativo e, se non liberata con l’istruzione
delete, rimane inaccessibile per usi futuri.
Infatti la variabile puntatore, che in fase di new punta all’area di
memoria in oggetto, nel momento in cui termina il suo ciclo di vita,
uscendo ad esempio dalla funzione nella quale è dichiarata, perde il
riferimento a tale area di memoria. Con essa si perde anche
qualsiasi possibilità di referenziare tale area che, pur continuando a
esistere, diventerà assolutamente irraggiungibile e quindi non più
utilizzabile. Tale situazione prende il nome di memory leak.
Un memory leak è dunque una situazione per la quale si perde la
possibilità di gestire l’area di memoria precedentemente allocata.
Poiché tale area di memoria è gestita attraverso una variabile
puntatore, un errore relativo a una errata manipolazione di tale
puntatore può portare a un altro tipo di memory leak come, per
esempio, se si dovesse cambiare inavvertitamente il suo valore.

Verifichiamo la disponibilità di spazio
di memoria
La memoria è una risorsa fisica della macchina e, come tale, ha una
sua dimensione che, per quanto grande possa essere, è pur sempre
limitata. Cosa succede se proviamo a richiedere memoria per
un’allocazione dinamica e questa non è disponibile? In effetti i
risultati sono del tutto imprevisti e potrebbero comportare anche il
blocco dell’applicazione. Un buon programmatore sa che già
esistono tutta una serie di problemi ai quali può andare incontro la
propria applicazione e che non è proprio il caso di crearsene di nuovi
per semplice pigrizia. La questione è banale: controllare la
disponibilità del sistema ad allocare memoria prima di utilizzarla.
Un sistema molto semplice e intuitivo è basato sulla circostanza che
in caso di fallimento dell’allocazione, l’operatore new restituisce il
valore zero. Tuttavia, in caso di anomalia nell’allocazione, il sistema
genera un’eccezione che dovremmo impegnarci a catturare. Nel
caso non si voglia gestire tale eccezione è necessario dirlo
esplicitamente usando, subito dopo l’operatore new, la parola chiave
nothrow, come vi mostro nell’esempio seguente:
#include <iostream>
using namespace std;
int main()
{
int *p;
p = new (nothrow) int [1000000000];
if (p == 0)
{
cout << "Allocazione FALLITA!";
}
else
{
cout << "Allocazione riuscita";
}
return 0;
}

È probabile che anche sul vostro sistema venga segnalato un errore
di allocazione fallita a causa delle eccessive dimensioni dell’array
dinamico richiesto tramite new.
Vediamo ora invece come gestire la situazione di errore nel caso di
utilizzo delle eccezioni standard. Il codice potrebbe essere il
seguente:
#include <iostream>
#include <exception>
using namespace std;
int main()
{
try
{
// codice
int *p;
p = new int [1000000000];
}
catch (exception& e)
{
// Gestione eccezione e
cout << "Allocazione FALLITA! " ;
cout << "Eccezione standard: " << e.what() << endl;
}
return 0;
}

La cosa interessante di questo stralcio di codice è il contenuto del
catch. Al suo interno facciamo riferimento alla classe exception definita
nell’omonimo file di include <exception>. Rispetto a tale classe
sfruttiamo la funzione what(), che restituisce il tipo di errore
riscontrato, nel nostro caso St9bad_alloc.

Allochiamo dinamicamente oggetti
Uno degli aspetti forse più interessanti e utili della gestione dinamica
della memoria è la possibilità di allocare dinamicamente non solo
semplici variabili e array, ma anche gli oggetti. Ovviamente, come
intuibile, utilizziamo gli operatori new e delete già visti in precedenza e
con modalità del tutto simili.
Di seguito vi presento, senza ulteriori indugi, un esempio che si basa
sulla ormai ben nota classe Rettangolo già più volte utilizzata.
#include <iostream>
using namespace std;
class Rettangolo
{
public:
int x;
int y;
Rettangolo(int, int);
int Area();
};
Rettangolo::Rettangolo(int a, int b)
{
x = a;
y = b;
}
int Rettangolo::Area()
{
return x * y;
}
int main()
{
cout << "La mia classe rettangolo e' dinamica" << endl;
Rettangolo *pR1 = new Rettangolo (4, 7);
cout << "L'area del rettangolo vale: " << pR1->Area() << endl;
delete pR1;
return 0;
}

In realtà, l’unica novità del codice è il modo con cui dichiariamo e ci
riferiamo all’oggetto Rettangolo. La creazione dell’oggetto in maniera

dinamica è demandata all’istruzione:
Rettangolo *pR1 = new Rettangolo (4, 7);

Per leggerla in maniera più rassicurante la possiamo confrontare con
l’istruzione utilizzata per allocare dinamicamente una variabile di tipo
intero, vista in precedenza:
int *p = new int;

Come potete osservare, Rettangolo rappresenta un tipo così come lo
è int. Se vogliamo, l’unica differenza sostanziale è data dai
parametri che passiamo al costruttore all’interno delle parentesi
tonde. Tuttavia, la somiglianza diventa addirittura impressionante nel
momento in cui vi rivelo che nel caso di variabili di tipo semplice è
possibile allocare dinamicamente la variabile e inizializzarla
direttamente a uno specifico valore, come vi mostro di seguito:
int *p = new int(10);

dove 10 è il voto che vi meritate per avermi seguito fino a questo
punto.
Per il resto, in relazione all’esempio della classe Rettangolo, non c’è
molto da dire. Facendo riferimento ai puntatori usiamo la notazione
freccia per riferirci alla funzione membro Area. Infine deallochiamo
l’oggetto con delete.

27
Le interfacce grafiche e la
programmazione guidata da
eventi
La saggezza consiste nel sapere
quando si può evitare la perfezione.
Arthur Bloch
Finora tutte le applicazioni che abbiamo realizzato sono state di tipo
console e quindi puramente testuali. Ho già motivato tale scelta in
più
occasioni.
Imparare
a
programmare
non
richiede
necessariamente la creazione di applicazioni di tipo grafico con
finestre e menu. Anzi, per certi aspetti la creazione di applicazioni
testuali ci forza allo studio dei dettagli della programmazione senza
costringerci a digerire gli innumerevoli aspetti coinvolti nella
realizzazione di elementi di tipo grafico.
Inoltre, come già detto in altre occasioni, né il linguaggio C
tantomeno il C++ posseggono strumenti autonomi per la creazione
di tali applicazioni. È quindi di norma indispensabile rifarsi all’utilizzo
di apposite librerie: MFC, GTK o QT solo per citarne alcune. Nel
prosieguo vi presento un approccio relativo al contesto Windows che
seppur rappresenti una scelta inevitabilmente parziale può farvi

comprendere le problematiche di tipo generale che coinvolgono lo
sviluppo di tali applicazioni.
Inizio con alcune indicazioni di carattere generale relative allo
sviluppo di applicazioni grafiche.

La programmazione guidata da eventi
La programmazione “classica” prevede la scrittura di codice prodotto
per risolvere un dato problema indicando in modo sostanzialmente
sequenziale le attività da realizzare. Un qualcosa del tipo: fai
questo, chiedi questo valore, calcola quest’altro, e così via
discorrendo.
Un tale approccio risulta abbastanza pratico e applicabile in differenti
occasioni: ma non sempre! Il caso più lampante e intuitivo può
essere proprio quello di un’applicazione a finestre, classica di un
ambiente grafico tipo Windows del quale stiamo discutendo.

Figura 27.1 – Una tipica applicazione Windows.
In un’applicazione di questo tipo, infatti, sono generalmente presenti

svariati elementi “attivi” con i quali l’utente deve interagire: bottoni,
voci di menu, liste ecc.
È intuitivo comprendere come un’applicazione di questo tipo sia
difficilmente trattabile con un approccio sequenziale.
Ogni elemento dell’interfaccia rappresenta, infatti, un punto da cui
può scaturire un’azione a causa del fatto che l’utente agisca, a puro
titolo di esempio, con un click o un doppio click del mouse,
sull’elemento stesso.
Compreso il contesto e le problematiche connesse, cerchiamo allora
una soluzione a questo tipo di situazioni iniziando a essere più
formali nella terminologia da utilizzare.
Cominciamo con il dire che gli elementi presenti all’interno di una
finestra di un’applicazione prendono il nome di widget, oppure di
controlli. Una casella di testo (text box), un’etichetta (label) o un
bottone sono tutti esempi di widget.
Tali elementi rappresentano l’interfaccia vera e propria
dell’applicazione e il mezzo con cui l’utente può inviare dei comandi
all’applicazione stessa. Ciò avviene abitualmente tramite l’utilizzo del
mouse e/o della tastiera; ad esempio, relativamente al mouse,
l’utente può esercitare delle azioni come un click oppure un doppio
click su di un widget.
Tali azioni prendono il nome di eventi, che vengono scatenati da
appositi messaggi inviati all’applicazione.
Il concetto di evento, così importante in questo tipo di contesto,
diventa allora l’elemento centrale di uno specifico approccio nel
realizzare applicazioni: la programmazione guidata da eventi.
Tale modo di affrontare lo sviluppo viene spesso anche definito
Modello Hollywood, prendendo spunto da una classica frase che
recita “Don’t call us, we’ll call you” propria degli ambienti del mondo
dello spettacolo. La frase, traducibile in italiano come “Non
chiamarci, ti chiameremo noi” (il classico “Le faremo sapere”), ben si
adatta a situazioni in cui sarà il controllo a chiamare il codice da
eseguirsi in caso di un’azione effettuata su di esso piuttosto che il
realizzarsi che sia il codice di sua iniziativa a richiedere specifiche
azioni all’utente dell’applicazione.
A livello implementativo, questo approccio può essere sintetizzato in
due specifici momenti di programmazione.

Di norma, un primo momento vede la realizzazione e il disegno
dell’interfaccia grafica dell’applicazione con tutti i suoi widgets:
finestre, bottoni, liste ecc.
In un secondo momento si scrive, per ciascun elemento
dell’interfaccia che si vuole coinvolgere nell’applicazione, una serie
di istruzioni relative a ciò che si vuole far fare all’elemento nel
momento in cui questo subisce uno specifico evento. A puro titolo di
esempio si potrebbe pensare a un bottone che subisce un clic del
mouse e reagisce mostrando un apposito messaggio di testo.

Che fatica aprire una finestra
Creare una finestra Windows può sembrare un’operazione banale.
Tale convinzione è sicuramente basata sul fatto che le finestre sono
elementi con i quali abbiamo sistematicamente e comunemente a
che fare. Tuttavia, una cosa è usare un oggetto, tutt’altra cosa è
crearlo. Diversi ambienti di sviluppo consentono la creazione di
finestre in modo grafico e intuitivo. Tuttavia il codice per aprire e
gestire una finestra anche assolutamente basilare è abbastanza
complesso e ci affidiamo quindi al wizard (procedura guidata)
dell’ambiente di sviluppo.
Nel caso di Code::Blocks selezioniamo la voce di menu File - New Project e scegliamo il tipo Win32 GUI project. Vi ricordo che GUI è
l’acronimo di Graphical User Interface, appunto interfaccia grafica
per l’utente.

Figura 27.2 – La scelta del tipo di progetto per un’applicazione a
finestre di tipo Windows.

Successivamente selezioniamo nel wizard il tipo Frame based. Tale
tipologia è contrapposta alla selezione Dialog based. Quest’ultima è
consigliata solo nel caso di applicazioni di ridotte dimensioni, con
pochi elementi da gestire. Un esempio tipico e chiarificatore può
essere quello di un programma che realizza una calcolatrice, nella
quale abbiamo una piccola finestra con una serie di bottoni e
qualche altro semplice elemento. Solo in casi come questo è
consigliabile usare il modello Dialog based.
Di seguito vi riporto quindi il codice prodotto dall’ambiente
Code::Blocks relativo alla scelta di tipo Frame e salvato nel file
main.cpp.
#include <windows.h>
/* Declare Windows procedure */
LRESULT CALLBACK WindowProcedure (HWND, UINT, WPARAM, LPARAM);
/* Make the class name into a global variable */
char szClassName[ ] = "CodeBlocksWindowsApp";
int WINAPI WinMain (HINSTANCE hThisInstance,
HINSTANCE hPrevInstance,
LPSTR lpszArgument,
int nCmdShow)
{
HWND hwnd;
/* This is the handle for our
window */
MSG messages;
/* Here messages to the
application are saved */
WNDCLASSEX wincl;
/* Data structure for the
windowclass */
/* The Window structure */
wincl.hInstance = hThisInstance;
wincl.lpszClassName = szClassName;
wincl.lpfnWndProc = WindowProcedure;
/* This function is
called by windows */
wincl.style = CS_DBLCLKS;
/* Catch doubleclicks */
wincl.cbSize = sizeof (WNDCLASSEX);
/* Use default icon and mouse-pointer */
wincl.hIcon = LoadIcon (NULL, IDI_APPLICATION);
wincl.hIconSm = LoadIcon (NULL, IDI_APPLICATION);
wincl.hCursor = LoadCursor (NULL, IDC_ARROW);
wincl.lpszMenuName = NULL;
/* No menu */
wincl.cbClsExtra = 0;
/* No extra bytes
after the window class */

wincl.cbWndExtra = 0;
/* structure or the
window instance */
/* Use Windows's default colour as the background of the
window */
wincl.hbrBackground = (HBRUSH) COLOR_BACKGROUND;
/* Register the window class, and if it fails quit the
program */
if (!RegisterClassEx (&wincl))
return 0;
/* The class is registered, let's create the program*/
hwnd = CreateWindowEx (
0,
/* Extended possibilites for
variation */
szClassName,
/* Classname */
"Code::Blocks Template Windows App",
/* Title
Text */
WS_OVERLAPPEDWINDOW, /* default window */
CW_USEDEFAULT,
/* Windows decides the position
*/
CW_USEDEFAULT,
/* where the window ends up on
the screen */
544,
/* The programs width */
375,
/* and height in pixels */
HWND_DESKTOP,
/* The window is a child-window
to desktop */
NULL,
/* No menu */
hThisInstance,
/* Program Instance handler */
NULL
/* No Window Creation data */
);
/* Make the window visible on the screen */
ShowWindow (hwnd, nCmdShow);
/* Run the message loop. It will run until GetMessage()
returns 0 */
while (GetMessage (&messages, NULL, 0, 0))
{
/* Translate virtual-key messages into character
messages */
TranslateMessage(&messages);
/* Send message to WindowProcedure */
DispatchMessage(&messages);
}
/* The program return-value is 0 - The value that
PostQuitMessage() gave */
return messages.wParam;
}

/* This function is called by the Windows function
DispatchMessage() */
LRESULT CALLBACK WindowProcedure (HWND hwnd, UINT message,
WPARAM wParam, LPARAM lParam)
{
switch (message)
/* handle the messages */
{
case WM_DESTROY:
PostQuitMessage (0);
/* send a WM_QUIT to the
message queue */
break;
default:
/* for messages that we
don't deal with */
return DefWindowProc (hwnd, message, wParam,
lParam);
}
return 0;
}

In effetti, a prima vista il codice in questione può incutere paura. La
sua compilazione e relativa esecuzione visualizzerà la finestra
mostrata nella Figura 27.3.

Figura 27.3 – L’applicazione Windows generata dal wizard frame
based.
Cominciamo dunque a esaminare il codice realizzato per noi
dall’ambiente. In tale lavoro saremo agevolati dal fatto che il wizard
introduce nel codice in maniera automatica svariati commenti che,
anche se in lingua inglese, ci agevolano di moto nella comprensione
delle funzionalità delle varie parti del codice stesso.
Partendo dall’inizio, la prima cosa sulla quale ci soffermiamo è la

riga:
#include <windows.h>

Si tratta del file di include principale per lo sviluppo di applicazioni
Windows che richiama a sua volta tutta una serie di ulteriori file di
include per la gestione delle librerie necessarie per le applicazioni
Windows stesse.

WinMain: il punto di ingresso
dell’applicazione
Saltando qualche riga di codice incontriamo il punto di ingresso
dell’applicazione:
int WINAPI WinMain (HINSTANCE hThisInstance,
HINSTANCE hPrevInstance,
LPSTR lpszArgument,
int nCmdShow)

La funzione WinMain realizza dunque l’analoga funzionalità del
classico main, tante volte visto nel contesto delle applicazioni console.
Come si vede chiaramente, tale funzione restituisce un intero.
Questo valore può essere utilizzato come stato di uscita del
programma da qualche altra applicazione che richiami il programma
stesso. Esso non viene utilizzato dal sistema operativo.
Analizzando il prototipo della funzione, scopriamo un elemento del
tutto nuovo rispetto a quanto finora visto per le funzioni stesse.
Siamo infatti abituati a confrontarci con qualcosa del tipo:
valore_restituito NomeFunzione(argomenti_input)

mentre in questo caso incontriamo un nuovo elemento sotto forma
della parola chiave WINAPI. Si tratta di una cosiddetta calling
convention, ovvero convenzione per la chiamata. Una calling
convention definisce il modo con cui la funzione riceve i parametri
dal chiamante la funzione stessa. Per i nostri scopi tale informazione
può essere sufficiente e possiamo quindi limitarci a controllare che la
voce venga utilizzata così come proposta dall’ambiente.
Più interessante risulta analizzare i quattro parametri presi in input
dalla nostra funzione.

• hThisInstance rappresenta un handle per l’istanza
dell’applicazione,
ovvero
un
collegamento
utilizzato dal sistema operativo per identificare

l’eseguibile caricato all’interno della memoria della
macchina. Può inoltre essere utilizzato per la
gestione di icone o immagini collegate
all’applicazione.
• hPrevInstance non è più usato ed è posto sempre a
zero. È un retaggio del mondo Windows a 16 bit
dove serviva a evitare di aprire più volte lo stesso
file eseguibile.
• lpszArgument rappresenta, sotto forma di puntatore a
stringa, gli eventuali argomenti passati sulla riga di
comando.
• nCmdShow è un valore intero che indica come verrà
visualizzata la finestra dell’applicazione al lancio
della stessa: minimizzata, massimizzata oppure
mostrata nelle sue dimensioni originali predefinite.

La struttura di una finestra
Procediamo con l’analisi della nostra applicazione osservando cosa
succede all’interno della funzione WinMain. La prima cosa di interesse
è la riga:
WNDCLASSEX wincl;
*/

/* Data structure for the windowclass

Con tale istruzione dichiariamo una struttura di tipo WNDCLASSEX. Ogni
finestra Windows deve possedere un riferimento a una struttura di
tale tipo, in quanto in essa vengono memorizzate tutta una serie di
caratteristiche della finestra stessa.
Vi invito a notare le varie valorizzazioni dei membri della struttura
attraverso il classico operatore . (punto).
Subito dopo tali valorizzazioni proviamo a registrare all’interno del
sistema la nostra finestra, ovvero a far sapere a Windows della sua
esistenza con il codice:
if (!RegisterClassEx (&wincl))
return 0;

Come si evince chiaramente dall’uso dell’operatore logico not (il
punto esclamativo) in caso di fallimento dell’operazione usciamo
brutalmente.
Al contrario, se tutto è andato per il verso giusto procediamo a
creare la nostra finestra utilizzando la seguente chiamata:
hwnd = CreateWindowEx (…);

dove per brevità ho inserito i puntini sospensivi al posto dei vari
parametri che possiamo passare per dettagliare le nostre richieste di
creazione.
Tanto per citarne uno, potete osservare il terzo parametro,
valorizzato con la stringa "Code::Blocks Template Windows App" che
rappresenta il nome dell’applicazione visualizzato sulla barra del
titolo dell’applicazione stessa. Potete iniziare proprio da tale
parametro, sostituendolo ad esempio con la stringa "La mia prima

per personalizzare e adattare alle vostre
esigenze il modello proposto dal wizard di Code::Blocks.
Arrivati a questo punto, non ci resta che visualizzare la nostra brava
finestra con la funzione:
applicazione

Windows"

ShowWindow (hwnd, nCmdShow);

nella cui chiamata è possibile riconoscere i due argomenti; il primo
come handle della finestra e il secondo indicante le modalità di
apertura.

Un loop per i messaggi
Una volta che la finestra è visualizzata all’interno del sistema, essa è
pronta per interagire con il mondo esterno e quindi con l’utente. Un
clic sulla tastiera o addirittura, più semplicemente, il movimento del
mouse sulla finestra causano l’invio di messaggi alla nostra
applicazione che vengono inseriti in una speciale coda dei
messaggi associata all’applicazione stessa.
Per gestire tale coda, e quindi l’insieme dei messaggi inviati, ogni
applicazione deve prevedere un apposito ciclo: il loop dei
messaggi. Tale struttura di controllo serve dunque all’applicazione
per catturare i messaggi e inviarli alla giusta finestra, considerando
infatti che una stessa applicazione può contenere differenti finestre.
Nel nostro caso il ciclo è implementato come segue:
/* Run the message loop. It will run until GetMessage() returns 0 */

while (GetMessage (&messages, NULL, 0, 0))
{
/* Translate virtual-key messages into character messages
*/
TranslateMessage(&messages);
/* Send message to WindowProcedure */
DispatchMessage(&messages);
}

La funzione GetMessage preleva di volta in volta dalla coda dei
messaggi il primo pronto per essere processato e restituisce un
valore diverso da zero per ogni messaggio catturato, eccezion fatta
per il messaggio identificato dalla costante WM_QUIT, corrispondente al
valore zero. Ciò accade in corrispondenza della richiesta di chiusura
dell’applicazione, il che causa dunque l’uscita dal loop.
La funzione TranslateMessage è relativa all’input generato dalla tastiera.
All’interno del loop l’istruzione cardine è invece la chiamata
DispatchMessage. Tale funzione forza Windows indirettamente a
chiamare la funzione WindowProcedure, una volta per ogni messaggio. Il
nome di tale funzione lo abbiamo indicato nella struttura di tipo
WNDCLASSEX con la riga di codice:

wincl.lpfnWndProc = WindowProcedure;
called by windows */

/* This function is

Rispondiamo ai messaggi
Come detto, la funzione WindowProcedure serve a gestire la risposta ai
messaggi inviati verso la nostra applicazione. Di seguito, per
comodità, vi riporto nuovamente il codice dell’implementazione di
tale funzione:
/* This function is called by the Windows function
DispatchMessage() */
LRESULT CALLBACK WindowProcedure (HWND hwnd, UINT message,
WPARAM wParam, LPARAM lParam)
{
switch (message)
/* handle the messages */
{
case WM_DESTROY:
PostQuitMessage (0);
/* send a WM_QUIT to the
message queue */
break;
default:
/* for messages that we
don't deal with */
return DefWindowProc (hwnd, message, wParam,
lParam);
}
return 0;
}

Analizziamola dunque a partire dalla sua firma. CALLBACK è la calling
convention della funzione. LRESULT è un valore di tipo intero che
dipende dal tipo di messaggio gestito, in quanto contiene la risposta
della nostra applicazione al messaggio stesso.
Per quanto riguarda i parametri in input, hwnd è banalmente l’handle
della finestra mentre message è il codice del messaggio, ad esempio
WM_DESTROY. Come si può vedere dallo switch interno alla funzione è
proprio il valore contenuto in message a gestire e selezionare i vari case
e quindi la risposta della nostra applicazione agli eventi esterni.
Infine, wParam e lParam contengono dati ulteriori relativi allo specifico
messaggio.
Per il resto, come già anticipato, la funzione non fa altro che
selezionare il case specifico relativo al tipo di messaggio che

vogliamo catturare, ignorando al contempo tutti quelli per i quali non
abbiamo intenzione di rispondere. Infatti, nel caso default ci limitiamo
a passare i parametri del messaggio alla funzione DefWindowProc che
assicura che il messaggio venga comunque filtrato dall’applicazione
anche se da essa ignorato.

Messaggi complessi
Quello che abbiamo visto finora è sicuramente indicativo della
complessità insita nella gestione di un’applicazione grafica. Ma è
intuitivo che si tratta solo di un contesto introduttivo. L’applicazione
che abbiamo realizzato è sicuramente completa, nel senso che è
possibile compilarla ed eseguirla, ma ovviamente non realizza nulla
che non sia la banale visualizzazione di una finestra vuota con tanto
di titolo, bottoni per il ridimensionamento e per la sua chiusura, ma
null’altro di interessante.
Proviamo allora a vedere come migliorare il nostro programma
consentendo, ad esempio, di catturare un clic del mouse
sull’applicazione stessa.
I codici dei messaggi per gestire rispettivamente il clic del mouse
sinistro e destro sono WM_LBUTTONDOWN e WM_RBUTTONDOWN. Per intercettare
dunque tali eventi è sufficiente aggiungere nello switch che controlla i
messaggi in arrivo il seguente codice:
…
case WM_LBUTTONDOWN:
MessageBox(hwnd,"Clic sinistro","Clic", MB_OK);
break;
case WM_RBUTTONDOWN:
MessageBox(hwnd,"Clic destro","Clic", MB_OK);
break;
…

Il codice è intuitivo. La novità riguarda la funzione MessageBox che
utilizziamo per visualizzare un messaggio di testo con l’indicazione
di quale bottone del mouse, destro o sinistro, abbiamo premuto.
La funzione in questione prende in input quattro parametri, il primo
dei quali è l’handle della finestra che ha generato il messaggio. Il
secondo rappresenta il contenuto del messaggio, mentre il terzo
indica un titolo da visualizzare su tale finestra di dialogo. L’ultimo
argomento, che nel nostro caso è MB_OK, è una costante intera che
specifica il tipo di bottoni da visualizzare nel dialogo. Quella utilizzata
per l’esempio mostra un semplice bottone di chiusura di tipo “OK”

che, d’altra parte, è proprio il comportamento predefinito del dialogo.

Figura 27.4 – La visualizzazione del messaggio di testo in seguito
alla pressione del tasto sinistro del mouse.
Volendo sarebbe abbastanza semplice sfruttare anche le
informazioni passate attraverso i parametri di tipo WPARAM e LPARAM
passati alla WindowProcedure, che in questo caso contengono le
coordinate x e y del punto in cui si è fatto clic con il mouse.

Le risorse indispensabili per
un’applicazione
Continuiamo nel processo di perfezionamento della nostra
applicazione per renderla maggiormente completa e professionale.
Un programma che si rispetti deve avere indispensabilmente un
insieme di elementi quali icone, voci di menu e dialoghi. Se le icone
sono un semplice arricchimento per l’applicazione, rendendola
maggiormente intuitiva e gradevole all’aspetto, elementi come menu
e dialoghi sono indispensabili per l’operatività dell’applicazione
stessa. Tali elementi prendono nel loro insieme, icone e immagini
comprese, il nome di risorse.
L’inserimento di specifiche risorse all’interno di un’applicazione è
un’operazione che può essere spesso svolta con l’ausilio di vari
automatismi messi a disposizione dall’ambiente in uso. Ogni
ambiente prevede dei propri strumenti. Nel caso in esame vi
presento un approccio di “basso livello” relativo alla nostra
applicazione Windows, per la quale costruiremo a mano gli elementi
necessari a definire le risorse per l’applicazione. Ciò renderà più
chiara l’anatomia dell’applicazione stessa.
Come prima operazione è necessario creare uno specifico file di
testo avente estensione .rc. Chiamiamo per semplicità il file con il
nome resource.rc. Tale file è anche noto con il nome di resource
script. Per crearlo all’interno di Code::Blocks possiamo agire sulla
voce di menu File - New - File e scegliere la voce Empty File
(ovvero file vuoto). Selezioniamo il percorso della nostra
applicazione e scriviamo il nome del file in questione. L’ambiente
riconoscerà in automatico l’estensione e visualizzerà di
conseguenza un nuovo ramo all’interno della scheda Projects del
pannello Management con il nome Resources a contenere il file .rc.

Figura 27.5 – Il pannello con la scheda Projects dopo l’inserimento
del file necessario per gestire le risorse.
Il file .rc serve dunque per definire le risorse da utilizzarsi all’interno
dell’applicazione.

Inseriamo un’icona
Supponiamo come prima cosa di voler dotare la nostra applicazione
di una specifica icona. Inseriremo quindi nel file in questione la
seguente riga:
1

ICON

"app.ico"

Il numero 1 è un identificativo univoco per la risorsa. La parola chiave
ICON indica che la risorsa in oggetto è un’icona, mentre il nome di
file app.ico rappresenta il file fisico contenente l’icona che vogliamo
assegnare alla nostra applicazione. Tale file verrà ricercato nella
cartella della nostra applicazione e, se provate a compilare senza
averlo preventivamente inserito, vi vedrete rispondere dall’ambiente
con un errore del tipo:
can't open icon file 'app.ico': No such file or directory

Fate attenzione al fatto che il file in questione deve essere di tipo ico
e non sono ammessi file di tipo differente, come ad esempio gif
oppure jpg. Provate a scrivere, in un qualsiasi motore di ricerca,
qualcosa del tipo “icone gratis” e avrete solo l’imbarazzo della scelta

per procurarvi un’icona per la vostra applicazione.
Una volta inserita la vostra icona con il nome app.ico all’interno della
cartella dell’applicazione e compilato il tutto, scoprirete che
all’apparenza nulla è successo. In realtà se andrete a visionare con
Esplora risorse il contenuto della cartella in cui risiede l’eseguibile
compilato (la sottocartella bin\Debug della vostra applicazione)
scoprirete che al file eseguibile è ora associata l’icona in questione.
Ciò è dovuto al fatto che Esplora risorse, per visualizzare
graficamente la voce del file, cerca all’interno dell’eseguibile l’icona
con l’identificativo più basso. Nel nostro caso, tale identificativo,
peraltro unico, è appunto 1.
Vediamo ora come assegnare l’icona all’applicazione in modo che
essa venga visualizzata sulla parte sinistra della barra del titolo. Per
farlo dobbiamo individuare le righe di codice seguenti presenti
all’interno della funzione WinMain:
wincl.hIcon = LoadIcon (NULL, IDI_APPLICATION);
wincl.hIconSm = LoadIcon (NULL, IDI_APPLICATION);

e modificarle come segue:
wincl.hIcon = LoadIcon (hThisInstance, MAKEINTRESOURCE(1));
wincl.hIconSm = LoadIcon (hThisInstance, MAKEINTRESOURCE(1));

La modifica riguarda innanzitutto, come evidente, l’inserimento del
valore hThisInstance come primo argomento della funzione LoadIcon.
Ciò per associare l’icona all’istanza dell’applicazione corrente. Come
secondo argomento andiamo a inserire l’identificativo, con valore 1,
della nostra icona così come dichiarato nel file di risorsa. Tale
identificativo deve passare attraverso il lavoro della macro
MAKEINTRESOURCE. Questa provvede a convertire il valore intero utilizzato
come identificativo della risorsa icona nel tipo compatibile con la
funzione di gestione della risorsa stessa.

Un menu per l’applicazione
Una qualsiasi applicazione che voglia interagire con l’utente in
maniera intuitiva deve di norma possedere un proprio menu. Anche
tale elemento viene facilmente gestito all’interno del file di risorse.

Supponiamo di voler dotare la nostra applicazione di un menu
formato da due voci principali, File e Aiuto, che rappresentano una
dotazione standard per ogni programma. Assegneremo a ognuna
delle due voci principali una serie di sottovoci. Il codice potrebbe
essere il seguente:
100 MENU
BEGIN
POPUP "File"
BEGIN
MENUITEM "Nuovo", 101
MENUITEM "Apri", 102
MENUITEM "Salva", 103
MENUITEM SEPARATOR
MENUITEM "Esci", 104
END
POPUP "Aiuto"
BEGIN
MENUITEM "Informazioni su...", 105
END
END

Con la prima riga indichiamo la volontà di gestire un menu al quale
diamo il numero identificativo 100. I gruppi di elementi vengono
racchiusi tramite blocchi delimitati dalle parole chiave BEGIN ed END che
rimandano per certi aspetti alla sintassi del linguaggio Pascal. La
parola POPUP identifica una voce principale, mentre MENUITEM una
sottovoce. Ogni elemento deve essere dotato di un suo identificativo
numerico. Nel mio esempio sono partito da 100 incrementando di
una unità per ogni elemento del menu. Potrebbe tuttavia essere una
scelta saggia quella di inserire i numeri lasciando dei “vuoti” del tipo
100, 102, 104 oppure addirittura 100, 105, 110. Ciò per permettere,
in caso di ulteriori aggiunte di voci di menu, da effettuarsi in un
secondo tempo, l’inserimento delle nuove voci mantenendo
comunque un certo ordine negli elementi.
A questo punto non ci resta che comunicare all’applicazione la
nostra volontà di inserire il menu appena creato. Modifichiamo allora
la linea di codice:
wincl.lpszMenuName = NULL;

/* No menu */

in:
wincl.lpszMenuName =

MAKEINTRESOURCE(100);

Il risultato è visibile nella Figura 27.6.

Figura 27.6 – L’applicazione in fase di realizzazione completa di
menu.

Un codice robusto
Si può facilmente asserire che per ogni applicazione esistono due
livelli distinti: un primo livello visibile all’utente e un secondo a lui
invisibile. Il primo livello, quello visibile, è dato dall’interfaccia
dell’applicazione e da come questa reagisce alle richieste dell’utente
stesso. Quando l’utente richiede un comando cliccando in qualche
punto dell’applicazione, oppure digitando qualcosa sulla tastiera,
vuole semplicemente che l’applicazione risponda in maniera
coerente alle proprie aspettative. Come state scoprendo in questo
nostro viaggio, fare in modo che ciò avvenga è sicuramente
abbastanza complesso e tutto ciò riguarda proprio il secondo livello
relativo al codice sorgente e quindi a noi programmatori.
All’utente, ovviamente, non interessa sapere come determinate
azioni vengano realizzate dall’applicazione ma semplicemente che
ciò avvenga. Tuttavia, per noi sviluppatori questo secondo livello è di

fondamentale importanza. Sebbene un codice scritto male possa
essere comunque efficace producendo gli effetti desiderati, il
problema riguarda direttamente, d’altra parte, innanzitutto
l’efficienza, ovvero quante risorse si impiegano per ottenere un dato
risultato. Tali risorse riguardano aspetti relativi, ad esempio, a un
utilizzo accorto della memoria, così come ai tempi di esecuzione che
devono in ogni caso essere ragionevoli.
Ma esiste un altro aspetto di capitale importanza che riguarda la
manutenibilità e scalabilità del software. Con tali termini ci si riferisce
a quanto sia costoso mettere le mani sul software per aggiungere a
esso caratteristiche non previste in una prima fase di realizzazione,
così come per correggere eventuali errori di programmazioni in
tempi contenuti.
Queste considerazioni fanno da giusta premessa a una modifica che
possiamo apportare alla nostra applicazione in merito alla gestione
delle risorse. Tale modifica riguarda il solo secondo livello, quello del
codice, e non cambia di una virgola l’aspetto esterno e le funzionalità
dell’applicazione, in coerenza con quanto detto a proposito dei due
differenti livelli di ogni applicazione.
Ciò che ci accingiamo a modificare riguarda gli identificatori numerici
delle nostre risorse. Come visto, ogni risorsa ha assegnato un suo
identificativo, brevemente chiamato ID, di tipo numerico. Ovviamente
per noi umani è più facile gestire dei nomi piuttosto che dei numeri.
Quello che faremo è di associare a ogni numero una costante con
un nome che sia in qualche modo esplicativo della funzione che
l’elemento in questione deve svolgere.
Per rendere più “pulita” l’intera operazione inseriamo, con le
modalità già viste per il file di risorsa, un nuovo file che denominiamo
resource.h che conterrà le dichiarazioni delle costanti numeriche.
Dopo il suo inserimento nel progetto, Code::Blocks visualizzerà un
nuovo ramo di nome Headers all’interno della scheda Projects in
relazione al pannello Management. Vediamo allora come potrebbe
essere valorizzato tale file.
#define IDI_APP_ICONA
#define IDM_MAINMENU
#define IDM_FILE_NUOVO
#define IDM_FILE_APRI

1
100
101
102

#define IDM_FILE_SALVA
#define IDM_FILE_ESCI
#define IDM_AIUTO_INFO

103
104
105

Abbiamo semplicemente definito una serie di costanti numeriche.
Fate attenzione alla scelta dei nomi. Il prefisso IDI sta per
IDentificativo di Icona mentre IDM sta per IDentificativo di Menu. Gli
identificativi sono poi costruiti aggiungendo un trattino basso seguito
da un nome del tipo FILE_NUOVO, che serve a far identificare con
semplicità nella lettura l’elemento in esame.
Con il tempo e l’esperienza forse scoprirete che è preferibile in
questi casi l’uso della lingua inglese. A titolo di esempio potremmo
pensare di chiamare la costante IDM_FILE_NUOVO con il nome IDM_FILE_NEW
oppure IDM_FILE_APRI con IDM_FILE_OPEN. L’inglese è per vari aspetti
maggiormente adatto per tali scopi grazie alla sua natura essenziale.
In questo contesto lascio i riferimenti in italiano per semplicità e
immediatezza di spiegazione.
Dobbiamo ora modificare il file resource.rc per rendere visibile al
suo interno l’elenco di voci appena creato. Per farlo usiamo la
direttiva:
#include "resource.h"

che di fatto collega i due file. Sempre nel file resource.rc dobbiamo
sostituire gli ID numerici con le costanti appena realizzate ottenendo
il seguente contenuto:
#include "resource.h"
IDI_APP_ICONA
ICON
"app.ico"
IDM_MAINMENU MENU
BEGIN
POPUP "File"
BEGIN
MENUITEM "Nuovo", IDM_FILE_NUOVO
MENUITEM "Apri", IDM_FILE_APRI
MENUITEM "Salva", IDM_FILE_SALVA
MENUITEM SEPARATOR
MENUITEM "Esci", IDM_FILE_ESCI
END
POPUP "Aiuto"
BEGIN
MENUITEM "Informazioni su...", IDM_AIUTO_INFO

END
END

Ricompilando ed eseguendo l’applicazione, come già anticipato, non
vedremo modifiche apparenti. Per completare il tutto, rendendo
coerente l’operazione di refactoring, ovvero la ristrutturazione e
ottimizzazione interna del codice senza modificare le funzionalità
esterne, non ci resta che sostituire gli ID numerici utilizzati nel file di
codice principale con le costanti. Per farlo dobbiamo innanzitutto
collegare il file di risorse tramite la seguente direttiva:
#include "resource.h"

Successivamente non ci resta che modificare le righe di codice
seguenti:
wincl.hIcon = LoadIcon (hThisInstance,
MAKEINTRESOURCE(IDI_APP_ICONA));
wincl.hIconSm = LoadIcon (hThisInstance,
MAKEINTRESOURCE(IDI_APP_ICONA));
wincl.lpszMenuName = MAKEINTRESOURCE(IDM_MAINMENU);

Una nuova compilazione e relativa esecuzione confermerà che nulla
è cambiato all’esterno dell’applicazione, mentre sappiamo bene che
il suo interno è ora sicuramente più facilmente modificabile.

28
Il C, Arduino e l’Internet delle
cose
È l’arte suprema dell’insegnante,
risvegliare la gioia della creatività e
della conoscenza.
Albert Einstein
In alcune persone è presente una spinta inarrestabile che costringe
a modificare gli oggetti più diversi per ottenere da essi
comportamenti differenti da quelli originariamente previsti. Alcuni
definiscono questo sentimento come spirito hacker e ultimamente
questi personaggi vengono definiti makers, nel senso, evidente, di
coloro che “fanno”. Anche se l’hacking si può esprimere in contesti
estremamente diversificati, di norma, gli interessi degli hacker sono
prettamente di tipo tecnologico. Prima dell’avvento dell’informatica di
massa, verificatosi intorno agli inizi degli anni 80 con la diffusione dei
primi home computer, l’hacking era soprattutto elettronica.
L’introduzione sul mercato di questi piccoli computer, quali i mitici
Commodore VIC 20, Commodore 64, Sinclair ZX Spectrum o
Sinclair QL, solo per citare alcuni dei tantissimi prodotti

commercializzati in quegli anni, consentì ai tanti affamati di
tecnologia e futuro di esprimere la loro creatività attraverso l’uso e la
produzione di software. A quel punto, in un certo senso, le strade
degli “hacker elettronici” e quelle degli “hacker informatici” iniziarono
a dividersi. Fare software diventava sempre più impegnativo, così
come realizzare circuiti stampati e assemblare componenti elettronici
era sempre più materia che richiedeva una curva di apprendimento
elevata. Per anni le cose sono proseguite in questo modo creando
nuove professioni, in particolar modo nel contesto informatico, in cui
molti “smanettoni” per passione hanno poi trovato occupazioni
lavorative come programmatori o sistemisti. Di fondo, comunque, c’è
da sottolineare che spessissimo la vera passione informatica rimane
interesse generale per la tecnologia in senso lato, tanto da arrivare
ad abbracciare, sicuramente, tanto la scienza quanto la
fantascienza. Negli ultimi anni una nuova rivoluzione tecnologica sta
riunendo finalmente le anime degli elettronici e degli informatici
intorno a un nuovo Sacro Graal, le schede per microcontroller.

Figura 28.1 – Microcontroller.
Un microcontroller non è altro che un piccolo computer in un singolo
chip. In un unico circuito integrato sono così presenti il
microprocessore, la memoria e dispositivi di input-output.
Apposite schede ospitano quindi il microcontroller e lo connettono al
mondo esterno attraverso varie tipologie di porte. Le porte presenti
su tali schede consentono di collegare tutta una serie di sensori per
misurare caratteristiche fisiche dell’ambiente circostante come, a

puro titolo di esempio, temperatura o luminosità. Il microcontroller
può quindi essere programmato per eseguire specifiche operazioni
al modificarsi di queste proprietà fisiche. Il salto di qualità che si
realizza con queste schede è la possibilità di tradurre queste
situazioni in modifiche fisiche vere e proprie, che coinvolgono il
nostro mondo reale. Ad esempio, è possibile far scattare dei relè per
accendere delle luci o per azionare motori o qualsiasi altro
dispositivo elettronico collegato. Tali meccanismi prendono il nome di
attuatori. Tutto ciò rientra in quello che viene definito come physical
computing. Quando poi questi dispositivi riescono a interagire e a
comunicare tra loro, si inizia a parlare di Internet delle cose. Nasce
dunque una nuova rete, nota in lingua inglese con l’acronimo di IoT,
ovvero Internet of Things, in cui i vari dispositivi, sia fisici che
virtuali, acquisiscono una sorta di consapevolezza del mondo reale
comunicando informazioni tra di essi.

Arduino
Tra le varie schede a microcontroller oggi presenti sul mercato, ne
esiste una che di sicuro ha realizzato la svolta decisiva verso una
nuova unificazione di informatica ed elettronica: il suo nome, ormai
famoso, è Arduino e orgogliosamente possiamo dire essere un
prodotto italiano.

Figura 28.2 – La scheda Arduino UNO.
La scheda Arduino nasce a Ivrea, in Piemonte, con lo scopo di
facilitare l’insegnamento della realizzazione di prototipi di nuovi
oggetti anche a persone con scarse conoscenze di elettronica e di
programmazione. La cosa forse più interessante di Arduino è la
filosofia di utilizzo promossa dal suo principale progettista, Massimo
Banzi. Infatti, ciò che si sollecita è lo sforzo creativo concreto nel
realizzare nuovi oggetti del mondo reale con i quali poter interagire.
Lo spirito creativo è talmente forte e presente nel contesto di Arduino
tanto che Massimo Banzi, nella sua guida ufficiale alla scheda in
questione, scrive: “Prima di cominciare a costruire qualcosa da zero,
vi consiglio di cominciare ad accumulare rifiuti”. Il riferimento è
contestualizzato rispetto a vecchi giocattoli elettronici e ai tanti
dispositivi non più propriamente funzionanti che di norma gettiamo
nella spazzatura. Il riutilizzo creativo di tale componentistica può
quindi dar vita a nuovi e interessanti oggetti. A volte, addirittura, le

nuove creazioni possono nascere da prove quasi casuali di
riorganizzazione delle varie parti, in un approccio noto appunto come
tinkering, che letteralmente significa “armeggiare”.
Il sito di riferimento della scheda Arduino è www.arduino.cc. Esistono
svariate versioni della scheda ma tutte, compreso la variante nota
come Genuino, sono caratterizzate dall’essere inquadrate nel
contesto open hardware e open source, ovvero, tutte le specifiche
sia hardware che software sono liberamente riutilizzabili da chiunque
in quanto vengono distribuiti i sorgenti software e gli schemi
hardware con tutti i dettagli sulla componentistica elettronica
utilizzata.

Le schede Arduino e Genuino, come indicato anche sul
sito del progetto, condividono la stessa componentistica.
Tuttavia, esse vengono distribuite, per motivazioni
NOTA
commerciali e di copyright, con due marchi diversi:
Genuino all’esterno degli USA e Arduino per i soli Stati
Uniti.

Hardware e corrente elettrica
Per poter realizzare degli esempi concreti e sufficientemente
specifici dobbiamo, per forza di cose, riferirci a un determinato
modello di scheda. Prendiamo allora come riferimento il modello
entry level Arduino Uno, considerando, comunque, che i
ragionamenti fatti sono quasi immediatamente trasferibili anche nei
contesti d’uso di modelli differenti. Ciò detto, vediamo la scheda in
maggior dettaglio dal punto di vista hardware, facendo riferimento
alla Figura 28.3.

Figura 28.3 – La scheda Arduino Uno.
La prima cosa che vi invito a osservare è il microcontroller ATmega
(4), ovviamente il cuore della nostra scheda.
La scheda deve necessariamente essere alimentata e, per farlo, è
possibile utilizzare il connettore di alimentazione (7) che può
funzionare con una tensione dai 7 ai 12 volt.

In realtà, in generale, è possibile alimentare la scheda attraverso il
collegamento della porta USB (9). Tale connettore serve, di norma,
per la programmazione della scheda stessa, il che, come vedremo
più avanti, causa l’accensione dei LED TX e RX (8).
In ogni caso, quando Arduino è alimentato si accende uno specifico
LED (3).
Sempre a proposito di LED, va segnalato il fatto che su Arduino ne
esiste uno molto particolare (2) che rappresenta l’unico attuatore
presente sulla scheda stessa. Come già detto, un attuatore è un
dispositivo che viene pilotato da una scheda come Arduino. Di
norma gli attuatori sono meccanismi più complessi che vengono
collegati esternamente alla scheda. Tuttavia, questo semplice LED,
che corrisponde al pin numero 13, è utile in fase di debugging. Con
esso svilupperemo più avanti un classico esempio di accensione
intermittente per mettere insieme i vari concetti esposti. Il termine
pin, in elettronica, si riferisce a quello che in italiano è anche
chiamato piedino e sta a indicare un terminale metallico di un certo
dispositivo elettronico.
Sulla scheda che stiamo analizzando esistono diversi pin con i quali
Arduino comunica con il mondo esterno. Ad esempio, possiamo
individuare quattordici pin digitali (1), numerati da 0 a 13, che
possono essere usati tanto per l’input quanto per l’output. Abbiamo
poi cinque pin analogici (5) utilizzabili come input.
Notiamo ancora una sezione di pin dedicata alla tensione in uscita
(6) da utilizzarsi per alimentare circuiti esterni.
Infine, possiamo facilmente individuare un tasto di reset (10) che
consente il riavvio della scheda.

La programmazione software di
Arduino
Il microcontroller presente sulla scheda Arduino è di norma un
Atmel. Nel caso specifico di Arduino UNO è un ATmega.
Ovviamente, il microcontroller ha un suo linguaggio macchina che,
tuttavia, viene bypassato dall’uso di appositi linguaggi di più alto
livello. Dal sito di riferimento di Arduino, è possibile scaricare uno
spartano ma pratico IDE (Integrated Development Environment)
disponibile sia per Windows (Figura 28.4) che per OS X e Linux.
Con tale strumento è possibile scrivere il codice in maniera semplice
e intuitiva e successivamente effettuare l’upload di tali istruzioni
direttamente sulla scheda attraverso un semplice cavo USB. L’IDE di
Arduino, realizzato in linguaggio Java, è multipiattaforma. Esso
deriva da un altro IDE, realizzato per il linguaggio di
programmazione processing, il cui sito di riferimento è
processing.org. Infatti, dal progetto processing è nato un ulteriore
contesto di sviluppo noto come wiring, che ha aggiunto al progetto
originario la possibilità di utilizzare i linguaggi C e C++. In definitiva,
l’IDE di Arduino non fa altro che fornire il supporto per la libreria
wiring consentendo il controllo della scheda tramite i linguaggi, per
noi familiari, C e C++.

Figura 28.4 – L’IDE di Arduino per Windows.
Una volta scaricato e installato il software Arduino, al lancio dell’IDE
verrà mostrato una videata simile a quella mostrata in Figura 28.4.
L’IDE consente di gestire differenti modelli di scheda. Per
selezionare quello in uso sul proprio sistema è sufficiente fare
riferimento alla voce di menu Strumenti – Scheda, come mostrato
nella Figura 28.5.

Figura 28.5 – La selezione del tipo di scheda nell’IDE di Arduino.
I programmi scritti all’interno dell’IDE prendono il nome di sketch. La
struttura di default dello sketch vuoto è la seguente:
void setup() {
// put your setup code here, to run once:
}
void loop() {
// put your main code here, to run repeatedly:
}

Nel codice proposto si riconoscono immediatamente due funzioni
predefinite, che devono essere sempre presenti: la funzione setup e
la funzione loop. Lo sketch di esempio, proposto dall’IDE di Arduino,
contiene anche un commento, in stile C++ e in lingua inglese, per le
due funzioni. Si intuisce immediatamente che la funzione setup deve
contenere le istruzioni che devono essere eseguite una sola volta
all’avvio della scheda. Si tratta dunque di una funzione di
inizializzazione dell’ambiente. Una volta eseguito il contenuto della
funzione setup, Arduino passerà a eseguire le istruzioni presenti nella
funzione loop. Tale funzione è una sorta di while(TRUE), ovvero un ciclo
infinito. Infatti, Arduino prevede che le istruzioni presenti all’interno
della scheda vengano eseguite indefinitamente dal momento in cui si

alimenta la scheda fino al momento in cui la scheda viene
disalimentata. Ovviamente, al riavvio della scheda verrà eseguito
l’ultimo sketch in essa salvato.

Un “salve, mondo” per Arduino
Anche Arduino non sfugge alla consuetudine del “Salve, mondo”,
ovvero alla realizzazione di un semplice programma per la stampa
delle classiche parole di saluto già viste nella presentazione del C e
del C++. Tuttavia, data la particolarità del dispositivo, la scheda
microcontroller in questione lo fa a modo suo. Infatti, nel caso di
Arduino, il primo esempio consiste in uno sketch che fa illuminare a
intermittenza un LED che, per ulteriore semplificazione, è il LED che
è presente sulla scheda stessa. Tale LED, come già anticipato,
corrisponde al pin numero 13. Vediamo allora come procedere.
Per prima cosa colleghiamo la scheda Arduino a una porta USB del
nostro PC, potendo constatare l’accensione del LED di
alimentazione. Lanciamo dunque l’IDE di Arduino e accertiamoci che
nella voce di menu Strumenti - Porta sia selezionata la specifica
porta di comunicazione e che nella voce Strumenti - Scheda si
faccia riferimento a “Arduino/Genuino Uno”. Inseriamo, quindi, il
seguente codice:
/*
Accende e spegne ripetutamente il LED 13
*/
// la funzione setup viene eseguita una sola volta quando si
alimenta la scheda
// oppure quando si preme il tasto reset sulla scheda
void setup()
{
// imposta il pin digitale numero 13 come output
pinMode(13, OUTPUT);
}
// ciclo infinito
void loop()
{
digitalWrite(13, HIGH);
// accende il LED
delay(3000);
// attende per 3 secondi
digitalWrite(13, LOW);
// spegne il LED
delay(3000);
// attende per 3 secondi
}

Credo sia di sicuro rassicurante una veloce occhiata al codice, in
quanto in esso riconosciamo la consueta sintassi del C. Ciò è
evidente sin dal commento iniziale, che rappresenta una breve
descrizione dello scopo dello sketch. Subito dopo, in relazione al
commento relativo alla funzione setup, riconosciamo il commento su
singola linea tipico del C++. In tale funzione, che come sappiamo
verrà eseguita una e una sola volta nel momento in cui alimentiamo
la scheda oppure la riavviamo con il tasto reset presente sulla
scheda stessa, utilizziamo l’istruzione pinMode(). Tale istruzione
prende in input due parametri: il primo è il pin sul quale agisce
l’istruzione e il secondo, nel nostro caso con valore OUTPUT, indica che
tale pin deve essere gestito appunto per l’output. L’ovvia alternativa
per questo secondo parametro potrebbe essere il valore INPUT,
stabilendo, quindi, che il pin in questione dovrebbe essere gestito
per la lettura di valori digitali.
Passiamo, allora, all’analisi del contenuto della funzione loop. In essa
notiamo innanzitutto l’istruzione:
digitalWrite(13, HIGH);

Tale funzione imposta per il pin 13, indicato come primo argomento
della funzione, il valore HIGH, passato come secondo argomento.
Trattandosi di un pin digitale, che tra le altre cose abbiamo impostato
essere di output con l’istruzione pinMode(13, OUTPUT);, l’effetto
dell’istruzione digitalWrite sarà quello di portare il valore di 5 volt sul
pin indicato, causando l’accensione del LED sulla scheda che è
appunto collegato a tale pin.
L’istruzione successiva, delay(3000);, come facilmente intuibile,
interrompe l’esecuzione dello sketch per il tempo indicato nel suo
argomento, ovvero per 3000 millisecondi, corrispondenti a 3 secondi.
A questo punto, il funzionamento dello sketch dovrebbe essere
chiaro. Infatti, la successiva istruzione digitalWrite(13, LOW); non farà
altro che impostare a LOW, quindi azzerare, la tensione sul LED 13.
Infine, in chiusura della funzione loop, troviamo nuovamente la
funzione delay(3000); che fermerà nuovamente per 3 secondi lo
sketch. Allo scadere di tale tempo, l’esecuzione riprenderà dalla
prima istruzione della funzione loop, iterando indefinitamente le
azioni appena discusse.

Il risultato finale dello sketch sarà, così come ci aspettiamo,
l’accensione e lo spegnimento ripetuto del LED presente sulla
scheda, a intervalli di 3 secondi. Per avere conferma pratica di tale
comportamento non ci resta che compilare lo sketch in questione e
trasferirlo sulla nostra scheda. Tuttavia, prima di procedere conviene
salvare il nostro sorgente in un’apposita cartella sul nostro PC. Per
farlo usiamo, banalmente, la voce di menu File - Salva con nome. Il
risultato di tale comando sarà quello di creare una nuova cartella con
il nome che specificheremo, all’interno della quale sarà presente un
file, avente lo stesso nome appena indicato, con estensione .ino che
conterrà il sorgente dello sketch. A questo punto possiamo verificare
la correttezza delle istruzioni inserite nello sketch utilizzando il
bottone Verifica presente nella barra degli strumenti dell’IDE di
Arduino, così come mostrato nella Figura 28.6.

Figura 28.6 – Il bottone Verifica per il controllo e la compilazione
dello sketch.
Successivamente, se la verifica è andata a buon fine, possiamo
finalmente trasferire il nostro compilato sulla scheda. Per farlo
possiamo agire sul bottone Carica, così come mostrato nella Figura
28.7.

Figura 28.7 – Il bottone Carica per l’upload dello sketch nella
scheda Arduino.

Costanti e variabili
Una volta compreso il contesto d’uso generale della scheda Arduino,
può essere utile fare qualche piccola considerazione relativa allo
stile consigliato da utilizzarsi nella gestione della programmazione
per l’ambiente in questione, verificando al contempo le strettissime
correlazioni con il linguaggio C così come lo abbiamo visto nei
capitoli precedenti.
Una questione preliminare, di sicuro interesse, riguarda la gestione
dei pin e la loro numerazione. Come abbiamo visto, nelle istruzioni
pinMode e digitalWrite dell’esempio precedente abbiamo usato il
numero del pin, nel contesto in esame il 13, per identificare lo
specifico pin. Ebbene, può essere utile dichiarare tale valore come
costante, indicando un nome consistente rispetto al suo significato,
all’esterno delle funzioni setup e loop immediatamente dopo il
commento iniziale, come mostrato di seguito.
/*
Accende e spegne ripetutamente il LED 13
*/
// Il LED è collegato sul pin 13
const int LED = 13;
void setup()
{
// imposta il pin digitale come output
pinMode(LED, OUTPUT);
}
void loop()
{
digitalWrite(LED, HIGH); // accende il LED
delay(3000);
// attende per 3 secondi
digitalWrite(LED, LOW);
// spegne il LED
delay(3000);
// attende per 3 secondi
}

Ovviamente, avremmo potuto dichiarare la costante anche con la
direttiva define scrivendo:
#define LED 13

Tuttavia è interessante notare come gli autori di Arduino sconsiglino
questa pratica. In rete si trovano lunghissime discussioni in merito
all’opportunità della scelta tra le due modalità. Vi lascio quindi la
tematica come approfondimento.
In alcuni casi potrebbe essere necessario utilizzare, al posto di una
costante, una o più variabili. Le regole di visibilità di tali variabili sono
le stesse già viste nei capitoli precedenti. Una variabile dichiarata
all’esterno delle funzioni assume visibilità globale, mentre sarà
locale nel momento in cui viene dichiarata all’interno di una qualsiasi
funzione. Ovviamente, a dimostrazione di quanto appena detto, il
seguente codice genererà un errore del tipo: "exit status 1 'LED' was
not declared in this scope".
/*
Visibilità variabili
*/
void setup()
{
int LED = 13;
pinMode(LED, OUTPUT);
}
void loop()
{
digitalWrite(LED, HIGH); //attenzione: qui si genera un
errore
}

Infatti, la variabile LED, dichiarata nella funzione setup, sarà locale a
tale pezzo di codice e di conseguenza invisibile alla funzione loop.

Comunicazione seriale
La scheda Arduino deve, per forza di cose, comunicare con il mondo
esterno ricevendo e inviando segnali elettrici. Uno dei modi possibili
per realizzare tale scambio di dati è rappresentato dalla
comunicazione seriale. A tale scopo è disponibile l’oggetto Serial,
che consente di far comunicare la scheda Arduino attraverso i pin
digitali 0 e 1, rispettivamente per la ricezione (RX) e la trasmissione
(TX). È intuitivo, e quantomeno ovvio, che se usiamo i pin 0 e 1 per
la comunicazione seriale non potremo usarli al contempo come input
o output digitale. Attraverso l’oggetto Serial è inoltre possibile
sfruttare come canale di comunicazione la connessione USB tra la
scheda e il nostro PC. A tal fine, l’IDE di Arduino contiene uno
specifico strumento, noto come serial monitor, che consente
appunto di far comunicare agevolmente il nostro PC con la scheda.
Per lanciare tale strumento è sufficiente cliccare sull’apposita icona,
presente in alto a destra nell’IDE, così come mostrato nella Figura
28.8.

Figura 28.8 – Il bottone che consente l’apertura del serial monitor.
Nella Figura 28.9, invece, è mostrata la finestra del serial monitor.
Ovviamente, nel caso in cui la scheda non fosse collegata al PC
attraverso una porta USB verrebbe restituito un messaggio di errore.

Figura 28.9 – L’interfaccia del serial monitor.
Per verificare nella pratica le funzionalità di collegamento seriale,
scriviamo uno sketch che consenta di accendere e spegnere il LED
presente sulla scheda attraverso un comando inviato tramite il nostro
PC con il serial monitor.
La prima operazione da realizzare è quella di impostare la velocità di
collegamento. Per farlo scriveremo, nella funzione setup, la seguente
istruzione:
Serial.begin(9600);

avendo indicato, come velocità, 9600 bit al secondo (bps),
sfruttando il metodo begin di un oggetto di nome Serial.

NOTA

Nel caso di Arduino si possono considerare i bit al secondo e i baud come
sinonimi. Ciò è dovuto al fatto che nelle trasmissioni seriali con due soli
livelli di segnale (binari), i bit al secondo corrispondono al numero di simboli
trasmessi in un secondo (quantità nota appunto con il termine baud).

Successivamente, può essere utile visualizzare nel serial monitor
una stringa che indichi all’utente come operare. Utilizzando il metodo
println dell’oggetto Serial, possiamo scrivere, ad esempio:
Serial.println("Accensione e spegnimento LED: 1 per accendere,
0 per spegnere");

dove println non è altro che una printf con l’aggiunta di un ritorno a

capo. Segnaliamo, dunque, che l’accensione del LED avverrà con la
digitazione del simbolo 1, mentre con il simbolo 0 spegneremo il
nostro LED.
Dopo aver compreso le specifiche previste per il nostro sketch,
possiamo analizzare il codice completo in modo da comprendere i
singoli dettagli.
/*
Comunicazione seriale con Arduino
*/
const int LED = 13;
void setup()
{
pinMode(LED, OUTPUT);
Serial.begin(9600);
Serial.println("Accensione e spegnimento LED: 1 per
accendere, 0 per spegnere");
}
void loop()
{
if (Serial.available())
{
char ch = Serial.read();
if (ch == '0')
{
Serial.println("LED spento!");
digitalWrite(LED, LOW);
// spegne il LED
}
else if (ch == '1')
{
Serial.println("LED acceso!");
digitalWrite(LED, HIGH);
// accende il LED
}
else
{
Serial.println("ATTENZIONE: comando non valido!");
}
}
}

La funzione setup dovrebbe essere quindi chiara. Impostiamo come
prima cosa con pinMode il LED 13 come output e successivamente
richiamiamo i metodi begin e println dell’oggetto Serial così come

appena descritto.
Passiamo dunque ad analizzare il cuore dello sketch, organizzato
nella funzione loop. Come prima cosa verifichiamo, attraverso il
metodo available dell’oggetto Serial, se abbiamo ricevuto dei caratteri
scrivendo:
if (Serial.available())
{
//
}

Infatti, available restituisce il numero di byte, e quindi di caratteri, già
ricevuti sulla seriale e presenti in uno specifico buffer di dimensione
64 byte. All’interno del’if, quindi nel caso in cui abbiamo ricevuto
almeno un carattere, leggiamo con Serial.read il primo byte presente
nel buffer e lo associamo alla variabile di tipo carattere che
chiamiamo ch. Il codice successivo dovrebbe essere del tutto
intuitivo. Verifichiamo se il carattere è uguale a 0 oppure a 1 e ci
comportiamo di conseguenza, accendendo e spegnendo il LED così
come già visto nell’esempio precedente. Infine, nel ramo else
segnaliamo l’eventuale inserimento di un carattere non valido,
ovvero diverso da 0 oppure da 1. Per provare lo sketch non resta
che uploadare il codice sulla scheda, aprire il serial monitor e
provare a inserire i simboli 0 e 1 nell’apposita casella di testo.
Affinché lo sketch funzioni correttamente è necessario impostare nel
serial monitor, attraverso l’apposita lista a cascata, una velocità
coerente con quanto fatto nello sketch stesso, nel nostro caso 9600
bps. Inoltre è importante prestare attenzione all’impostazione del
carattere di fine riga (in inglese line ending), selezionabile
anch’esso con una specifica lista a cascata. Quest’ultima
impostazione indica al serial monitor come comportarsi quando si
conferma un dato da inviare, inserendolo nell’apposita casella di
testo, premendo Invio sulla tastiera o il bottone Invia nel serial
monitor. Nel nostro caso dovremo selezionare la voce “Nessun fine
riga”. Altre opzioni consentono invece di accodare, a quanto inserito
come input, un carattere di a capo automatico (New Line, NL), un
carattere di ritorno carrello (Carriage Retun, CR) oppure entrambi,
così come mostrato nella Figura 28.10.

Figura 28.10 – La selezione delle impostazioni del carattere di fine
riga e della velocità nel serial monitor.

Arduino e la prototipazione
Come già detto, Arduino è lo strumento ideale per sperimentare la
creazione di nuovi oggetti consentendo la costruzione di prototipi in
modo semplice e rapido. A tal fine, ovviamente, non è sufficiente il
solo Arduino e il relativo IDE, in quanto è necessario che Arduino
riceva input esterni attraverso una serie di sensori e che agisca sul
mondo esterno attraverso degli attuatori. Per collegare questi
elementi alla scheda in questione si utilizza, di norma, una speciale
scheda forata, nota come breadboard, che consente la connessione
degli elementi necessari al prototipo senza necessità di effettuare
laboriose saldature dei vari componenti, consentendo quindi il
sistematico reimpiego di questi ultimi nei vari prototipi. Una tipica
breadboard è visibile nella Figura 28.11.

Figura 28.11 – Una tipica breadboard.
Una breadboard, nota anche con il termine di basetta sperimentale,
è sostanzialmente divisa in due sezioni da una scanalatura. In ogni

sezione sono presenti due righe, su alcuni modelli evidenziate con i
colori rosso e blu, nelle quali collegare l’alimentazione elettrica che
verrà fornita al circuito. Le righe in questione sono individuate dai
simboli + e –, rispettivamente per il polo positivo e negativo
dell’alimentazione.
Per collegare i vari componenti, la breadboard dispone di una serie
di fori distanziati di 2,54 millimetri, ovvero un decimo di pollice. Il
motivo di tale misura è dato dal fatto che essa rappresenta la
distanza standard tra i pin dei circuiti integrati, che possono così
essere collegati su tale basetta senza difficoltà.
Esistono differenti tipologie di breadboard che si distinguono
principalmente per il numero di fori presenti sulla basetta e per le
modalità di collegamento dell’alimentazione. Il modello presentato
nella Figura 28.11 è noto come half+. Altri modelli tipici sono full,
full+, half, mini, tiny e BB-301.
Perpendicolarmente alle linee di alimentazioni vi sono una serie di
ulteriori sequenze di fori, etichettate con dei numeri, che sono
collegate elettricamente. Nella Figura 28.12 è presentato lo schema
di collegamento elettrico di una tipica basetta in cui le linee
disegnate sulla breadboard indicano le sottostanti linee elettriche.

Figura 28.12 – I collegamenti elettrici della breadboard.

Qualche cenno sui principi della
corrente elettrica
È palese che il contesto di questo capitolo e, più in generale, del
libro stesso non può prevedere spiegazioni dettagliate relative alla
corrente elettrica e ai suoi utilizzi nei circuiti elettronici. In ogni caso i
più esperti tra voi troverebbero di scarso interesse la trattazione, in
quanto sarebbero necessari approfondimenti non contenibili nei
pochi paragrafi qui presentati. Sono inoltre disponibili interi volumi
che trattano la disciplina elettronica nel livello di dettaglio richiesto
per un uso professionale. Un ottimo manuale per approfondire la
tematica in questione è “Elettronica per maker” di Paolo Aliverti,
edito da LSWR.
Tuttavia, può qui essere importante, per chi si avvicina per le prime
volte agli aspetti elettronici provenendo dal mondo della
programmazione software, rispolverare qualche nozione di base
sulla corrente elettrica e sui principali componenti dei circuiti elettrici.
La corrente elettrica può essere vista come un flusso di elettroni,
cariche elettriche negative, che attraversa un conduttore. Sono
diverse le proprietà di interesse in relazione alla costruzione di un
circuito elettrico. La quantità di elettroni che transitano lungo una
sezione del conduttore in una data unità di tempo è misurata in
ampere e indicata come intensità di corrente (simbolo I). Affinché
vi possa essere il passaggio di cariche è necessario la presenza di
una forza che le spinga lungo il conduttore. Tale forza è realizzata
tramite una differenza nel numero di cariche presenti ai due capi del
conduttore. Le cariche in eccesso su di un lato cercheranno di
raggiungere il lato opposto per compensare lo squilibrio. Il tutto è di
norma realizzato tramite una batteria e la differenza di cariche è nota
come voltaggio o differenza di potenziale (simbolo ΔV) e misurata
in volt (simbolo V). Il lato con cariche negative in eccesso è noto
come polo negativo mentre l’altro capo è ovviamente il polo
positivo. Sebbene siano le cariche negative, ovvero gli elettroni, a
spostarsi
lungo
il
conduttore,
di
norma
si
assume

convenzionalmente, per motivi storici, che il verso della corrente inizi
dal polo positivo e si diriga verso il polo negativo.
Se il verso della corrente è costante nel tempo per l’intera durata di
funzionamento del circuito, nel senso che ad esempio esso parte
sempre dal polo positivo e si dirige verso quello negativo, si parla di
corrente continua, mentre, in caso contrario, quando il flusso si
inverte in maniera sistematica, in quanto si inverte la polarità dei poli
del sistema di alimentazione, si parla di corrente alternata.
Ovviamente, la corrente che circola nel conduttore incontra una
certa resistenza, che generalmente si manifesta attraverso la
produzione di calore, e tale proprietà è nota appunto come
resistenza elettrica (simbolo R) e si misura in ohm, il cui simbolo è
Ω (omega). Di norma la resistenza del conduttore è trascurabile
mentre è di notevole interesse, per il funzionamento del circuito, la
resistenza interna dei componenti utilizzati, i quali causano ai loro
capi una caduta di tensione elettrica.
Riepilogando, le caratteristiche fondamentali della corrente elettrica
sono tre: la differenza di potenziale, simbolo V, l’intensità di corrente,
simbolo I e la resistenza elettrica, simbolo R. Queste quantità sono
inscindibilmente legate da una relazione, nota come legge di Ohm,
che può essere scritta come segue:

V=R×I
Ovvero, ai capi di un conduttore la tensione elettrica è uguale alla
resistenza moltiplicata l’intensità. Infatti, esiste un ovvio rapporto di
proporzionalità tra la tensione e la corrente, nel senso che
all’aumentare dell’una deve, per forza di cose, aumentare anche
l’altra e tale rapporto è condizionato appunto dalla resistenza
dell’elemento che è attraversato dal flusso di corrente.

LED, resistenze e caduta di tensione
Uno degli elementi più utilizzati in un circuito, particolarmente nel
contesto di semplici sperimentazioni, è il LED. Nei primi esempi di
utilizzo di Arduino ci siamo limitati ad accendere e spegnere il LED
presente sulla scheda stessa. Ovviamente, la suddetta operazione
non comporta alcuna difficoltà particolare, mentre nel caso di utilizzo
di un LED esterno abbiamo bisogno di pianificare con attenzione le
operazioni da compiere. Il primo passo consiste nella scelta del LED.
Esistono infatti vari tipi di LED, che si differenziano per il colore della
luce generata e per il voltaggio a cui possono funzionare, noto come
tensione di soglia. I vari colori sono infrarosso, rosso, arancione,
giallo, verde, blu, viola, ultravioletto e bianco. Di seguito vi propongo
uno schema che lega i principali colori alle tensioni di soglia.

LED

Tensione

infrarosso

1,3

rosso

1,8

giallo

1,9

verde

2,0

bianco

3,0

blu

3,5

Tali tensioni sono approssimative, nel senso che esiste un margine
di funzionamento per ogni LED e che tali tensioni dipendono anche
dal costruttore.
I LED hanno due specifici poli, uno positivo, noto come anodo, e
uno negativo, chiamato catodo. È quindi indispensabile alimentarli
nel circuito con la giusta polarità al fine di farli funzionare
correttamente senza danneggiarli. Di norma il catodo è riconoscibile
in quanto più corto del lato positivo. Nel caso in cui il componente
fosse già stato tagliato, e quindi ci si trovasse di fronte a due

connettori di uguale lunghezza, potremmo riconoscere il catodo
guardando il LED in controluce e individuando l’elemento più grande.
In ogni caso, anche se nella giusta polarità, una corrente eccessiva
potrebbe bruciare il LED.

Figura 28.13 – Un tipico LED e il relativo simbolo nello schema
elettrico.
È molto importante inserire il LED nella corretta polarità poichè esso
si comporta proprio come un diodo. Tale componente è un altro
tipico elemento dei circuiti elettrici, che consente il passaggio di
corrente in una sola direzione: per cui, inserito in senso errato, si
comporta come un interruttore chiuso, impedendo il passaggio di
corrente. Il LED è quindi un diodo particolare che ha la proprietà di
generare luce quando attraversato da una specifica quantità di
corrente e quindi quando ai suoi capi è applicata una specifica
differenza di potenziale. Non a caso, il termine LED è un acronimo
che sta per Light Emitting Diode, ovvero diodo a emissione
luminosa.
Onde evitare problemi è quindi necessario inserire, in serie al LED,
un componente di tipo resistenza di uno specifico valore. Una
resistenza, dunque, si oppone al passaggio della corrente
salvaguardando il LED, ma deve avere un valore ben determinato al
fine di consentire il passaggio della corrente sufficiente per far
accendere il LED stesso. Le resistenze, come detto, vengono
misurate in ohm. Per indicarne e riconoscerne il valore si utilizza uno
schema di bande colorate stampate sul componente stesso. Di
norma si utilizzano quattro strisce colorate.

Colore

banda 1 banda 2
banda 3
1° cifra 2° cifra Moltiplicatore

Nero

0

0

1Ω

Marrone

1

1

10 Ω

Rosso

2

2

100 Ω

Arancio

3

3

1 KΩ

Giallo

4

4

10 KΩ

Verde

5

5

100 KΩ

Blu

6

6

1 MΩ

Viola

7

7

10 MΩ

Grigio

8

8

Bianco

9

9

La quarta banda è generalmente di colore oro oppure argento e
indica la tolleranza, ovvero l’affidabilità della resistenza rispetto a
quanto dichiarato dal costruttore. Il senso è che le resistenze
effettive possono variare leggermente rispetto ai valori nominali di
fabbricazione. Il colore oro corrisponde a una tolleranza del +/–5%,
mentre il colore argento a una di +/–10%.

Figura 28.14 – Una resistenza e il relativo simbolo nello schema
elettrico.

Per leggere il valore di una resistenza è sufficiente interpretare le
bande colorate avendo cura di mettere sulla propria destra la banda
con i valori di tolleranza (argento oppure oro). Le prime due bande
rappresentano rispettivamente la prima e la seconda cifra del
numero che indica il valore della resistenza, mentre il terzo colore
viene usato come moltiplicatore. Infatti, spesso il valore in ohm della
resistenza è molto alto e quindi si usano dei multipli come, ad
esempio, K per mille e M (mega) per il milione. Vi propongo un
semplice esempio. Supponiamo di avere una resistenza aventi i
seguenti colori: marrone, nero, rosso, oro. Il marrone e il nero
corrispondono a 10 come prime due cifre mentre il terzo colore, il
rosso, corrisponde al moltiplicatore 100 Ω. Quindi la nostra
resistenza avrà un valore di 1.000 Ω corrispondenti a 1K Ω. Il colore
oro indica una tolleranza del +/–5%.
Dobbiamo dunque calcolare la giusta resistenza da inserire nel
circuito al fine di proteggere il LED. Per farlo possiamo sfruttare la
legge di Ohm scritta nella forma:

R=V/I
ovvero, la resistenza è data dalla tensione diviso l’intensità di
corrente. Supponiamo di prendere l’alimentazione dalla scheda
Arduino che, come sappiamo, eroga 5 volt. Tuttavia, la tensione V da
utilizzare nella formula non è questa tensione di uscita, ma
dobbiamo impostare la differenza tra tale tensione di alimentazione e
la caduta di tensione che vogliamo si verifichi ai capi del LED. Per
fissare le idee utilizziamo nel nostro circuito un LED rosso e
impostiamo 1,8 V come valore desiderato per la tensione ai capi del
LED. La corrente I da inserire al denominatore della formula è la
corrente che vogliamo passi all’interno del LED. Tale corrente, per il
LED in questione, dovrebbe aggirarsi intorno ai 20 mA (ovvero 20
milliampere, cioè 0,02 A). Tale corrente massima varia da LED a
LED ed è normalmente indicata sui cosiddetti datasheet, cioè delle
schede con le indicazioni di tutti i parametri funzionali del nostro
componente. La formula finale diventa dunque la seguente:

R = Valim - Vled / I = 5 - 1,8 / 0,02 = 3,2 / 0,02 = 160
dove Valim è la tensione prodotta dall’alimentatore e Vled quella

richiesta per il LED. Abbiamo dunque bisogno di una resistenza di
160 ohm. Tuttavia, dobbiamo sapere che non sono disponibili in
commercio resistenze di qualsiasi valore in ohm ma solo un numero
ben definito e standardizzato. Nel caso specifico, le tipologie in
commercio che più si avvicinano al nostro valore di interesse di 160
ohm sono quelle con valori di 150 e 180 ohm. Teoricamente,
essendo tali valori abbastanza vicini a quello di nostro interesse,
potremmo scegliere indifferentemente una delle due, considerando
anche che esse prevedono comunque una certa tolleranza. Tuttavia,
conviene di norma utilizzare una resistenza con un valore maggiore,
piuttosto che minore, rispetto a quanto calcolato per avere un
maggior margine di sicurezza rispetto alla salvaguardia del nostro
LED. Nel caso in questione scegliamo quindi una resistenza da 180
ohm avente, ovviamente, la sequenza di colori marrone, grigio e
marrone per le prime tre bande e normalmente oro per la quarta.
Lo schema finale del nostro semplice circuito sarà dunque quello
mostrato in Figura 28.15.

Figura 28.15 – Lo schema elettrico del circuito con un LED e una
resistenza in serie.
Il motivo per cui per il calcolo della tensione sottraiamo quella ai capi
del LED da quella di alimentazione è da ricercarsi in una proprietà
fondamentale dei circuiti nota come legge di Kirchhoff delle
tensioni. Secondo questa legge, la somma (algebrica) delle tensioni
in una sezione chiusa di un circuito elettrico deve essere pari a zero.
Nel nostro circuito abbiamo quindi che:

Valim - Vled - Vresistenza = 0

da cui deriva, banalmente, che la tensione di cui abbiamo bisogno ai
capi della resistenza, la cosiddetta caduta di tensione, deve essere
uguale a:

Vresistenza = Valim - Vled
così come avevamo impostato nel nostro calcolo.
Vediamo allora come realizzare praticamente il circuito. Per prima
cosa fissiamo i componenti sulla breadboard, così come mostrato
nella Figura 28.16, e successivamente alimentiamo il circuito
collegando la breadboard alla scheda Arduino. Per un primo
semplice test di accensione possiamo collegare il positivo
sull’alimentazione di 5 volt e il negativo al pin GND nella sezione di
alimentazione di uscita, indicata nella Figura 28.3 con il numero 6. Il
tutto è visibile chiaramente sempre nella Figura 28.16.
Una volta verificati e corretti eventuali problemi, sarà possibile
alimentare il circuito sulla breadboard collegando il positivo
dell’alimentazione al pin digitale 13 di Arduino e il polo negativo al
pin GND immediatamente vicino a quest’ultimo. In questo modo sarà
possibile verificare l’accensione del LED sulla breadboard in
concomitanza con l’accensione del LED sulla scheda Arduino
utilizzando gli sketch proposti negli esempi precedenti, che facevano
riferimento appunto al pin numero 13.

Figura 28.16 – Il circuito con un LED e una resistenza in serie
implementato sulla breadboard.

Per sperimentare concretamente ciò che avviene all’interno del
circuito può essere di fondamentale importanza dotarsi di uno
strumento di misurazione come un multimetro, più noto
semplicemente come tester. Si tratta di uno strumento che consente
di misurare varie caratteristiche di un circuito quali tensioni, correnti
e resistenze.

Figura 28.17 – Un multimetro digitale.
Esistono due tipi di tester: analogici e digitali. Indipendentemente
dalla tipologia, ovviamente, è necessaria una certa pratica per
effettuare misurazioni corrette sul circuito e una buona dose di
attenzione quando si lavora con tensioni di rete come quelle
casalinghe, che possono arrecare seri danni allo strumento ma
soprattutto all’operatore. Tuttavia, nel caso dei nostri esperimenti le
tensioni e le correnti sono estremamente basse da non comportare
particolari problemi.

Fritzing: un aiuto per la progettazione
elettronica
La costruzione di un prototipo è un’operazione che può richiedere un
grosso impegno in termini di tempo e lavoro. Ovviamente, una volta
realizzato il prototipo e constatatane l’efficacia rispetto al proprio
progetto iniziale, si vorrà realizzare l’oggetto finale. In questa ottica
può risultare di grande aiuto un progetto software, noto con il nome
di Fritzing, che è di ausilio sia nella fase di progettazione sia in
quella di realizzazione del prodotto finale. Fritzing è un progetto
open source che affonda le sue radici nello stesso brodo primordiale
di Processing, Wiring e Arduino e che ha come scopo principale
quello di aiutare nella realizzazione di prototipi elettronici che si
basano su schede a microcontroller non solo i professionisti del
settore ma anche hobbisti, designer e artisti in genere.
Il software è disponibile per tutte le principali piattaforme come
Windows, Mac e Linux. Il sito di riferimento è fritzing.org.

Figura 28.18 – L’IDE di Fritzing.

Come è possibile notare dalla Figura 28.18, il software consente di
costruire in maniera virtuale l’intero prototipo disponendo sulla griglia
di lavoro i vari componenti necessari, collegandoli nella maniera
opportuna. Il software in esame ha diversi aspetti di grande
interesse. Una sua prima utilità sta nella semplicità di
sperimentazione dei tantissimi componenti elettronici disponibili, il
che consente, anche ai meno esperti, di acquisire una certa
familiarità con resistenze, condensatori e tutta la varietà di
componentistica necessaria per realizzare un determinato progetto.
Inoltre, si ha la possibilità di salvare su file i progetti realizzati per
avere un riferimento futuro per la loro eventuale successiva
implementazione. Ancora, essendo il software molto utilizzato, sono
disponibili in rete innumerevoli file di progetti già realizzati con i quali
fare nuove esperienze. Infine è possibile passare dal virtuale al
reale, nel senso che il progetto mette a disposizione il cosiddetto
Fritzing Fab, che consente di farsi produrre, a un prezzo
ragionevole, il circuito stampato, noto anche in inglese come PCB
(Printed Circuit Board). Una volta inviato il proprio disegno di
progetto, il team di Fritzing verifica anche che questo non presenti
potenziali problemi produttivi, ovviamente non arrivando alla verifica
della correttezza del circuito dal punto di vista del funzionamento
elettronico.

Bluetooth + Arduino = IoT
Anche se l’equazione Bluetooth + Arduino = IoT non è la sola possibile,
essa può rappresentare un modo, forse di colore, per indicare come
il contesto del mondo Internet of Things si possa basare su schede a
microntroller, come Arduino, che si collegano al mondo esterno
attraverso la arcinota tecnologia Bluetooth. Tale tecnologia deve il
suo nome a un re danese del decimo secolo, Harald Blåtand, noto in
inglese come Harold Bluetooth, il quale restò famoso per la sua
capacità di unire differenti fazioni in lotta tra di loro. Il senso della
scelta del nome è quindi quello di voler sottolineare come questa
tecnologia cerchi di appianare le differenze tra vari dispositivi
consentendo a essi di comunicare tra loro. Il sito di riferimento è
www.bluetooth.com.
Il Bluetooth è utilizzato in innumerevoli situazioni dove è richiesto il
collegamento tra più dispositivi quali, solo per citarne alcuni,
computer, stampanti, cellulari, auricolari e autovetture. Quello che ci
proponiamo è di consentire ad Arduino di essere controllato in
modalità Bluetooth attraverso un dispositivo tipo uno smartphone o
un PC. In tal modo possiamo, ad esempio, comandare Arduino da
remoto al fine di pilotare un pin digitale e quindi eseguire una
specifica azione di nostro interesse.
Sebbene alcuni modelli di scheda Arduino abbiano integrata la
circuiteria per la comunicazione Bluetooth, la versione Arduino Uno,
che prendiamo come riferimento in quanto prodotto entry level, non
possiede tale capacità di comunicazione e dobbiamo quindi
collegare a essa uno specifico dispositivo che faccia da ponte tra
Arduino e il mondo esterno. Tali dispositivi aggiuntivi, noti come
moduli, sono realizzati da vari produttori e facilmente reperibili su
Internet oppure in negozi di componentistica elettronica.
Tra i vari modelli disponibili concentriamo la nostra attenzione su
quelli identificati dalle sigle HC-05 e HC-06. Entrambi sono basati sul
chip Cambridge Silicon Radio BC417, funzionante a 2.4 GHz.
Mentre la versione HC-05 può essere settata sia come Master sia
come Slave, la versione HC-06 è utilizzabile solo in modalità Slave.

Fondamentalmente ciò significa che il modello HC-06 può essere
ricercato dal nostro smartphone e quindi è possibile,
successivamente, comunicare con esso in maniera bidirezionale,
mentre il modello HC-05 consente esso stesso di scansionare
l’ambiente circostante alla ricerca di dispositivi ai quali collegarsi.
I moduli in questione richiedono una tensione di 5 volt per
l’alimentazione. È quindi possibile collegare l’uscita 5V e GND di
Arduino rispettivamente ai pin VCC e GND del modulo Bluetooth.
Dobbiamo poi collegare i pin di trasmissione e ricezione (RXD e
TXD) del modulo alla scheda Arduino e possiamo riferirci ai pin
digitali 0 e 1 di quest’ultima. I pin digitali 0 e 1 di Arduino sono in
effetti etichettati rispettivamente anche come RX e TX. Dobbiamo
allora collegare il TXD del modulo al pin 0 (RX) di Arduino e l’RXD
del modulo al pin 1 (TX) sempre della scheda Arduino. Lo schema
grafico è presente nella Figura 28.19.

Figura 28.19 – Il collegamento tra Arduino e il modulo Bluetooth.
Il modo più semplice per effettuare i collegamenti in oggetto è
ovviamente quello di collocare il modulo Bluetooth sulla breadboard,
essendo tale modulo compatibile a livello di distanza tra i pin con la
nostra basetta.

A questo punto, per poter interagire con Arduino, dovremo collegarci
al modulo Bluetooth appena installato. Per farlo possiamo sfruttare
un’app open source per Android chiamata BlueTerm, che consente
di comunicare in modo seriale con qualsiasi dispositivo con
connettività Bluetooth che accetti appunto una connessione seriale.
È ovviamente il caso del nostro modulo HC-06 per Arduino.
Una volta scaricata dal Google Play Store, installata e lanciata
l’applicazione in oggetto, potremo connetterci al nostro dispositivo
che dovrebbe essere visualizzato come qualcosa del tipo HC-06
sulla console di BlueTerm. Una volta cliccato sul nome del
dispositivo verrà richiesto il PIN per l’associazione, che di norma è
1234. Ad associazione avvenuta, il LED presente sul modulo
cesserà di lampeggiare e rimarrà acceso. BlueTerm ci comunicherà
invece l’avvenuta associazione mostrando una schermata vuota
nella quale potremo inviare i nostri comandi. A tal fine, per rendere
maggiormente interessante l’esperimento potremo fare riferimento
allo sketch utilizzato per la connessione con il serial monitor nel
quale inviavamo il carattere 0 per spegnere il LED 13 e il carattere 1
per accenderlo. Per affinare le nostre abilità pratiche può essere a
questo punto importante collegare sul pin 13, così come già fatto in
precedenza, un LED esterno protetto dalla nostra resistenza. Lo
schema finale di montaggio potrebbe essere quello mostrato in
Figura 28.20.

Figura 28.20 – Il collegamento tra Arduino, il modulo Bluetooth e un
LED sul pin 13.
Finalmente, sarà sufficiente digitare 0 oppure 1 nel terminale di
BlueTerm per accendere e spegnere il nostro LED, come visibile
nella Figura 28.21. In buona sostanza abbiamo sostituito l’invio dei
comandi nel serial monitor con un invio effettuato da smartphone.

Figura 28.21 – L’app BlueTerm utilizzata per l’accensione e lo
spegnimento di un LED.

Programmazione del modulo Bluetooth
Ovviamente, per rendere il tutto professionale è necessario
riprogrammare il modulo con un nuovo SSID (Service Set IDentifier),
ovvero il nome che appare nella scansione, e una nuova password.
Quest’ultimo aspetto, relativo alla password, è ovviamente molto
importante per evitare che persone non autorizzate accedano al
nostro dispositivo nel momento in cui questo diventerà
effettivamente operativo.
Per riprogrammare il modulo Bluetooth si usano i cosiddetti
comandi AT, noti anche come comandi Hayes, dal nome di Dennis
Hayes, originale sviluppatore di tale set di comandi. Si tratta di una

serie di istruzioni usate storicamente per inviare comandi ai modem
attraverso una porta seriale. La sintassi in questione prevede di far
seguire alla stringa AT, che si riferisce alla parola inglese Attention,
lo specifico comando. Vediamo di seguito i principali comandi da
inviare.
Scrivendo il semplice comando AT possiamo verificare la
comunicazione tra Arduino e il modulo Bluetooth, in quanto, se
questa è presente, il modulo risponderà con la dicitura OK.
Sempre in termini di testing possiamo usare il comando:
AT+VERSION

che restituisce la versione del firmware del modulo.
Per impostare il nome del modulo usiamo il comando:
AT+NAMEmionome

dove mionome è il SSID da associare al modulo. Tale nome non deve
superare i 20 caratteri.
Per impostare la password usiamo invece il comando:
AT+PINxxxx

dove la stringa xxxx deve essere sostituita con la password di nostra
scelta.
Infine, è possibile impostare la velocità di comunicazione con la
stringa di comando:
AT+BAUDx

dove x è una cifra esadecimale che può essere 1 per 1200 bps, 2
per 2400 bps e, di seguito, 3=4800, 4=9600, 5=19200, 6=38400,
7=57600, 8=115200, 9=230400, A=460800, B=921600, C=1382400.
Vediamo allora come inviare i comandi AT al nostro modulo. Per
farlo realizziamo un apposito sketch da far eseguire ad Arduino e
che utilizzeremo solo per la fase di programmazione in questione in
quanto, una volta programmato con i settaggi di nostro interesse,
caricheremo su Arduino lo sketch di uso normale. Lo sketch di
programmazione farà uso del serial monitor per raccogliere i nostri
comandi e inviarli al modulo Bluetooth e al contempo riceverà le

risposte dal modulo Bluetooth e le visualizzerà al suo interno. Il
serial monitor, come già detto, è connesso alla porta hardware di
Arduino, che corrisponde al pin 0 per la ricezione (RX) e al pin 1 per
la trasmissione (TX). Faccio incidentalmente notare come di solito le
porte seriali vengano chiamate UART (Universal Asynchronous
Receiver-Transmitter) oppure USART (Universal SynchronousAsynchronous Receiver/Transmitter).
Fortunatamente, per casi come questo in cui abbiamo bisogno di
un’ulteriore porta seriale per interfacciarci con il modulo Bluetooth,
Arduino mette a disposizione una specifica libreria software nota
come SoftwareSerial, che consente di sfruttare due pin digitali di
Arduino per adibirli a RX e TX aggiuntivi.
Per sfruttare la nostra nuova libreria sarà sufficiente la seguente
direttiva:
#include <SoftwareSerial.h>

In seguito dobbiamo istanziare uno specifico oggetto utilizzando il
costruttore SoftwareSerial, scrivendo qualcosa del tipo:
SoftwareSerial Bluetooth(pinRx, pinTx);

dove al posto di pinRx e pinTx indicheremo il numero del pin,
rispettivamente, per la ricezione e trasmissione dei dati e dove
Bluetooth è un nome di nostra scelta per l’oggetto.
Lo sketch dovrà poi essere in grado di leggere i comandi dal serial
monitor e inviarli al modulo Bluetooth raccogliendone le risposte.
Vediamo quindi, per intero, il codice in questione:
#include <SoftwareSerial.h>
const int RX = 2;
const int TX = 3;
SoftwareSerial Bluetooth(RX, TX);
void setup()
{
Serial.begin(9600);
Bluetooth.begin(9600);
Serial.println("Comunicazione inizializzata!");
Serial.println("Inserire i comandi AT per configurare il
modulo.");
}

void loop()
{
if (Bluetooth.available())
{
Serial.write(Bluetooth.read());
}
if (Serial.available())
{
Bluetooth.write(Serial.read());
}
}

Lo sketch è abbastanza semplice. Come si vede, usiamo i pin 2 e 3
di Arduino per la ricezione e trasmissione dei dati verso il modulo
Bluetooth. Nella funzione setup impostiamo a 9600 bps le velocità di
entrambe le porte seriali, sia quella hardware di default di Arduino
Serial, sia quella software gestita dall’oggetto che abbiamo chiamato
Bluetooth.
Ovviamente per il corretto funzionamento dello sketch dovremo
collegare i pin 2 e 3 di Arduino rispettivamente ai pin TX e RX del
modulo Bluetooth. Per essere più chiari, il pin RX (2) di Arduino deve
essere collegato al pin TX del modulo Bluetooth e il pin TX (3) di
Arduino al pin RX del modulo in esame.
Procedendo con l’analisi dello sketch, notiamo che nella funzione
loop,
se ci sono dati disponibili nel modulo Bluetooth,
if(Bluetooth.available()), scriviamo sulla seriale ciò che leggiamo dal
modulo Bluetooth, Serial.write(Bluetooth.read()).
D’altra parte, se sono presenti dati sulla seriale hardware,
if(Serial.available()), scriviamo sul modulo Bluetooth ciò che
leggiamo dal serial monitor, Bluetooth.write(Serial.read()), ovvero i
comandi che abbiamo in esso digitati.
Una volta collegati i cavi, eseguito l’upload dello sketch e lanciato il
serial monitor, dovrebbe essere possibile inviare i dati di
configurazione del modulo, così come mostrato nella Figura 28.22,
al quale abbiamo inviato la seguente sequenza di comandi:
AT+VERSION
AT+NAMEArduino
AT+PIN4321

NOTA Nel caso dell’esempio in oggetto è stato usato un modulo
HC-06 che non richiede caratteri di fine riga. Tuttavia, con
alcuni moduli, potrebbe essere necessario selezionare,
nell’apposita lista a cascata del serial monitor, una voce
per inviare un a capo (NL ovvero \n ) e un ritorno carrello
(CR ovvero \r).

Figura 28.22 – Il serial monitor visualizza l’output dei comandi inviati al
modulo Bluetooth.

Come abbiamo visto, lo sketch precedente consente la
programmazione del modulo Bluetooth in maniera interattiva,
inviando al modulo in questione una serie di comandi AT. In alcuni
casi, si potrebbe desiderare di realizzare uno sketch che impartisca
comandi ben definiti direttamente in fase di esecuzione dello sketch
stesso. Una possibile soluzione, molto semplice, è data dal seguente
codice:
#include <SoftwareSerial.h>
const int RX = 2;
const int TX = 3;
SoftwareSerial Bluetooth(RX, TX);
void setup()
{
Serial.begin(9600);
while (!Serial)
{
; // Attesa per la comunicazione seriale. Necessaria solo
nel caso di porta USB
}
Serial.println("Programmazione modulo Bluetooth!");

// imposto velocità seriale Bluetooth
Bluetooth.begin(9600);
Bluetooth.print("AT+VERSION");
AttendiRisposta();
Bluetooth.print("AT+NAME");
Bluetooth.print("Arduino");
AttendiRisposta();
Bluetooth.print("AT+PIN");
Bluetooth.print("1234");
AttendiRisposta();
}
void AttendiRisposta()
{
delay(1000);
while (Bluetooth.available())
{
Serial.write(Bluetooth.read());
}
Serial.write("\n");
}
void loop()
{
//vuoto
}

Come si può facilmente evincere dal codice, i comandi al modulo
vengono inviati attraverso istruzioni del tipo:
Bluetooth.print("AT+VERSION");

Per consentire il ritorno senza problemi dell’output del modulo
rispetto a tali comandi, si predispone una funzione, che abbiamo
chiamato AttendiRisposta, che esegue un’attesa di un secondo e
successivamente legge dallo stream del modulo per scriverlo sulla
seriale di default. Da notare come la funzione loop risulti vuota, non
dovendo eseguire alcuna operazione.
In ogni caso, una volta programmato il modulo dovremo uploadare lo
sketch da far eseguire alla scheda e, solo successivamente,
ricollegare i pin 0 e 1 di Arduino verso i corrispondenti pin del
modulo Bluetooth.

Collegamento wireless: il modulo
ESP8266
Il collegamento di tipo Bluetooth è eccellente in tutta una serie di
situazioni ma esso ha, tuttavia, anche grosse limitazioni, ad esempio
legate alla distanza di funzionamento degli apparati. Nel caso si
necessiti di collegamento a distanze superiori a qualche decina di
metri ci si può affidare a un collegamento di tipo Wi-Fi. Fra le varie
possibili soluzioni spicca, per lo straordinario rapporto prezzoprestazioni, il modulo Wi-Fi basato sull’integrato ESP8266. Si tratta
di un cosiddetto SoC, acronimo che sta per System on a Chip,
ovvero un sistema completo realizzato su un singolo circuito
integrato (chip), prodotto dall’azienda cinese Espressif Systems.
Basandosi su questo chip, l’azienda AI-Thinker ha realizzato un
modulo di grande successo noto come ESP-01, acquistabile
facilmente su Internet a un costo irrisorio di qualche euro.

Figura 28.23 – Il modulo ESP-01 ESP8266.
Per collegare il nostro Arduino Uno al modulo in questione bisogna
prestare molta attenzione, perché il modulo ESP-01 richiede una
tensione sui pin RX e TX di soli 3.3 volt mentre Arduino gestisce 5
volt. Si corre quindi il serio rischio di danneggiare irreparabilmente il
modulo. Sebbene sia possibile realizzare specifici artifici per
adattare il giusto voltaggio e la giusta corrente richiesta dal modulo,
il sistema più pratico per collegare Arduino all’ESP-01 può essere

l’acquisto, sempre su Internet e sempre per pochi euro, di uno
specifico adattatore la cui sigla è ADP-01. Tale adattatore, spesso
identificato con la descrizione ADP-01 Adattatore per ESP-01
ESP8266, oltre a convertire la corrente così come richiesta dal
modulo (Level Converter 3.3V- 5V), consente anche di inserire il
tutto su di una breadboard (Breadboard Adapter). Infatti,
contrariamente all’adattatore, il modulo ESP-01 ha una piedinatura
non compatibile con le distanza tra i fori della breadboard.
Una volta collegati tra loro il modulo e l’adattatore, come mostrato in
Figura 28.24, possiamo inserire l’adattatore sulla breadboard e
collegare i connettori di alimentazione e quelli di ricezione e
trasmissione dei dati. Sull’adattatore sono chiaramente visibili i
simboli + e – per l’alimentazione, così come i simboli RX e TX. Per la
programmazione del modulo possiamo servirci dello stesso schema
e dello stesso sketch utilizzato per la programmazione del modulo
Bluetooth, collegando il pin 2 di Arduino al TX dell’adattatore e il pin
3 sempre di Arduino all’RX dell’adattatore.

Figura 28.24 – Il modulo ESP-01 ESP8266 pronto per essere
inserito sull’adattatore ADP-01.
Come detto, una volta collegati modulo e adattatore sulla
breadboard e ad Arduino, possiamo passare alla fase di
programmazione vera e propria utilizzando sostanzialmente lo
stesso sketch usato per programmare il modulo Bluetooth e che
riporto qui di seguito.
#include <SoftwareSerial.h>
const int RX = 2;
const int TX = 3;

SoftwareSerial Esp8266(RX, TX);
void setup()
{
Serial.begin(9600);
Esp8266.begin(9600);
Serial.println("Comunicazione inizializzata!");
Serial.println("Inserire i comandi AT per configurare il
modulo ESP8266.");
}
void loop()
{
if (Esp8266.available())
{
Serial.write(Esp8266.read());
}
if (Serial.available())
{
Esp8266.write(Serial.read());
}
}

Come si può osservare, si tratta del medesimo sketch precedente
con l’unica differenza che abbiamo chiamato Esp8266 l’oggetto
istanziato con il costruttore SoftwareSerial. Ovviamente, avremmo
potuto mantenere il nome già utilizzato in precedenza così come
sceglierne un altro qualsiasi. Conviene comunque mantenere
separati i due sketch sia per una questione di comodità d’uso sia per
il fatto che sarà possibile personalizzarli per i moduli specifici.
Arrivati dunque a questo punto, non resta che uploadare lo sketch in
questione e aprire il serial monitor. Anche in questo caso possiamo
usare i comandi AT dello standard Hayes e così proviamo per prima
cosa a digitare il solo comando AT in attesa di una risposta positiva
di tipo OK. Se i collegamenti sono corretti, il serial monitor dovrebbe
mostrate qualcosa di simile a quanto visualizzato in Figura 28.25.

Figura 28.25 – Il serial monitor in programmazione sul modulo ESP01 ESP8266.
Nel caso di insuccesso della comunicazione può essere utile
verificare il tipo di fine linea, che dovrebbe essere NL & CR, e la
velocità che dovrebbe essere impostata a 9600 bps sia nel serial
monitor che nello sketch. In alternativa si potrebbe provare a velocità
diverse, come ad esempio 57600 o 115200 bps.
Il primo comando AT da utilizzare può essere AT+GMR, che restituisce
le informazioni relative alla versione del firmware. Il comando AT+RST,
invece, consente di riavviare il modulo.
Il modulo ESP-01 può essere configurato sia come semplice client
sia come Access Point. Per verificare l’attuale configurazione è
possibile usare il comando:
AT+CWMODE_CUR?

Questo visualizzerà la configurazione attuale del modulo in relazione
al Wi-Fi secondo il seguente schema: 1 per modalità Station
(client), 2 per modalità AP (Access Point) e 3 per modalità AP +
modalità Station. La modalità Station (numero 1) prevede che il
modulo abbia un indirizzo IP che gli consente di collegarsi, appunto,
come client al nostro router wireless. La modalità AP (numero 2)
prevede invece che il modulo abbia un indirizzo IP che funga da
server, permettendo ad altre macchine di collegarsi a esso.
I numeri in questione possono essere usati per impostare la

specifica modalità desiderata. Ad esempio, scrivendo il comando:
AT+CWMODE_CUR=3

impostiamo la modalità 3 (modalità AP + modalità Station). I
comandi in questione, tuttavia, non salvano la configurazione nella
memoria flash. Se si vuole ottenere questo risultato è necessario
utilizzare il comando AT+CWMODE_DEF=<mode>, dove <mode> è un numero da
1 a 3 con il medesimo significato del caso precedente. Ad esempio,
per salvare la configurazione per la modalità AP + modalità Station,
scriveremo:
AT+CWMODE_DEF=3

mentre per ottenere le informazioni relative all’attuale configurazione
salvata su flash scriveremo il comando:
AT+CWMODE_DEF?

Modalità Station
A questo punto possiamo connetterci al nostro router wireless. Per
farlo, digitiamo il comando:
AT+CWLAP

che elenca tutti gli Access Point disponibili. Ovviamente, affinché
tale comando non generi un errore, è necessario che la modalità
attuale del modulo sia anche di tipo Station, quindi impostata al
valore 1 oppure 3. Infatti, in caso contrario, il modulo non avrebbe
accesso al nostro router wireless. Individuato il nostro SSID, che in
realtà dovremmo già conoscere, usiamo il comando:
AT+CWJAP="SSID","password"

inserendo il nome della nostra connessione al posto della stringa
SSID e la relativa password, così come nel comando di esempio
appena scritto. In caso di successo dovremmo ottenere un
messaggio del tipo:
WIFI CONNECTED
WIFI GOT IP

Per verificare l’assegnazione dell’indirizzo IP possiamo digitare il
comando:
AT+CIFSR

In output riceveremo qualcosa di simile a ciò che segue:
+CIFSR:APIP,"192.168.20.6"
+CIFSR:APMAC,"5e:cf:7f:0d:42:e6"
+CIFSR:STAIP,"192.168.20.5"
+CIFSR:STAMAC,"5c:cf:7f:0d:42:e6

dove STAIP sta, come già spiegato in precedenza, per Station IP,
ovvero l’indirizzo IP che il modulo gestisce quando si collega ad
esempio al nostro router wireless, mentre APIP sta per Access Point
IP, ovvero l’indirizzo IP del modulo quando funge appunto da Access
Point e quindi quando dà la possibilità di collegarsi a esso.
Per iniziare, vediamo la gestione degli IP in modalità station. Per
verificare l’attuale configurazione possiamo usare il seguente
comando:
AT+CIPSTA_CUR?

che restituirà qualcosa del tipo seguente:
+CIPSTA_CUR:ip:"192.168.20.5"
+CIPSTA_CUR:gateway:"192.168.20.1"
+CIPSTA_CUR:netmask:"255.255.255.0"

L’output mostra gli attuali parametri di rete fondamentali per qualsiasi
connessione: IP, gateway e netmask. Può essere utile, a questo
punto della trattazione, spendere qualche parola di carattere
generale sugli indirizzi IP e la loro gestione. Come dovrebbe essere
noto, un indirizzo IP è l’identificativo associato a una interfaccia di
rete con il quale è resa possibile la comunicazione attraverso i
protocolli della rete Internet. Ogni macchina necessita quindi di un
tale indirizzo per poter comunicare in rete. Oltre a questo è
necessario specificare la netmask, nota anche come maschera di
rete, che rende possibile l’identificazione delle macchine che
appartengono alla stessa rete della macchina in esame. Infine, è
necessario indicare il cosiddetto gateway di default o, più

semplicemente, gateway, che indica l’IP della macchina con la
quale dobbiamo comunicare per raggiungere una macchina di
destinazione che non appartiene alla nostra rete. Per specificare
questi parametri in maniera statica possiamo usare il seguente
comando:
AT+CIPSTA_CUR="192.168.1.33"

dove 192.168.1.33 è l’indirizzo IP che vogliamo associare al nostro
modulo. Interrogando nuovamente il modulo con il comando
AT+CIPSTA_CUR? avremo un output del tipo seguente:
+CIPSTA_CUR:ip:"192.168.1.33"
+CIPSTA_CUR:gateway:"192.168.1.1"
+CIPSTA_CUR:netmask:"255.255.255.0"

Scopriremo cioè che il comando ha impostato per noi anche un
gateway e una netmask di tipo predefinito che andrà bene nella
maggioranza dei casi. Volendo impostare dei parametri
personalizzati potremo scrivere il comando in questione nella forma
seguente:
AT+CIPSTA_CUR="192.168.1.33","192.168.6.101","255.255.255.0"

potendo specificare, separati da una virgola, nell’ordine, l’indirizzo IP,
il gateway e la maschera di rete. Tuttavia, la configurazione così
ottenuta non viene salvata nella memoria flash del modulo. Per
rendercene conto è possibile utilizzare il seguente comando:
AT+CIPSTA_DEF?

che mostra la configurazione salvata in maniera permanente nel
modulo. Per modificare tale configurazione è allora possibile
utilizzare il comando AT+CIPSTA_DEF con le stesse modalità appena
viste per il comando AT+CIPSTA_CUR. La sua sintassi è dunque la
seguente:
AT+CIPSTA_DEF=<IP>[,<gateway>,<netmask>]

con ovvio significato dei parametri richiesti.
A questo punto è di vitale importanza, per la verifica della

correttezza delle configurazioni che andiamo ad effettuare, utilizzare
degli strumenti diagnostici che ci consentano di stabilire se è
possibile comunicare tra i diversi apparati, come ad esempio tra il
nostro PC e il modulo ESP8266. Di norma questi strumenti sono dei
semplici comandi da utilizzarsi nella shell testuale del nostro sistema
operativo. Ad esempio, per conoscere l’IP del nostro computer
possiamo aprire un prompt dei comandi in Windows e digitare il
comando ipconfig. Con Linux o OS X possiamo, invece, usare il
terminale e digitare il comando ifconfig. Per verificare se riusciamo a
raggiungere dalla nostra macchina un certo IP possiamo utilizzare
un apposito comando, uguale nei vari sistemi operativi, di nome ping.
Per tale scopo scriviamo un comando del tipo:
ping 192.168.1.33

dove 192.168.1.33 è l’IP della macchina di cui vogliamo testare la
raggiungibilità. Nel nostro caso, questo è proprio l’IP che abbiamo
appena assegnato al modulo. La riuscita o meno della
comunicazione viene chiaramente indicata dall’output del comando.

Figura 28.26 – Il comando ping per verificare la connettività tra PC e
modulo ESP-01 ESP8266.

Modalità Access Point
Vediamo ora, invece, come assegnare un indirizzo statico al nostro
modulo nel momento in cui lo impostiamo in modalità di tipo Access
Point. Scopriremo che la procedura è del tutto simile al caso
precedente con, ovviamente, nomi di comandi differenti. Innanzitutto

proviamo il comando per visualizzare l’attuale configurazione IP del
modulo di tipo AP:
AT+CIPAP_CUR?

otterremo quindi qualcosa del tipo seguente:
+CIPAP:ip:"192.168.20.6"
+CIPAP:gateway:"192.168.20.6"
+CIPAP:netmask:"255.255.255.0"

Utilizziamo quindi il comando, togliendo il punto interrogativo finale,
andando a specificare un indirizzo IP per il modulo:
AT+CIPAP_CUR="192.168.1.66"

dove, ovviamente, 192.168.1.66 è l’indirizzo che vogliamo impostare.
Interrogando nuovamente lo stato del modulo con il comando
AT+CIPAP_CUR? otterremo la seguente situazione:
+CIPAP_CUR:ip:"192.168.1.66"
+CIPAP_CUR:gateway:"192.168.1.66"
+CIPAP_CUR:netmask:"255.255.255.0"

Anche in questo caso, il suffisso _CUR ci fa intuire che la
configurazione realizzata con il comando in questione è di tipo
momentanea (corrente) ma non è stata salvata nella memoria flash.
Per ottenere quest’ultimo risultato dovremo utilizzare, invece, il
comando:
AT+CIPAP_DEF="192.168.1.66"

che imporrà l’IP specificato come default.
Bisogna prestare molta attenzione al fatto che l’IP dell’Access Point
può essere “pingato” con successo, ovvero usando il comando ping
riusciamo a verificare la presenza della connessione, solo se ci
connettiamo alla rete dell’Access Point stesso. In altre parole, non è
sufficiente che l’IP del computer che stiamo utilizzando per la
programmazione e l’IP del modulo appartengano alla stessa rete,
ma è invece necessario che il PC sia connesso alla rete dell’Access
Point. In caso contrario, utilizzando il comando:

ping 192.168.1.66

otterremo qualcosa del tipo:
Esecuzione di Ping 192.168.1.66 con 32 byte di dati:
Risposta da 192.168.1.101: Host di destinazione non
raggiungibile.
...

Infatti, dal nostro PC possiamo pingare direttamente solo l’IP di tipo
station. Invece, per rendere possibile la comunicazione tra il PC e
l’Access Point, dobbiamo, come già detto, collegarci a tale Access
Point attraverso le modalità dello specifico sistema operativo. In
Figura 28.27 viene mostrato l’elenco dei dispositivi wireless con il
modulo ESP8266 che viene indicato come qualcosa del tipo AITHINKER_X. La rete, per semplicità di sperimentazione, è attualmente
aperta.

Figura 28.27 – La selezione del modulo wireless ESP-01 ESP8266.
Ovviamente, nel momento in cui accederemo a tale rete, perderemo
la connettività a Internet.

NOTA Per cambiare il nome del modulo (SSID), impostare una

password di accesso e specificare la modalità di
protezione è possibile fare riferimento ai comandi
AT+CWSAP_CUR e AT+CWSAP_DEF.

L’ESP8266 impostato come server
Verifichiamo allora come poter gestire il modulo ESP8266 come un
server. Per prima cosa dobbiamo impostare il modulo in modalità
Access Point con il comando:
AT+CWMODE_CUR=2

oppure, analogamente, con il comando AT+CWMODE_CUR=3 che imposta
entrambe le modalità (Station + AP). Come si intuisce dal suffisso
_CUR, anche in questo caso l’impostazione non è permanente. Per
impostare, invece, salvando su flash la modalità desiderata useremo
il comando:
AT+CWMODE_DEF=2

oppure, AT+CWMODE_DEF=3 per la modalità Station e AP insieme. Per
interrogare il modulo e verificare quale sia la modalità attualmente
impostata possiamo usare i comandi AT+CWMODE_CUR? e AT+CWMODE_DEF?,
rispettivamente per la modalità corrente e quella di default.
Inoltre, dobbiamo richiedere al modulo di accettare connessioni
multiple, provenienti evidentemente da eventuali differenti client, con
il seguente comando:
AT+CIPMUX=1

A questo punto dobbiamo indicare la porta sulla quale il nostro
server resterà in attesa delle richieste di connessione da parte dei
client. Per farlo utilizziamo il seguente comando:
AT+CIPSERVER=1,80

che imposta la porta 80 come porta di ascolto. Avremmo ovviamente
potuto scegliere una qualsiasi altra porta. Una porta non è altro che
un identificativo numerico che il sistema operativo consente di
associare a uno specifico servizio e che consente di poter gestire
contemporaneamente più servizi di tipo server associati allo stesso
indirizzo IP. Per completezza, vale la pena di ricordare che l’unione

di un indirizzo IP e di un numero di porta prende il nome tecnico di
socket.

Come già spiegato in precedenza, affinché le successive
connessioni tra il PC e il modulo siano possibili, è
NOTA
necessario che il PC si connetta alla rete wireless del
modulo ESP8266.
Non ci resta quindi che interrogare il nostro server, utilizzando un
qualsiasi client capace di effettuare una richiesta sulla porta 80
appena aperta sul nostro modulo. Il modo più semplice, che
dimostra in effetti che la porta 80 non era una scelta del tutto
casuale, è quella di utilizzare un browser qualsiasi come ad esempio
Google Chrome e indicare, nella barra degli indirizzi, l’IP dell’Access
Point che, nel caso del nostro esempio, è 192.168.1.66. Come tutta
risposta vedremo comparire nel serial monitor un messaggio simile
al seguente:
0,CONNECT
+IPD,0,391:GET / HTTP/1.1
Host: 192.168.1.66
Connection: keep-alive
Accept:
text/html,application/xhtml+xml,application/xml;q=0.9,image/web
p,*/*;q=0.8
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64)
AppleWebKit/537.36 (KHTML, like Gecko) Chrome/49.0.2623.87
Safari/537.36
Accept-Encoding: gzip, deflate, sdch
Accept-Language: it-IT,it;q=0.8,en-US;q=0.6,en;q=0.4

Si tratta, in buona sostanza, della richiesta effettuata dal browser
che per default effettua proprio una richiesta sulla porta 80 cercando
di comunicare con un web server. Per studiare in maniera più
dettagliata il tipo di comunicazione che si instaura tra client e server
possiamo effettuare la richiesta di connessione al server utilizzando
come client un qualsiasi emulatore di terminale, come ad esempio
PuTTY oppure TeraTerm, solo per citarne alcuni. Entrambi i software

citati sono gratuiti e facilmente scaricabili da Internet. Sarà
sufficiente allora impostare il protocollo Telnet indicando la porta 80
e l’indirizzo IP del modulo ESP8266 per effettuare il collegamento,
così come visibile in Figura 28.28, usando come esempio PuTTY.

Figura 28.28 – L’emulatore PuTTY con i parametri di collegamento
per il modulo ESP-01 ESP8266.
Una volta effettuata la connessione, nel serial monitor dovremo
vedere un messaggio del tipo:
0,CONNECT
+IPD,0,21:ÿûÿû ÿûÿû'ÿýÿûÿý

che conferma appunto l’avvenuta connessione. Da questo momento
in poi tutto ciò che digiteremo nella finestra dell’emulatore PuTTY
verrà trasferito via Wi-Fi al modulo ESP e sarà leggibile nel nostro
serial monitor. Una sessione di comunicazione di tale tipologia è
visibile in Figura 28.29.
Dalla figura in questione si evince un particolare di grande interesse
relativamente a come il serial monitor raccoglie il testo inviato dal
client, come ad esempio nella riga:
+IPD,0,14:Salve da PuTTY

Il primo numero, in questo caso zero, rappresenta l’identificativo del
client. Per ogni client connesso, infatti, il modulo tiene traccia di
questo identificativo al fine di poterlo riconoscere per un’eventuale
risposta. Il secondo numero, invece, indica la lunghezza del testo
trasferito prima di ogni singola digitazione del tasto Invio. A questo
punto possiamo quindi rispondere al client sfruttando il serial monitor
e scrivendo un comando del tipo:

AT+CIPSEND=0,42

Figura 28.29 – L’emulatore PuTTY e il modulo ESP-01 ESP8266
stabiliscono una connessione.
dove il numero zero rappresenta l’identificativo del client al quale
vogliamo rispondere e 42 sono i caratteri che ci accingiamo a
inviare. Subito dopo l’inserimento del comando appena visto, nel
serial monitor comparirà il simbolo di maggiore > a indicare che il
server è pronto per raccogliere la risposta da inviare verso il client.
Ad esempio potremo scrivere, sfruttando esattamente 42 caratteri, il
seguente messaggio:
Lunga vita e prosperità dal modulo ESP8266

che vedremo comparire nel terminale di PuTTY, che rappresenta il
nostro client, così come mostrato in Figura 28.30.
Non ci resta, a questo punto, che chiudere la connessione aperta
con il comando:
AT+CIPCLOSE=ID

dove ID è l’identificativo della connessione precedentemente aperta.
Nel caso dell’esempio, scriveremo quindi:
AT+CIPCLOSE=0

Figura 28.30 – Esempio di scambio di dati tra il modulo ESP-01
ESP8266 e l’emulatore PuTTY.

Web chiama ESP8266: rispondete!
Sfruttando la conoscenza dei principali comandi di gestione del
modulo ESP8266 appena acquisiti, possiamo spingerci oltre
realizzando uno sketch di maggiore complessità e utilità. Ci
prefiggiamo allora di realizzare uno sketch che gestisca un server in
ascolto sulla porta 80 e che quindi consenta di collegarsi al nostro
modulo, via Wi-Fi e tramite un qualsiasi browser web, comandando il
nostro solito LED.
Per semplificare al massimo l’intera operazione, supporremo che
ogni qualvolta richiameremo nel browser il modulo ESP8266, tramite
il suo indirizzo IP, sarà come azionare un interruttore di controllo del
LED sul pin 13: se questo è spento lo accenderemo, mentre se esso
è acceso lo spegneremo.
Poiché il modulo dovrà, per forza di cose, segnalare il

completamento dell’operazione al browser web, tale segnalazione
dovrà avvenire inviando al browser chiamante una specifica pagina
web. La pagina web in questione verrà creata al volo e restituita al
browser attraverso il comando AT+CIPSEND, visto in precedenza.
Una pagina web non è altro che un insieme di istruzioni di tipo
testuale realizzate in linguaggio HTML. Tale linguaggio è, almeno in
relazione a un utilizzo minimale, di estrema semplicità. Seppure la
sua conoscenza sia ormai molto diffusa, per completezza di
trattazione, vediamone di seguito i suoi aspetti fondamentali. Esso si
basa su di una serie di marcatori che definiscono la formattazione
degli elementi sulla pagina stessa. Un marcatore è costituito da una
parola chiave racchiusa tra i simboli di minore e maggiore.
Il testo della pagina che faremo restituire al modulo è
sostanzialmente il seguente:
<html>
<head>
<title>ESP8266 - Controllo LED</title>
</head>
<body>
<h1>ESP8266 - Controllo LED</h1>
<h2>LED acceso!</h2>
<h2>LED spento!</h2>
</body>
</html>

Generalmente un marcatore, più noto con il termine di tag, prevede
un’apertura, ovvero una indicazione di inizio del suo funzionamento,
e una chiusura, per indicare appunto quando tale comportamento
deve cessare.
Il tag di chiusura è identificato dal fatto che all’interno delle parentesi
angolari (i simboli di minore e maggiore) la parola chiave è
preceduta dal simbolo / di slash. Ad esempio, il principale tag, <html>
che indica l’inizio del documento, prevede un tag di chiusura scritto
come </html>. All’interno del blocco di tag <html></html> troviamo una
sezione di intestazione della pagina delimitata dai tag <head> e </head>.
In questa sezione vengono di norma inserite informazioni utili ai
motori di ricerca che indicizzano le pagine presenti in Internet.
Tra queste informazioni quella che non manca mai è relativa al titolo

della pagina, indicato con i tag <title> e </title>. Il titolo è il testo che
appare all’interno della finestra del browser, nella sezione superiore,
nota appunto come title bar o caption bar. Il contenuto vero e
proprio della pagina web è racchiuso tra i tag <body> e </body>. Qui
inseriremo un testo con grande evidenza utilizzando il tag <h1>. La
lettera h del tag in oggetto è l’iniziale della parola inglese header, che
significa intestazione, e che consente di inserire del testo che risalti
all’interno del documento. Il numero 1 insieme al tag h indica la
massima dimensione possibile.
Subito dopo sfruttiamo lo stesso tag, ma con il numero 2, inserendo
del testo con una dimensione leggermente minore rispetto al
precedente. Ovviamente, delle due istruzioni <h2>LED acceso!</h2> e
<h2>LED spento!</h2> ne dovremo inserire una sola, a seconda della
situazione reale del LED.
Se si trattasse di un pagina HTML statica avremmo dovuto salvare il
file sul disco del nostro computer in formato testuale utilizzando
un’estensione di file tipo .htm oppure .html. Tali file possono essere
prodotti da un qualsiasi editor di testi, tipo il Blocco Note di Windows,
anche se in generale si preferiscono editor più evoluti come
Notepad++ o PSPad, solo per citarne un paio. Tuttavia, il nostro
codice HTML, come già detto in precedenza, dovrà essere prodotto
in maniera dinamica all’interno del nostro sketch.
Per semplicità di trattazione, cominciamo con il vedere la parte
iniziale dello sketch con la funzione setup():
#include <SoftwareSerial.h>
const int RX = 2;
const int TX = 3;
const int LED = 13; // Il LED è collegato sul pin 13
SoftwareSerial Esp8266(RX, TX);
void setup()
{
Serial.begin(9600);
Esp8266.begin(9600);
//impostiamo il pin LED come output e lo spegniamo
pinMode(LED, OUTPUT);
digitalWrite(LED, LOW);
//settaggio modulo ESP8266
InviaDati("AT+RST\r\n", 2000); // reset del modulo

InviaDati("AT+CWMODE_CUR=2\r\n", 1000); // configurazione
modulo come Access Point
InviaDati("AT+CIFSR\r\n", 1000); // stampa indirizzo IP
InviaDati("AT+CIPMUX=1\r\n", 1000); // predisposizione
modulo per connessioni multiple
InviaDati("AT+CIPSERVER=1,80\r\n", 1000); // abilitazione
server sulla porta 80
Serial.println("Comunicazione inizializzata!");
Serial.println("Il modulo Esp8266 e' in attesa di richieste
via web.");
}

Come è possibile osservare, la prima parte dello sketch è familiare.
Infatti, dopo aver incluso la libreria SoftwareSerial.h, definiamo
l’oggetto Esp8266 indicando i soliti terminali RX e TX e definiamo la
costante LED associata al numero 13. Successivamente impostiamo
le velocità di comunicazione per la seriale hardware e quella
software e quindi definiamo il pin LED, ovvero 13, come output,
spegnendolo subito dopo.
In questo sketch, tuttavia, introduciamo una novità di gestione del
codice relativa a una specifica funzione, che chiamiamo InviaDati,
che semplifica appunto l’invio dei dati verso il modulo ESP. Infatti, la
funzione prende in input il comando da far eseguire al modulo e il
rispettivo tempo di attesa, timeout, da utilizzare al fine di consentire il
riempimento del buffer, come già visto in precedenza.
/* Invio dati al modulo Esp8266 */
void InviaDati(String comando, int timeout)
{
String risposta = "";
Esp8266.print(comando); // invio comando verso il modulo
ESP8266
delay(timeout); //attesa per riempire il buffer di risposta
char c;
while (Esp8266.available()>0)
{
// Il modulo ESP8266 sta inviando dati
c = Esp8266.read(); // lettura carattere successivo
risposta+=c;
}
//stampa per debug

Serial.print(risposta);
return;
}

Le funzioni di Arduino sono pressoché identiche a quelle del C puro,
se non per il fatto che l’IDE non richiede come indispensabile
dichiarare preventivamente il prototipo della funzione. Il primo
argomento della funzione è una stringa della classe String. Infatti,
con Arduino possiamo utilizzare in modo classico le stringhe come
array di caratteri, ma volendo è possibile sfruttare la più comoda
classe String che mette a disposizione, ad esempio, l’operatore + di
concatenazione. La nostra funzione, come prima cosa, invia il
comando passato come primo argomento al modulo ESP e
successivamente attende per il riempimento del buffer di risposta.
Successivamente, con il ciclo while, preleviamo i caratteri della
risposta e li accodiamo nella stringa appositamente creata a tale
scopo. Il tutto può essere utile in fase di debug ed eventualmente
commentabile in fase di finalizzazione del codice in questione.
Non ci resta ora che analizzare il codice di esecuzione vero e proprio
contenuto nella funzione loop.
void loop()
{
if(Esp8266.available()>0) // Se il modulo ESP sta inviando
dati
{
//cerchiamo la stringa "+IPD," dopo della quale ci
aspettiamo di leggere l'ID della connessione
if(Esp8266.find("+IPD,"))
{
delay(1000); // attesa per caricare il buffer seriale
//Otteniamo l'ID della connessione in modo da poterla
successivamente anche chiudere.
//Il valore numerico di tale ID è ottenuto sottraendo
48 al valore letto tramite read()
int connID = Esp8266.read()-48;
//Se il LED è spento lo accendiamo mentre se è acceso
lo spegniamo
if (digitalRead(LED))
{
digitalWrite(LED, LOW); // spegne il LED

}
else
{
digitalWrite(LED, HIGH);
}

// accende il LED

//Inizio output
String strHtml = "";
strHtml +="<html><head><title>ESP8266 - Controllo
LED</title></head>";
strHtml +="<body><h1>ESP8266 - Controllo LED</h1>";
String cipSend;
cipSend = "AT+CIPSEND=";
cipSend += connID;
cipSend += ",";
cipSend += strHtml.length();
cipSend += "\r\n";
//inviamo il comando AT+CIPSEND= facendolo seguire da
connID
//e numero di byte da inviare subito di seguito
InviaDati(cipSend, 1000);
InviaDati(strHtml, 3000); //invio dati vero e proprio
if (digitalRead(LED))
{
strHtml ="<h2>LED acceso!</h2>";
}
else
{
strHtml = "<h2>LED spento!</h2>";
}
strHtml+= "</body></html>";
cipSend = "AT+CIPSEND=";
cipSend += connID;
cipSend += ",";
cipSend += strHtml.length();
cipSend += "\r\n";
InviaDati(cipSend, 1000);
InviaDati(strHtml, 2000);
//Fine output

//Chiudiamo la connessione
String cipClose;
cipClose = "AT+CIPCLOSE=";
cipClose += connID; // Aggiungo ID della connessione
cipClose += "\r\n";
InviaDati(cipClose, 1000); // chiude connessione
}
}
}

La

prima

cosa

che verifichiamo, attraverso il controllo
if(Esp8266.available()>0), è se il numero di byte che eventualmente sta
trasmettendo il modulo è maggiore di zero. In tal caso, effettuiamo
un nuovo controllo, if(Esp8266.find("+IPD,")), per verificare se
all’interno di questi dati vi sia la stringa +IPD che, come abbiamo visto
in precedenza, indica l’inizio di una trasmissione, facendo seguire
tale stringa da una virgola e dall’ID della connessione. La funzione
find(), infatti, legge lo stream seriale fino a quando non trova
l’argomento a esso passato. Se non lo trova, restituisce false, mentre
in caso positivo restituisce true e quindi si posiziona alla fine della
stringa trovata. In tale caso impostiamo un delay per dare il tempo
per far riempire il buffer. A questo punto possiamo finalmente
leggere il numero di connessione passato dopo la stringa IPD. Per
farlo scriviamo:
int connID = Esp8266.read()-48;

dove, banalmente, Esp8266.read() legge il byte di nostro interesse.
Tuttavia, prima di associarlo alla variabile connID, dobbiamo sottrarre
da esso il numero 48. Ciò è dovuto al fatto che read() legge il valore
decimale della posizione nella tavola ASCII relativamente al simbolo
in oggetto e quindi, per ottenere il valore di nostro interesse,
dobbiamo sottrarre il numero 48 che rappresenta la posizione in cui
iniziano i numeri. Infatti, al valore decimale 48 corrisponde il numero
zero, al valore decimale 49 il numero uno e così via fino al valore
decimale 57 che corrisponde al numero nove.
Arrivati a questo punto gestiamo il nostro semplice attuatore, ovvero
il solito LED sul pin 13, verificando se esso sia acceso o meno. In
caso risulti acceso lo spegneremo mentre in caso contrario
provvederemo ad accenderlo.

Possiamo quindi preparare l’output da restituire al client con il
comando AT+CIPSEND, per segnalare lo stato in cui abbiamo posto il
nostro LED. Per farlo usiamo la classe String, dichiarando una
variabile che chiamiamo strHtml in cui accodiamo il codice HTML che
costituirà la pagina web da restituire al nostro client che, essendo
con ogni probabilità un browser web, visualizzerà al suo interno il
codice in questione in maniera del tutto naturale. Per rendere il
codice più pulito utilizziamo una specifica variabile, cipSend, per
costruire appunto il comando AT+CIPSEND con il quale inviare il codice
HTML al nostro client. Ovviamente, costruiremo un apposito
messaggio di <h2>LED acceso</h2> oppure <h2>LED spento</h2> a seconda
dello stato del LED, verificato con l’istruzione digitalRead.
Al comando AT+CIPSEND= facciamo seguire l’ID della connessione, una
virgola e, sfruttando l’istruzione strHtml.length, la lunghezza in byte
della stringa di codice HTML che abbiamo appena costruito. Infine,
come ultima operazione, provvediamo a chiudere la connessione
con il client.

Figura 28.31 – La pagina web restituita dal modulo ESP-01
ESP8266.
È importante sottolineare, infine, come i comandi utilizzati finora
siano solo una parte di quelli disponibili per il nostro modulo
ESP8266. Infatti, sul sito di riferimento dell’azienda Espressif,
espressif.com, è possibile scaricare il manuale in formato PDF dal
titolo “ESP8266 AT Instruction Set”, ovvero la documentazione
completa dell’intero insieme di comandi AT che è possibile utilizzare
con il modulo in questione. Per ottenere tale documento, insieme ad
altra documentazione tecnica relativa al modulo, è possibile
utilizzare la funzionalità Search presente sul portale utilizzando

come chiave di ricerca il nome ESP8266.

Hardware libero e sperimentazione
Le osservazioni e le relative sperimentazioni che abbiamo realizzato
in questo capitolo non possono, ovviamente, essere minimamente
esaustive di un contesto talmente vasto come quello del physical
computing e del mondo dell’Internet delle cose. Molti degli approcci
utilizzati rappresentano, infatti, solo una delle possibili scelte in
merito a un tipo di collegamento piuttosto che a una scelta di
componenti o adattatori. Su questi presupposti, tuttavia, si possono
fondare le basi per futuri studi e approfondimenti sempre guidati
dalla passione per la scoperta di nuove possibili applicazioni
pratiche. Fortunatamente viviamo un momento di estrema
condivisione, non solo del contesto open source e quindi relativo al
software, ma anche, forse più inaspettatamente, rispetto alla
divulgazione libera di schemi e dettagli progettuali delle
apparecchiature elettroniche. Tale condivisione, che prende il nome
di hardware libero o, nella dizione inglese, open source hardware
o, più semplicemente open hardware, rappresenta un incredibile
volano per la diffusione di una cultura tecnico-scientifica che non sia
limitata a una ristretta cerchia di appassionati ma che sia, per quanto
possibile, di massa.


